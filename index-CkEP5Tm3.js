const __vite__mapDeps = (
 i,
 m = __vite__mapDeps,
 d = m.f ||
  (m.f = [
   "https://lmsbyrizal.vercel.app/assets/DashboardHome-C2mfH2Aj.js",
   "https://lmsbyrizal.vercel.app/assets/trending-up-BpWlKPTc.js",
   "https://lmsbyrizal.vercel.app/assets/QuestionBank-4vpR0hfT.js",
   "https://lmsbyrizal.vercel.app/assets/MathRenderer-XySJAvdR.js",
   "https://lmsbyrizal.vercel.app/assets/filter-CTbQ5-dH.js",
   "https://lmsbyrizal.vercel.app/assets/search-9tuKzuwu.js",
   "https://lmsbyrizal.vercel.app/assets/x-D4IKeWlL.js",
   "https://lmsbyrizal.vercel.app/assets/plus-BgCfmbo6.js",
   "https://lmsbyrizal.vercel.app/assets/check-square--8HQpFyU.js",
   "https://lmsbyrizal.vercel.app/assets/trash-2-CpHd4TEG.js",
   "https://lmsbyrizal.vercel.app/assets/lock-_5NyXZcH.js",
   "https://lmsbyrizal.vercel.app/assets/loader-2-CwuFfEYP.js",
   "https://lmsbyrizal.vercel.app/assets/arrow-left-mJ1mDUJA.js",
   "https://lmsbyrizal.vercel.app/assets/save-D7MOyr1V.js",
   "assets/StudentExam-Bu_ZnvWL.js",
   "https://lmsbyrizal.vercel.app/assets/wifi-off-CUYrWRG-.js",
   "https://lmsbyrizal.vercel.app/assets/alert-triangle-CP6CtVKR.js",
   "https://lmsbyrizal.vercel.app/assets/StudentDashboard-CI-qOt-Z.js",
   "https://lmsbyrizal.vercel.app/assets/StudentExamList-CUtuSQTO.js",
   "https://lmsbyrizal.vercel.app/assets/alert-circle-BL-h7AYW.js",
   "https://lmsbyrizal.vercel.app/assets/StudentProfile-ChT2w2lH.js",
   "https://lmsbyrizal.vercel.app/assets/book-XyCiiluC.js",
   "https://lmsbyrizal.vercel.app/assets/ExamSessions-UWO1rSwt.js",
   "https://lmsbyrizal.vercel.app/assets/xlsx-CKN5doRT.js",
   "https://lmsbyrizal.vercel.app/assets/square-CJ9HZJg_.js",
   "https://lmsbyrizal.vercel.app/assets/layers-BxZ4T1uB.js",
   "https://lmsbyrizal.vercel.app/assets/refresh-cw-C6DzP0cR.js",
   "https://lmsbyrizal.vercel.app/assets/check-circle-CJle1LFw.js",
   "https://lmsbyrizal.vercel.app/assets/pie-chart-Rhu2xJz9.js",
   "https://lmsbyrizal.vercel.app/assets/square-pen-CQwYQS0I.js",
   "https://lmsbyrizal.vercel.app/assets/LiveMonitoring-DyqnViSl.js",
   "https://lmsbyrizal.vercel.app/assets/StudentMonitor-CQAjFJUd.js",
   "https://lmsbyrizal.vercel.app/assets/download-DpCXkXT-.js",
   "https://lmsbyrizal.vercel.app/assets/ReportDescriptions-DyJHwgzB.js",
   "https://lmsbyrizal.vercel.app/assets/zap-B4hLDi5E.js",
   "https://lmsbyrizal.vercel.app/assets/PacketManager-C2Xm7OEs.js",
   "https://lmsbyrizal.vercel.app/assets/UserManagement-MPjDGs5L.js",
   "https://lmsbyrizal.vercel.app/assets/ClassAttendance-CD9Vy32v.js",
   "https://lmsbyrizal.vercel.app/assets/TeacherJournal-D2CrYiyl.js",
   "https://lmsbyrizal.vercel.app/assets/link-6TvFWqbF.js",
   "https://lmsbyrizal.vercel.app/assets/TeacherGradebook-C2CuulEv.js",
   "https://lmsbyrizal.vercel.app/assets/LegerNilai-DEODtUQp.js",
   "https://lmsbyrizal.vercel.app/assets/SchoolSettings-BEiXl1SY.js",
   "https://lmsbyrizal.vercel.app/assets/upload-atoaDX3Q.js",
   "https://lmsbyrizal.vercel.app/assets/SchoolSchedule-DL01YS_Q.js",
   "https://lmsbyrizal.vercel.app/assets/LearningMaterials-Bv1RAZY_.js",
   "https://lmsbyrizal.vercel.app/assets/ExamAnalysis-Br8lDBvy.js",
   "https://lmsbyrizal.vercel.app/assets/TeacherProfile-D2WrIX5v.js",
  ])
) => i.map((i) => d[i]);
function nN(t, e) {
 for (var n = 0; n < e.length; n++) {
  const r = e[n];
  if (typeof r != "string" && !Array.isArray(r)) {
   for (const i in r)
    if (i !== "default" && !(i in t)) {
     const o = Object.getOwnPropertyDescriptor(r, i);
     o && Object.defineProperty(t, i, o.get ? o : { enumerable: !0, get: () => r[i] });
    }
  }
 }
 return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
(function () {
 const e = document.createElement("link").relList;
 if (e && e.supports && e.supports("modulepreload")) return;
 for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
 new MutationObserver((i) => {
  for (const o of i)
   if (o.type === "childList") for (const s of o.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
 }).observe(document, { childList: !0, subtree: !0 });
 function n(i) {
  const o = {};
  return (
   i.integrity && (o.integrity = i.integrity),
   i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
   i.crossOrigin === "use-credentials"
    ? (o.credentials = "include")
    : i.crossOrigin === "anonymous"
      ? (o.credentials = "omit")
      : (o.credentials = "same-origin"),
   o
  );
 }
 function r(i) {
  if (i.ep) return;
  i.ep = !0;
  const o = n(i);
  fetch(i.href, o);
 }
})();
var hK =
 typeof globalThis < "u"
  ? globalThis
  : typeof window < "u"
    ? window
    : typeof global < "u"
      ? global
      : typeof self < "u"
        ? self
        : {};
function rN(t) {
 return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var hI = { exports: {} },
 Md = {},
 pI = { exports: {} },
 ue = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var xl = Symbol.for("react.element"),
 iN = Symbol.for("react.portal"),
 oN = Symbol.for("react.fragment"),
 sN = Symbol.for("react.strict_mode"),
 aN = Symbol.for("react.profiler"),
 lN = Symbol.for("react.provider"),
 uN = Symbol.for("react.context"),
 cN = Symbol.for("react.forward_ref"),
 dN = Symbol.for("react.suspense"),
 fN = Symbol.for("react.memo"),
 hN = Symbol.for("react.lazy"),
 I_ = Symbol.iterator;
function pN(t) {
 return t === null || typeof t != "object"
  ? null
  : ((t = (I_ && t[I_]) || t["@@iterator"]), typeof t == "function" ? t : null);
}
var mI = {
  isMounted: function () {
   return !1;
  },
  enqueueForceUpdate: function () {},
  enqueueReplaceState: function () {},
  enqueueSetState: function () {},
 },
 gI = Object.assign,
 yI = {};
function Vs(t, e, n) {
 (this.props = t), (this.context = e), (this.refs = yI), (this.updater = n || mI);
}
Vs.prototype.isReactComponent = {};
Vs.prototype.setState = function (t, e) {
 if (typeof t != "object" && typeof t != "function" && t != null)
  throw Error(
   "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
  );
 this.updater.enqueueSetState(this, t, e, "setState");
};
Vs.prototype.forceUpdate = function (t) {
 this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function vI() {}
vI.prototype = Vs.prototype;
function Gm(t, e, n) {
 (this.props = t), (this.context = e), (this.refs = yI), (this.updater = n || mI);
}
var zm = (Gm.prototype = new vI());
zm.constructor = Gm;
gI(zm, Vs.prototype);
zm.isPureReactComponent = !0;
var S_ = Array.isArray,
 _I = Object.prototype.hasOwnProperty,
 Wm = { current: null },
 wI = { key: !0, ref: !0, __self: !0, __source: !0 };
function EI(t, e, n) {
 var r,
  i = {},
  o = null,
  s = null;
 if (e != null)
  for (r in (e.ref !== void 0 && (s = e.ref), e.key !== void 0 && (o = "" + e.key), e))
   _I.call(e, r) && !wI.hasOwnProperty(r) && (i[r] = e[r]);
 var a = arguments.length - 2;
 if (a === 1) i.children = n;
 else if (1 < a) {
  for (var l = Array(a), u = 0; u < a; u++) l[u] = arguments[u + 2];
  i.children = l;
 }
 if (t && t.defaultProps) for (r in ((a = t.defaultProps), a)) i[r] === void 0 && (i[r] = a[r]);
 return { $$typeof: xl, type: t, key: o, ref: s, props: i, _owner: Wm.current };
}
function mN(t, e) {
 return { $$typeof: xl, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner };
}
function Km(t) {
 return typeof t == "object" && t !== null && t.$$typeof === xl;
}
function gN(t) {
 var e = { "=": "=0", ":": "=2" };
 return (
  "$" +
  t.replace(/[=:]/g, function (n) {
   return e[n];
  })
 );
}
var A_ = /\/+/g;
function rh(t, e) {
 return typeof t == "object" && t !== null && t.key != null ? gN("" + t.key) : e.toString(36);
}
function ac(t, e, n, r, i) {
 var o = typeof t;
 (o === "undefined" || o === "boolean") && (t = null);
 var s = !1;
 if (t === null) s = !0;
 else
  switch (o) {
   case "string":
   case "number":
    s = !0;
    break;
   case "object":
    switch (t.$$typeof) {
     case xl:
     case iN:
      s = !0;
    }
  }
 if (s)
  return (
   (s = t),
   (i = i(s)),
   (t = r === "" ? "." + rh(s, 0) : r),
   S_(i)
    ? ((n = ""),
      t != null && (n = t.replace(A_, "$&/") + "/"),
      ac(i, e, n, "", function (u) {
       return u;
      }))
    : i != null &&
      (Km(i) && (i = mN(i, n + (!i.key || (s && s.key === i.key) ? "" : ("" + i.key).replace(A_, "$&/") + "/") + t)),
      e.push(i)),
   1
  );
 if (((s = 0), (r = r === "" ? "." : r + ":"), S_(t)))
  for (var a = 0; a < t.length; a++) {
   o = t[a];
   var l = r + rh(o, a);
   s += ac(o, e, n, l, i);
  }
 else if (((l = pN(t)), typeof l == "function"))
  for (t = l.call(t), a = 0; !(o = t.next()).done; ) (o = o.value), (l = r + rh(o, a++)), (s += ac(o, e, n, l, i));
 else if (o === "object")
  throw (
   ((e = String(t)),
   Error(
    "Objects are not valid as a React child (found: " +
     (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) +
     "). If you meant to render a collection of children, use an array instead."
   ))
  );
 return s;
}
function Au(t, e, n) {
 if (t == null) return t;
 var r = [],
  i = 0;
 return (
  ac(t, r, "", "", function (o) {
   return e.call(n, o, i++);
  }),
  r
 );
}
function yN(t) {
 if (t._status === -1) {
  var e = t._result;
  (e = e()),
   e.then(
    function (n) {
     (t._status === 0 || t._status === -1) && ((t._status = 1), (t._result = n));
    },
    function (n) {
     (t._status === 0 || t._status === -1) && ((t._status = 2), (t._result = n));
    }
   ),
   t._status === -1 && ((t._status = 0), (t._result = e));
 }
 if (t._status === 1) return t._result.default;
 throw t._result;
}
var zt = { current: null },
 lc = { transition: null },
 vN = { ReactCurrentDispatcher: zt, ReactCurrentBatchConfig: lc, ReactCurrentOwner: Wm };
function TI() {
 throw Error("act(...) is not supported in production builds of React.");
}
ue.Children = {
 map: Au,
 forEach: function (t, e, n) {
  Au(
   t,
   function () {
    e.apply(this, arguments);
   },
   n
  );
 },
 count: function (t) {
  var e = 0;
  return (
   Au(t, function () {
    e++;
   }),
   e
  );
 },
 toArray: function (t) {
  return (
   Au(t, function (e) {
    return e;
   }) || []
  );
 },
 only: function (t) {
  if (!Km(t)) throw Error("React.Children.only expected to receive a single React element child.");
  return t;
 },
};
ue.Component = Vs;
ue.Fragment = oN;
ue.Profiler = aN;
ue.PureComponent = Gm;
ue.StrictMode = sN;
ue.Suspense = dN;
ue.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vN;
ue.act = TI;
ue.cloneElement = function (t, e, n) {
 if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
 var r = gI({}, t.props),
  i = t.key,
  o = t.ref,
  s = t._owner;
 if (e != null) {
  if (
   (e.ref !== void 0 && ((o = e.ref), (s = Wm.current)),
   e.key !== void 0 && (i = "" + e.key),
   t.type && t.type.defaultProps)
  )
   var a = t.type.defaultProps;
  for (l in e) _I.call(e, l) && !wI.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
 }
 var l = arguments.length - 2;
 if (l === 1) r.children = n;
 else if (1 < l) {
  a = Array(l);
  for (var u = 0; u < l; u++) a[u] = arguments[u + 2];
  r.children = a;
 }
 return { $$typeof: xl, type: t.type, key: i, ref: o, props: r, _owner: s };
};
ue.createContext = function (t) {
 return (
  (t = {
   $$typeof: uN,
   _currentValue: t,
   _currentValue2: t,
   _threadCount: 0,
   Provider: null,
   Consumer: null,
   _defaultValue: null,
   _globalName: null,
  }),
  (t.Provider = { $$typeof: lN, _context: t }),
  (t.Consumer = t)
 );
};
ue.createElement = EI;
ue.createFactory = function (t) {
 var e = EI.bind(null, t);
 return (e.type = t), e;
};
ue.createRef = function () {
 return { current: null };
};
ue.forwardRef = function (t) {
 return { $$typeof: cN, render: t };
};
ue.isValidElement = Km;
ue.lazy = function (t) {
 return { $$typeof: hN, _payload: { _status: -1, _result: t }, _init: yN };
};
ue.memo = function (t, e) {
 return { $$typeof: fN, type: t, compare: e === void 0 ? null : e };
};
ue.startTransition = function (t) {
 var e = lc.transition;
 lc.transition = {};
 try {
  t();
 } finally {
  lc.transition = e;
 }
};
ue.unstable_act = TI;
ue.useCallback = function (t, e) {
 return zt.current.useCallback(t, e);
};
ue.useContext = function (t) {
 return zt.current.useContext(t);
};
ue.useDebugValue = function () {};
ue.useDeferredValue = function (t) {
 return zt.current.useDeferredValue(t);
};
ue.useEffect = function (t, e) {
 return zt.current.useEffect(t, e);
};
ue.useId = function () {
 return zt.current.useId();
};
ue.useImperativeHandle = function (t, e, n) {
 return zt.current.useImperativeHandle(t, e, n);
};
ue.useInsertionEffect = function (t, e) {
 return zt.current.useInsertionEffect(t, e);
};
ue.useLayoutEffect = function (t, e) {
 return zt.current.useLayoutEffect(t, e);
};
ue.useMemo = function (t, e) {
 return zt.current.useMemo(t, e);
};
ue.useReducer = function (t, e, n) {
 return zt.current.useReducer(t, e, n);
};
ue.useRef = function (t) {
 return zt.current.useRef(t);
};
ue.useState = function (t) {
 return zt.current.useState(t);
};
ue.useSyncExternalStore = function (t, e, n) {
 return zt.current.useSyncExternalStore(t, e, n);
};
ue.useTransition = function () {
 return zt.current.useTransition();
};
ue.version = "18.3.1";
pI.exports = ue;
var W = pI.exports;
const De = rN(W),
 _N = nN({ __proto__: null, default: De }, [W]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var wN = W,
 EN = Symbol.for("react.element"),
 TN = Symbol.for("react.fragment"),
 IN = Object.prototype.hasOwnProperty,
 SN = wN.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
 AN = { key: !0, ref: !0, __self: !0, __source: !0 };
function II(t, e, n) {
 var r,
  i = {},
  o = null,
  s = null;
 n !== void 0 && (o = "" + n), e.key !== void 0 && (o = "" + e.key), e.ref !== void 0 && (s = e.ref);
 for (r in e) IN.call(e, r) && !AN.hasOwnProperty(r) && (i[r] = e[r]);
 if (t && t.defaultProps) for (r in ((e = t.defaultProps), e)) i[r] === void 0 && (i[r] = e[r]);
 return { $$typeof: EN, type: t, key: o, ref: s, props: i, _owner: SN.current };
}
Md.Fragment = TN;
Md.jsx = II;
Md.jsxs = II;
hI.exports = Md;
var L = hI.exports,
 np = {},
 SI = { exports: {} },
 mn = {},
 AI = { exports: {} },
 CI = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
 function e(z, Z) {
  var ae = z.length;
  z.push(Z);
  e: for (; 0 < ae; ) {
   var Le = (ae - 1) >>> 1,
    Ae = z[Le];
   if (0 < i(Ae, Z)) (z[Le] = Z), (z[ae] = Ae), (ae = Le);
   else break e;
  }
 }
 function n(z) {
  return z.length === 0 ? null : z[0];
 }
 function r(z) {
  if (z.length === 0) return null;
  var Z = z[0],
   ae = z.pop();
  if (ae !== Z) {
   z[0] = ae;
   e: for (var Le = 0, Ae = z.length, We = Ae >>> 1; Le < We; ) {
    var cr = 2 * (Le + 1) - 1,
     dr = z[cr],
     fr = cr + 1,
     hr = z[fr];
    if (0 > i(dr, ae))
     fr < Ae && 0 > i(hr, dr) ? ((z[Le] = hr), (z[fr] = ae), (Le = fr)) : ((z[Le] = dr), (z[cr] = ae), (Le = cr));
    else if (fr < Ae && 0 > i(hr, ae)) (z[Le] = hr), (z[fr] = ae), (Le = fr);
    else break e;
   }
  }
  return Z;
 }
 function i(z, Z) {
  var ae = z.sortIndex - Z.sortIndex;
  return ae !== 0 ? ae : z.id - Z.id;
 }
 if (typeof performance == "object" && typeof performance.now == "function") {
  var o = performance;
  t.unstable_now = function () {
   return o.now();
  };
 } else {
  var s = Date,
   a = s.now();
  t.unstable_now = function () {
   return s.now() - a;
  };
 }
 var l = [],
  u = [],
  h = 1,
  p = null,
  m = 3,
  v = !1,
  w = !1,
  C = !1,
  A = typeof setTimeout == "function" ? setTimeout : null,
  T = typeof clearTimeout == "function" ? clearTimeout : null,
  _ = typeof setImmediate < "u" ? setImmediate : null;
 typeof navigator < "u" &&
  navigator.scheduling !== void 0 &&
  navigator.scheduling.isInputPending !== void 0 &&
  navigator.scheduling.isInputPending.bind(navigator.scheduling);
 function E(z) {
  for (var Z = n(u); Z !== null; ) {
   if (Z.callback === null) r(u);
   else if (Z.startTime <= z) r(u), (Z.sortIndex = Z.expirationTime), e(l, Z);
   else break;
   Z = n(u);
  }
 }
 function N(z) {
  if (((C = !1), E(z), !w))
   if (n(l) !== null) (w = !0), $r(M);
   else {
    var Z = n(u);
    Z !== null && _n(N, Z.startTime - z);
   }
 }
 function M(z, Z) {
  (w = !1), C && ((C = !1), T(I), (I = -1)), (v = !0);
  var ae = m;
  try {
   for (E(Z), p = n(l); p !== null && (!(p.expirationTime > Z) || (z && !x())); ) {
    var Le = p.callback;
    if (typeof Le == "function") {
     (p.callback = null), (m = p.priorityLevel);
     var Ae = Le(p.expirationTime <= Z);
     (Z = t.unstable_now()), typeof Ae == "function" ? (p.callback = Ae) : p === n(l) && r(l), E(Z);
    } else r(l);
    p = n(l);
   }
   if (p !== null) var We = !0;
   else {
    var cr = n(u);
    cr !== null && _n(N, cr.startTime - Z), (We = !1);
   }
   return We;
  } finally {
   (p = null), (m = ae), (v = !1);
  }
 }
 var F = !1,
  P = null,
  I = -1,
  R = 5,
  k = -1;
 function x() {
  return !(t.unstable_now() - k < R);
 }
 function D() {
  if (P !== null) {
   var z = t.unstable_now();
   k = z;
   var Z = !0;
   try {
    Z = P(!0, z);
   } finally {
    Z ? b() : ((F = !1), (P = null));
   }
  } else F = !1;
 }
 var b;
 if (typeof _ == "function")
  b = function () {
   _(D);
  };
 else if (typeof MessageChannel < "u") {
  var se = new MessageChannel(),
   Jt = se.port2;
  (se.port1.onmessage = D),
   (b = function () {
    Jt.postMessage(null);
   });
 } else
  b = function () {
   A(D, 0);
  };
 function $r(z) {
  (P = z), F || ((F = !0), b());
 }
 function _n(z, Z) {
  I = A(function () {
   z(t.unstable_now());
  }, Z);
 }
 (t.unstable_IdlePriority = 5),
  (t.unstable_ImmediatePriority = 1),
  (t.unstable_LowPriority = 4),
  (t.unstable_NormalPriority = 3),
  (t.unstable_Profiling = null),
  (t.unstable_UserBlockingPriority = 2),
  (t.unstable_cancelCallback = function (z) {
   z.callback = null;
  }),
  (t.unstable_continueExecution = function () {
   w || v || ((w = !0), $r(M));
  }),
  (t.unstable_forceFrameRate = function (z) {
   0 > z || 125 < z
    ? console.error(
       "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      )
    : (R = 0 < z ? Math.floor(1e3 / z) : 5);
  }),
  (t.unstable_getCurrentPriorityLevel = function () {
   return m;
  }),
  (t.unstable_getFirstCallbackNode = function () {
   return n(l);
  }),
  (t.unstable_next = function (z) {
   switch (m) {
    case 1:
    case 2:
    case 3:
     var Z = 3;
     break;
    default:
     Z = m;
   }
   var ae = m;
   m = Z;
   try {
    return z();
   } finally {
    m = ae;
   }
  }),
  (t.unstable_pauseExecution = function () {}),
  (t.unstable_requestPaint = function () {}),
  (t.unstable_runWithPriority = function (z, Z) {
   switch (z) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
     break;
    default:
     z = 3;
   }
   var ae = m;
   m = z;
   try {
    return Z();
   } finally {
    m = ae;
   }
  }),
  (t.unstable_scheduleCallback = function (z, Z, ae) {
   var Le = t.unstable_now();
   switch (
    (typeof ae == "object" && ae !== null
     ? ((ae = ae.delay), (ae = typeof ae == "number" && 0 < ae ? Le + ae : Le))
     : (ae = Le),
    z)
   ) {
    case 1:
     var Ae = -1;
     break;
    case 2:
     Ae = 250;
     break;
    case 5:
     Ae = 1073741823;
     break;
    case 4:
     Ae = 1e4;
     break;
    default:
     Ae = 5e3;
   }
   return (
    (Ae = ae + Ae),
    (z = { id: h++, callback: Z, priorityLevel: z, startTime: ae, expirationTime: Ae, sortIndex: -1 }),
    ae > Le
     ? ((z.sortIndex = ae), e(u, z), n(l) === null && z === n(u) && (C ? (T(I), (I = -1)) : (C = !0), _n(N, ae - Le)))
     : ((z.sortIndex = Ae), e(l, z), w || v || ((w = !0), $r(M))),
    z
   );
  }),
  (t.unstable_shouldYield = x),
  (t.unstable_wrapCallback = function (z) {
   var Z = m;
   return function () {
    var ae = m;
    m = Z;
    try {
     return z.apply(this, arguments);
    } finally {
     m = ae;
    }
   };
  });
})(CI);
AI.exports = CI;
var CN = AI.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var RN = W,
 hn = CN;
function H(t) {
 for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)
  e += "&args[]=" + encodeURIComponent(arguments[n]);
 return (
  "Minified React error #" +
  t +
  "; visit " +
  e +
  " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
 );
}
var RI = new Set(),
 Za = {};
function To(t, e) {
 _s(t, e), _s(t + "Capture", e);
}
function _s(t, e) {
 for (Za[t] = e, t = 0; t < e.length; t++) RI.add(e[t]);
}
var Cr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
 rp = Object.prototype.hasOwnProperty,
 PN =
  /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
 C_ = {},
 R_ = {};
function kN(t) {
 return rp.call(R_, t) ? !0 : rp.call(C_, t) ? !1 : PN.test(t) ? (R_[t] = !0) : ((C_[t] = !0), !1);
}
function bN(t, e, n, r) {
 if (n !== null && n.type === 0) return !1;
 switch (typeof e) {
  case "function":
  case "symbol":
   return !0;
  case "boolean":
   return r
    ? !1
    : n !== null
      ? !n.acceptsBooleans
      : ((t = t.toLowerCase().slice(0, 5)), t !== "data-" && t !== "aria-");
  default:
   return !1;
 }
}
function NN(t, e, n, r) {
 if (e === null || typeof e > "u" || bN(t, e, n, r)) return !0;
 if (r) return !1;
 if (n !== null)
  switch (n.type) {
   case 3:
    return !e;
   case 4:
    return e === !1;
   case 5:
    return isNaN(e);
   case 6:
    return isNaN(e) || 1 > e;
  }
 return !1;
}
function Wt(t, e, n, r, i, o, s) {
 (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
  (this.attributeName = r),
  (this.attributeNamespace = i),
  (this.mustUseProperty = n),
  (this.propertyName = t),
  (this.type = e),
  (this.sanitizeURL = o),
  (this.removeEmptyString = s);
}
var vt = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
 .split(" ")
 .forEach(function (t) {
  vt[t] = new Wt(t, 0, !1, t, null, !1, !1);
 });
[
 ["acceptCharset", "accept-charset"],
 ["className", "class"],
 ["htmlFor", "for"],
 ["httpEquiv", "http-equiv"],
].forEach(function (t) {
 var e = t[0];
 vt[e] = new Wt(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
 vt[t] = new Wt(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) {
 vt[t] = new Wt(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
 .split(" ")
 .forEach(function (t) {
  vt[t] = new Wt(t, 3, !1, t.toLowerCase(), null, !1, !1);
 });
["checked", "multiple", "muted", "selected"].forEach(function (t) {
 vt[t] = new Wt(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function (t) {
 vt[t] = new Wt(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (t) {
 vt[t] = new Wt(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function (t) {
 vt[t] = new Wt(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var Jm = /[\-:]([a-z])/g;
function Ym(t) {
 return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
 .split(" ")
 .forEach(function (t) {
  var e = t.replace(Jm, Ym);
  vt[e] = new Wt(e, 1, !1, t, null, !1, !1);
 });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) {
 var e = t.replace(Jm, Ym);
 vt[e] = new Wt(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
 var e = t.replace(Jm, Ym);
 vt[e] = new Wt(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (t) {
 vt[t] = new Wt(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
vt.xlinkHref = new Wt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (t) {
 vt[t] = new Wt(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function Qm(t, e, n, r) {
 var i = vt.hasOwnProperty(e) ? vt[e] : null;
 (i !== null
  ? i.type !== 0
  : r || !(2 < e.length) || (e[0] !== "o" && e[0] !== "O") || (e[1] !== "n" && e[1] !== "N")) &&
  (NN(e, n, i, r) && (n = null),
  r || i === null
   ? kN(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n))
   : i.mustUseProperty
     ? (t[i.propertyName] = n === null ? (i.type === 3 ? !1 : "") : n)
     : ((e = i.attributeName),
       (r = i.attributeNamespace),
       n === null
        ? t.removeAttribute(e)
        : ((i = i.type),
          (n = i === 3 || (i === 4 && n === !0) ? "" : "" + n),
          r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))));
}
var Lr = RN.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
 Cu = Symbol.for("react.element"),
 zo = Symbol.for("react.portal"),
 Wo = Symbol.for("react.fragment"),
 Xm = Symbol.for("react.strict_mode"),
 ip = Symbol.for("react.profiler"),
 PI = Symbol.for("react.provider"),
 kI = Symbol.for("react.context"),
 jm = Symbol.for("react.forward_ref"),
 op = Symbol.for("react.suspense"),
 sp = Symbol.for("react.suspense_list"),
 Zm = Symbol.for("react.memo"),
 Yr = Symbol.for("react.lazy"),
 bI = Symbol.for("react.offscreen"),
 P_ = Symbol.iterator;
function fa(t) {
 return t === null || typeof t != "object"
  ? null
  : ((t = (P_ && t[P_]) || t["@@iterator"]), typeof t == "function" ? t : null);
}
var Fe = Object.assign,
 ih;
function Ca(t) {
 if (ih === void 0)
  try {
   throw Error();
  } catch (n) {
   var e = n.stack.trim().match(/\n( *(at )?)/);
   ih = (e && e[1]) || "";
  }
 return (
  `
` +
  ih +
  t
 );
}
var oh = !1;
function sh(t, e) {
 if (!t || oh) return "";
 oh = !0;
 var n = Error.prepareStackTrace;
 Error.prepareStackTrace = void 0;
 try {
  if (e)
   if (
    ((e = function () {
     throw Error();
    }),
    Object.defineProperty(e.prototype, "props", {
     set: function () {
      throw Error();
     },
    }),
    typeof Reflect == "object" && Reflect.construct)
   ) {
    try {
     Reflect.construct(e, []);
    } catch (u) {
     var r = u;
    }
    Reflect.construct(t, [], e);
   } else {
    try {
     e.call();
    } catch (u) {
     r = u;
    }
    t.call(e.prototype);
   }
  else {
   try {
    throw Error();
   } catch (u) {
    r = u;
   }
   t();
  }
 } catch (u) {
  if (u && r && typeof u.stack == "string") {
   for (
    var i = u.stack.split(`
`),
     o = r.stack.split(`
`),
     s = i.length - 1,
     a = o.length - 1;
    1 <= s && 0 <= a && i[s] !== o[a];

   )
    a--;
   for (; 1 <= s && 0 <= a; s--, a--)
    if (i[s] !== o[a]) {
     if (s !== 1 || a !== 1)
      do
       if ((s--, a--, 0 > a || i[s] !== o[a])) {
        var l =
         `
` + i[s].replace(" at new ", " at ");
        return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l;
       }
      while (1 <= s && 0 <= a);
     break;
    }
  }
 } finally {
  (oh = !1), (Error.prepareStackTrace = n);
 }
 return (t = t ? t.displayName || t.name : "") ? Ca(t) : "";
}
function xN(t) {
 switch (t.tag) {
  case 5:
   return Ca(t.type);
  case 16:
   return Ca("Lazy");
  case 13:
   return Ca("Suspense");
  case 19:
   return Ca("SuspenseList");
  case 0:
  case 2:
  case 15:
   return (t = sh(t.type, !1)), t;
  case 11:
   return (t = sh(t.type.render, !1)), t;
  case 1:
   return (t = sh(t.type, !0)), t;
  default:
   return "";
 }
}
function ap(t) {
 if (t == null) return null;
 if (typeof t == "function") return t.displayName || t.name || null;
 if (typeof t == "string") return t;
 switch (t) {
  case Wo:
   return "Fragment";
  case zo:
   return "Portal";
  case ip:
   return "Profiler";
  case Xm:
   return "StrictMode";
  case op:
   return "Suspense";
  case sp:
   return "SuspenseList";
 }
 if (typeof t == "object")
  switch (t.$$typeof) {
   case kI:
    return (t.displayName || "Context") + ".Consumer";
   case PI:
    return (t._context.displayName || "Context") + ".Provider";
   case jm:
    var e = t.render;
    return (
     (t = t.displayName),
     t || ((t = e.displayName || e.name || ""), (t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")),
     t
    );
   case Zm:
    return (e = t.displayName || null), e !== null ? e : ap(t.type) || "Memo";
   case Yr:
    (e = t._payload), (t = t._init);
    try {
     return ap(t(e));
    } catch {}
  }
 return null;
}
function MN(t) {
 var e = t.type;
 switch (t.tag) {
  case 24:
   return "Cache";
  case 9:
   return (e.displayName || "Context") + ".Consumer";
  case 10:
   return (e._context.displayName || "Context") + ".Provider";
  case 18:
   return "DehydratedFragment";
  case 11:
   return (
    (t = e.render),
    (t = t.displayName || t.name || ""),
    e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")
   );
  case 7:
   return "Fragment";
  case 5:
   return e;
  case 4:
   return "Portal";
  case 3:
   return "Root";
  case 6:
   return "Text";
  case 16:
   return ap(e);
  case 8:
   return e === Xm ? "StrictMode" : "Mode";
  case 22:
   return "Offscreen";
  case 12:
   return "Profiler";
  case 21:
   return "Scope";
  case 13:
   return "Suspense";
  case 19:
   return "SuspenseList";
  case 25:
   return "TracingMarker";
  case 1:
  case 0:
  case 17:
  case 2:
  case 14:
  case 15:
   if (typeof e == "function") return e.displayName || e.name || null;
   if (typeof e == "string") return e;
 }
 return null;
}
function Si(t) {
 switch (typeof t) {
  case "boolean":
  case "number":
  case "string":
  case "undefined":
   return t;
  case "object":
   return t;
  default:
   return "";
 }
}
function NI(t) {
 var e = t.type;
 return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
}
function DN(t) {
 var e = NI(t) ? "checked" : "value",
  n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
  r = "" + t[e];
 if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
  var i = n.get,
   o = n.set;
  return (
   Object.defineProperty(t, e, {
    configurable: !0,
    get: function () {
     return i.call(this);
    },
    set: function (s) {
     (r = "" + s), o.call(this, s);
    },
   }),
   Object.defineProperty(t, e, { enumerable: n.enumerable }),
   {
    getValue: function () {
     return r;
    },
    setValue: function (s) {
     r = "" + s;
    },
    stopTracking: function () {
     (t._valueTracker = null), delete t[e];
    },
   }
  );
 }
}
function Ru(t) {
 t._valueTracker || (t._valueTracker = DN(t));
}
function xI(t) {
 if (!t) return !1;
 var e = t._valueTracker;
 if (!e) return !0;
 var n = e.getValue(),
  r = "";
 return t && (r = NI(t) ? (t.checked ? "true" : "false") : t.value), (t = r), t !== n ? (e.setValue(t), !0) : !1;
}
function bc(t) {
 if (((t = t || (typeof document < "u" ? document : void 0)), typeof t > "u")) return null;
 try {
  return t.activeElement || t.body;
 } catch {
  return t.body;
 }
}
function lp(t, e) {
 var n = e.checked;
 return Fe({}, e, {
  defaultChecked: void 0,
  defaultValue: void 0,
  value: void 0,
  checked: n ?? t._wrapperState.initialChecked,
 });
}
function k_(t, e) {
 var n = e.defaultValue == null ? "" : e.defaultValue,
  r = e.checked != null ? e.checked : e.defaultChecked;
 (n = Si(e.value != null ? e.value : n)),
  (t._wrapperState = {
   initialChecked: r,
   initialValue: n,
   controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null,
  });
}
function MI(t, e) {
 (e = e.checked), e != null && Qm(t, "checked", e, !1);
}
function up(t, e) {
 MI(t, e);
 var n = Si(e.value),
  r = e.type;
 if (n != null)
  r === "number"
   ? ((n === 0 && t.value === "") || t.value != n) && (t.value = "" + n)
   : t.value !== "" + n && (t.value = "" + n);
 else if (r === "submit" || r === "reset") {
  t.removeAttribute("value");
  return;
 }
 e.hasOwnProperty("value") ? cp(t, e.type, n) : e.hasOwnProperty("defaultValue") && cp(t, e.type, Si(e.defaultValue)),
  e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked);
}
function b_(t, e, n) {
 if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
  var r = e.type;
  if (!((r !== "submit" && r !== "reset") || (e.value !== void 0 && e.value !== null))) return;
  (e = "" + t._wrapperState.initialValue), n || e === t.value || (t.value = e), (t.defaultValue = e);
 }
 (n = t.name),
  n !== "" && (t.name = ""),
  (t.defaultChecked = !!t._wrapperState.initialChecked),
  n !== "" && (t.name = n);
}
function cp(t, e, n) {
 (e !== "number" || bc(t.ownerDocument) !== t) &&
  (n == null
   ? (t.defaultValue = "" + t._wrapperState.initialValue)
   : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
}
var Ra = Array.isArray;
function ss(t, e, n, r) {
 if (((t = t.options), e)) {
  e = {};
  for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
  for (n = 0; n < t.length; n++)
   (i = e.hasOwnProperty("$" + t[n].value)),
    t[n].selected !== i && (t[n].selected = i),
    i && r && (t[n].defaultSelected = !0);
 } else {
  for (n = "" + Si(n), e = null, i = 0; i < t.length; i++) {
   if (t[i].value === n) {
    (t[i].selected = !0), r && (t[i].defaultSelected = !0);
    return;
   }
   e !== null || t[i].disabled || (e = t[i]);
  }
  e !== null && (e.selected = !0);
 }
}
function dp(t, e) {
 if (e.dangerouslySetInnerHTML != null) throw Error(H(91));
 return Fe({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue });
}
function N_(t, e) {
 var n = e.value;
 if (n == null) {
  if (((n = e.children), (e = e.defaultValue), n != null)) {
   if (e != null) throw Error(H(92));
   if (Ra(n)) {
    if (1 < n.length) throw Error(H(93));
    n = n[0];
   }
   e = n;
  }
  e == null && (e = ""), (n = e);
 }
 t._wrapperState = { initialValue: Si(n) };
}
function DI(t, e) {
 var n = Si(e.value),
  r = Si(e.defaultValue);
 n != null &&
  ((n = "" + n),
  n !== t.value && (t.value = n),
  e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
  r != null && (t.defaultValue = "" + r);
}
function x_(t) {
 var e = t.textContent;
 e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function LI(t) {
 switch (t) {
  case "svg":
   return "http://www.w3.org/2000/svg";
  case "math":
   return "http://www.w3.org/1998/Math/MathML";
  default:
   return "http://www.w3.org/1999/xhtml";
 }
}
function fp(t, e) {
 return t == null || t === "http://www.w3.org/1999/xhtml"
  ? LI(e)
  : t === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : t;
}
var Pu,
 VI = (function (t) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
   ? function (e, n, r, i) {
      MSApp.execUnsafeLocalFunction(function () {
       return t(e, n, r, i);
      });
     }
   : t;
 })(function (t, e) {
  if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e;
  else {
   for (
    Pu = Pu || document.createElement("div"),
     Pu.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
     e = Pu.firstChild;
    t.firstChild;

   )
    t.removeChild(t.firstChild);
   for (; e.firstChild; ) t.appendChild(e.firstChild);
  }
 });
function el(t, e) {
 if (e) {
  var n = t.firstChild;
  if (n && n === t.lastChild && n.nodeType === 3) {
   n.nodeValue = e;
   return;
  }
 }
 t.textContent = e;
}
var Ua = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0,
 },
 LN = ["Webkit", "ms", "Moz", "O"];
Object.keys(Ua).forEach(function (t) {
 LN.forEach(function (e) {
  (e = e + t.charAt(0).toUpperCase() + t.substring(1)), (Ua[e] = Ua[t]);
 });
});
function UI(t, e, n) {
 return e == null || typeof e == "boolean" || e === ""
  ? ""
  : n || typeof e != "number" || e === 0 || (Ua.hasOwnProperty(t) && Ua[t])
    ? ("" + e).trim()
    : e + "px";
}
function OI(t, e) {
 t = t.style;
 for (var n in e)
  if (e.hasOwnProperty(n)) {
   var r = n.indexOf("--") === 0,
    i = UI(n, e[n], r);
   n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : (t[n] = i);
  }
}
var VN = Fe(
 { menuitem: !0 },
 {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
 }
);
function hp(t, e) {
 if (e) {
  if (VN[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(H(137, t));
  if (e.dangerouslySetInnerHTML != null) {
   if (e.children != null) throw Error(H(60));
   if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(H(61));
  }
  if (e.style != null && typeof e.style != "object") throw Error(H(62));
 }
}
function pp(t, e) {
 if (t.indexOf("-") === -1) return typeof e.is == "string";
 switch (t) {
  case "annotation-xml":
  case "color-profile":
  case "font-face":
  case "font-face-src":
  case "font-face-uri":
  case "font-face-format":
  case "font-face-name":
  case "missing-glyph":
   return !1;
  default:
   return !0;
 }
}
var mp = null;
function eg(t) {
 return (
  (t = t.target || t.srcElement || window),
  t.correspondingUseElement && (t = t.correspondingUseElement),
  t.nodeType === 3 ? t.parentNode : t
 );
}
var gp = null,
 as = null,
 ls = null;
function M_(t) {
 if ((t = Ll(t))) {
  if (typeof gp != "function") throw Error(H(280));
  var e = t.stateNode;
  e && ((e = Od(e)), gp(t.stateNode, t.type, e));
 }
}
function FI(t) {
 as ? (ls ? ls.push(t) : (ls = [t])) : (as = t);
}
function BI() {
 if (as) {
  var t = as,
   e = ls;
  if (((ls = as = null), M_(t), e)) for (t = 0; t < e.length; t++) M_(e[t]);
 }
}
function $I(t, e) {
 return t(e);
}
function HI() {}
var ah = !1;
function qI(t, e, n) {
 if (ah) return t(e, n);
 ah = !0;
 try {
  return $I(t, e, n);
 } finally {
  (ah = !1), (as !== null || ls !== null) && (HI(), BI());
 }
}
function tl(t, e) {
 var n = t.stateNode;
 if (n === null) return null;
 var r = Od(n);
 if (r === null) return null;
 n = r[e];
 e: switch (e) {
  case "onClick":
  case "onClickCapture":
  case "onDoubleClick":
  case "onDoubleClickCapture":
  case "onMouseDown":
  case "onMouseDownCapture":
  case "onMouseMove":
  case "onMouseMoveCapture":
  case "onMouseUp":
  case "onMouseUpCapture":
  case "onMouseEnter":
   (r = !r.disabled) || ((t = t.type), (r = !(t === "button" || t === "input" || t === "select" || t === "textarea"))),
    (t = !r);
   break e;
  default:
   t = !1;
 }
 if (t) return null;
 if (n && typeof n != "function") throw Error(H(231, e, typeof n));
 return n;
}
var yp = !1;
if (Cr)
 try {
  var ha = {};
  Object.defineProperty(ha, "passive", {
   get: function () {
    yp = !0;
   },
  }),
   window.addEventListener("test", ha, ha),
   window.removeEventListener("test", ha, ha);
 } catch {
  yp = !1;
 }
function UN(t, e, n, r, i, o, s, a, l) {
 var u = Array.prototype.slice.call(arguments, 3);
 try {
  e.apply(n, u);
 } catch (h) {
  this.onError(h);
 }
}
var Oa = !1,
 Nc = null,
 xc = !1,
 vp = null,
 ON = {
  onError: function (t) {
   (Oa = !0), (Nc = t);
  },
 };
function FN(t, e, n, r, i, o, s, a, l) {
 (Oa = !1), (Nc = null), UN.apply(ON, arguments);
}
function BN(t, e, n, r, i, o, s, a, l) {
 if ((FN.apply(this, arguments), Oa)) {
  if (Oa) {
   var u = Nc;
   (Oa = !1), (Nc = null);
  } else throw Error(H(198));
  xc || ((xc = !0), (vp = u));
 }
}
function Io(t) {
 var e = t,
  n = t;
 if (t.alternate) for (; e.return; ) e = e.return;
 else {
  t = e;
  do (e = t), e.flags & 4098 && (n = e.return), (t = e.return);
  while (t);
 }
 return e.tag === 3 ? n : null;
}
function GI(t) {
 if (t.tag === 13) {
  var e = t.memoizedState;
  if ((e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)), e !== null)) return e.dehydrated;
 }
 return null;
}
function D_(t) {
 if (Io(t) !== t) throw Error(H(188));
}
function $N(t) {
 var e = t.alternate;
 if (!e) {
  if (((e = Io(t)), e === null)) throw Error(H(188));
  return e !== t ? null : t;
 }
 for (var n = t, r = e; ; ) {
  var i = n.return;
  if (i === null) break;
  var o = i.alternate;
  if (o === null) {
   if (((r = i.return), r !== null)) {
    n = r;
    continue;
   }
   break;
  }
  if (i.child === o.child) {
   for (o = i.child; o; ) {
    if (o === n) return D_(i), t;
    if (o === r) return D_(i), e;
    o = o.sibling;
   }
   throw Error(H(188));
  }
  if (n.return !== r.return) (n = i), (r = o);
  else {
   for (var s = !1, a = i.child; a; ) {
    if (a === n) {
     (s = !0), (n = i), (r = o);
     break;
    }
    if (a === r) {
     (s = !0), (r = i), (n = o);
     break;
    }
    a = a.sibling;
   }
   if (!s) {
    for (a = o.child; a; ) {
     if (a === n) {
      (s = !0), (n = o), (r = i);
      break;
     }
     if (a === r) {
      (s = !0), (r = o), (n = i);
      break;
     }
     a = a.sibling;
    }
    if (!s) throw Error(H(189));
   }
  }
  if (n.alternate !== r) throw Error(H(190));
 }
 if (n.tag !== 3) throw Error(H(188));
 return n.stateNode.current === n ? t : e;
}
function zI(t) {
 return (t = $N(t)), t !== null ? WI(t) : null;
}
function WI(t) {
 if (t.tag === 5 || t.tag === 6) return t;
 for (t = t.child; t !== null; ) {
  var e = WI(t);
  if (e !== null) return e;
  t = t.sibling;
 }
 return null;
}
var KI = hn.unstable_scheduleCallback,
 L_ = hn.unstable_cancelCallback,
 HN = hn.unstable_shouldYield,
 qN = hn.unstable_requestPaint,
 Ye = hn.unstable_now,
 GN = hn.unstable_getCurrentPriorityLevel,
 tg = hn.unstable_ImmediatePriority,
 JI = hn.unstable_UserBlockingPriority,
 Mc = hn.unstable_NormalPriority,
 zN = hn.unstable_LowPriority,
 YI = hn.unstable_IdlePriority,
 Dd = null,
 tr = null;
function WN(t) {
 if (tr && typeof tr.onCommitFiberRoot == "function")
  try {
   tr.onCommitFiberRoot(Dd, t, void 0, (t.current.flags & 128) === 128);
  } catch {}
}
var Un = Math.clz32 ? Math.clz32 : YN,
 KN = Math.log,
 JN = Math.LN2;
function YN(t) {
 return (t >>>= 0), t === 0 ? 32 : (31 - ((KN(t) / JN) | 0)) | 0;
}
var ku = 64,
 bu = 4194304;
function Pa(t) {
 switch (t & -t) {
  case 1:
   return 1;
  case 2:
   return 2;
  case 4:
   return 4;
  case 8:
   return 8;
  case 16:
   return 16;
  case 32:
   return 32;
  case 64:
  case 128:
  case 256:
  case 512:
  case 1024:
  case 2048:
  case 4096:
  case 8192:
  case 16384:
  case 32768:
  case 65536:
  case 131072:
  case 262144:
  case 524288:
  case 1048576:
  case 2097152:
   return t & 4194240;
  case 4194304:
  case 8388608:
  case 16777216:
  case 33554432:
  case 67108864:
   return t & 130023424;
  case 134217728:
   return 134217728;
  case 268435456:
   return 268435456;
  case 536870912:
   return 536870912;
  case 1073741824:
   return 1073741824;
  default:
   return t;
 }
}
function Dc(t, e) {
 var n = t.pendingLanes;
 if (n === 0) return 0;
 var r = 0,
  i = t.suspendedLanes,
  o = t.pingedLanes,
  s = n & 268435455;
 if (s !== 0) {
  var a = s & ~i;
  a !== 0 ? (r = Pa(a)) : ((o &= s), o !== 0 && (r = Pa(o)));
 } else (s = n & ~i), s !== 0 ? (r = Pa(s)) : o !== 0 && (r = Pa(o));
 if (r === 0) return 0;
 if (e !== 0 && e !== r && !(e & i) && ((i = r & -r), (o = e & -e), i >= o || (i === 16 && (o & 4194240) !== 0)))
  return e;
 if ((r & 4 && (r |= n & 16), (e = t.entangledLanes), e !== 0))
  for (t = t.entanglements, e &= r; 0 < e; ) (n = 31 - Un(e)), (i = 1 << n), (r |= t[n]), (e &= ~i);
 return r;
}
function QN(t, e) {
 switch (t) {
  case 1:
  case 2:
  case 4:
   return e + 250;
  case 8:
  case 16:
  case 32:
  case 64:
  case 128:
  case 256:
  case 512:
  case 1024:
  case 2048:
  case 4096:
  case 8192:
  case 16384:
  case 32768:
  case 65536:
  case 131072:
  case 262144:
  case 524288:
  case 1048576:
  case 2097152:
   return e + 5e3;
  case 4194304:
  case 8388608:
  case 16777216:
  case 33554432:
  case 67108864:
   return -1;
  case 134217728:
  case 268435456:
  case 536870912:
  case 1073741824:
   return -1;
  default:
   return -1;
 }
}
function XN(t, e) {
 for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, o = t.pendingLanes; 0 < o; ) {
  var s = 31 - Un(o),
   a = 1 << s,
   l = i[s];
  l === -1 ? (!(a & n) || a & r) && (i[s] = QN(a, e)) : l <= e && (t.expiredLanes |= a), (o &= ~a);
 }
}
function _p(t) {
 return (t = t.pendingLanes & -1073741825), t !== 0 ? t : t & 1073741824 ? 1073741824 : 0;
}
function QI() {
 var t = ku;
 return (ku <<= 1), !(ku & 4194240) && (ku = 64), t;
}
function lh(t) {
 for (var e = [], n = 0; 31 > n; n++) e.push(t);
 return e;
}
function Ml(t, e, n) {
 (t.pendingLanes |= e),
  e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
  (t = t.eventTimes),
  (e = 31 - Un(e)),
  (t[e] = n);
}
function jN(t, e) {
 var n = t.pendingLanes & ~e;
 (t.pendingLanes = e),
  (t.suspendedLanes = 0),
  (t.pingedLanes = 0),
  (t.expiredLanes &= e),
  (t.mutableReadLanes &= e),
  (t.entangledLanes &= e),
  (e = t.entanglements);
 var r = t.eventTimes;
 for (t = t.expirationTimes; 0 < n; ) {
  var i = 31 - Un(n),
   o = 1 << i;
  (e[i] = 0), (r[i] = -1), (t[i] = -1), (n &= ~o);
 }
}
function ng(t, e) {
 var n = (t.entangledLanes |= e);
 for (t = t.entanglements; n; ) {
  var r = 31 - Un(n),
   i = 1 << r;
  (i & e) | (t[r] & e) && (t[r] |= e), (n &= ~i);
 }
}
var Ie = 0;
function XI(t) {
 return (t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1;
}
var jI,
 rg,
 ZI,
 eS,
 tS,
 wp = !1,
 Nu = [],
 fi = null,
 hi = null,
 pi = null,
 nl = new Map(),
 rl = new Map(),
 Xr = [],
 ZN =
  "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
   " "
  );
function V_(t, e) {
 switch (t) {
  case "focusin":
  case "focusout":
   fi = null;
   break;
  case "dragenter":
  case "dragleave":
   hi = null;
   break;
  case "mouseover":
  case "mouseout":
   pi = null;
   break;
  case "pointerover":
  case "pointerout":
   nl.delete(e.pointerId);
   break;
  case "gotpointercapture":
  case "lostpointercapture":
   rl.delete(e.pointerId);
 }
}
function pa(t, e, n, r, i, o) {
 return t === null || t.nativeEvent !== o
  ? ((t = { blockedOn: e, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }),
    e !== null && ((e = Ll(e)), e !== null && rg(e)),
    t)
  : ((t.eventSystemFlags |= r), (e = t.targetContainers), i !== null && e.indexOf(i) === -1 && e.push(i), t);
}
function ex(t, e, n, r, i) {
 switch (e) {
  case "focusin":
   return (fi = pa(fi, t, e, n, r, i)), !0;
  case "dragenter":
   return (hi = pa(hi, t, e, n, r, i)), !0;
  case "mouseover":
   return (pi = pa(pi, t, e, n, r, i)), !0;
  case "pointerover":
   var o = i.pointerId;
   return nl.set(o, pa(nl.get(o) || null, t, e, n, r, i)), !0;
  case "gotpointercapture":
   return (o = i.pointerId), rl.set(o, pa(rl.get(o) || null, t, e, n, r, i)), !0;
 }
 return !1;
}
function nS(t) {
 var e = Xi(t.target);
 if (e !== null) {
  var n = Io(e);
  if (n !== null) {
   if (((e = n.tag), e === 13)) {
    if (((e = GI(n)), e !== null)) {
     (t.blockedOn = e),
      tS(t.priority, function () {
       ZI(n);
      });
     return;
    }
   } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
    t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
    return;
   }
  }
 }
 t.blockedOn = null;
}
function uc(t) {
 if (t.blockedOn !== null) return !1;
 for (var e = t.targetContainers; 0 < e.length; ) {
  var n = Ep(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
  if (n === null) {
   n = t.nativeEvent;
   var r = new n.constructor(n.type, n);
   (mp = r), n.target.dispatchEvent(r), (mp = null);
  } else return (e = Ll(n)), e !== null && rg(e), (t.blockedOn = n), !1;
  e.shift();
 }
 return !0;
}
function U_(t, e, n) {
 uc(t) && n.delete(e);
}
function tx() {
 (wp = !1),
  fi !== null && uc(fi) && (fi = null),
  hi !== null && uc(hi) && (hi = null),
  pi !== null && uc(pi) && (pi = null),
  nl.forEach(U_),
  rl.forEach(U_);
}
function ma(t, e) {
 t.blockedOn === e &&
  ((t.blockedOn = null), wp || ((wp = !0), hn.unstable_scheduleCallback(hn.unstable_NormalPriority, tx)));
}
function il(t) {
 function e(i) {
  return ma(i, t);
 }
 if (0 < Nu.length) {
  ma(Nu[0], t);
  for (var n = 1; n < Nu.length; n++) {
   var r = Nu[n];
   r.blockedOn === t && (r.blockedOn = null);
  }
 }
 for (
  fi !== null && ma(fi, t), hi !== null && ma(hi, t), pi !== null && ma(pi, t), nl.forEach(e), rl.forEach(e), n = 0;
  n < Xr.length;
  n++
 )
  (r = Xr[n]), r.blockedOn === t && (r.blockedOn = null);
 for (; 0 < Xr.length && ((n = Xr[0]), n.blockedOn === null); ) nS(n), n.blockedOn === null && Xr.shift();
}
var us = Lr.ReactCurrentBatchConfig,
 Lc = !0;
function nx(t, e, n, r) {
 var i = Ie,
  o = us.transition;
 us.transition = null;
 try {
  (Ie = 1), ig(t, e, n, r);
 } finally {
  (Ie = i), (us.transition = o);
 }
}
function rx(t, e, n, r) {
 var i = Ie,
  o = us.transition;
 us.transition = null;
 try {
  (Ie = 4), ig(t, e, n, r);
 } finally {
  (Ie = i), (us.transition = o);
 }
}
function ig(t, e, n, r) {
 if (Lc) {
  var i = Ep(t, e, n, r);
  if (i === null) vh(t, e, r, Vc, n), V_(t, r);
  else if (ex(i, t, e, n, r)) r.stopPropagation();
  else if ((V_(t, r), e & 4 && -1 < ZN.indexOf(t))) {
   for (; i !== null; ) {
    var o = Ll(i);
    if ((o !== null && jI(o), (o = Ep(t, e, n, r)), o === null && vh(t, e, r, Vc, n), o === i)) break;
    i = o;
   }
   i !== null && r.stopPropagation();
  } else vh(t, e, r, null, n);
 }
}
var Vc = null;
function Ep(t, e, n, r) {
 if (((Vc = null), (t = eg(r)), (t = Xi(t)), t !== null))
  if (((e = Io(t)), e === null)) t = null;
  else if (((n = e.tag), n === 13)) {
   if (((t = GI(e)), t !== null)) return t;
   t = null;
  } else if (n === 3) {
   if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
   t = null;
  } else e !== t && (t = null);
 return (Vc = t), null;
}
function rS(t) {
 switch (t) {
  case "cancel":
  case "click":
  case "close":
  case "contextmenu":
  case "copy":
  case "cut":
  case "auxclick":
  case "dblclick":
  case "dragend":
  case "dragstart":
  case "drop":
  case "focusin":
  case "focusout":
  case "input":
  case "invalid":
  case "keydown":
  case "keypress":
  case "keyup":
  case "mousedown":
  case "mouseup":
  case "paste":
  case "pause":
  case "play":
  case "pointercancel":
  case "pointerdown":
  case "pointerup":
  case "ratechange":
  case "reset":
  case "resize":
  case "seeked":
  case "submit":
  case "touchcancel":
  case "touchend":
  case "touchstart":
  case "volumechange":
  case "change":
  case "selectionchange":
  case "textInput":
  case "compositionstart":
  case "compositionend":
  case "compositionupdate":
  case "beforeblur":
  case "afterblur":
  case "beforeinput":
  case "blur":
  case "fullscreenchange":
  case "focus":
  case "hashchange":
  case "popstate":
  case "select":
  case "selectstart":
   return 1;
  case "drag":
  case "dragenter":
  case "dragexit":
  case "dragleave":
  case "dragover":
  case "mousemove":
  case "mouseout":
  case "mouseover":
  case "pointermove":
  case "pointerout":
  case "pointerover":
  case "scroll":
  case "toggle":
  case "touchmove":
  case "wheel":
  case "mouseenter":
  case "mouseleave":
  case "pointerenter":
  case "pointerleave":
   return 4;
  case "message":
   switch (GN()) {
    case tg:
     return 1;
    case JI:
     return 4;
    case Mc:
    case zN:
     return 16;
    case YI:
     return 536870912;
    default:
     return 16;
   }
  default:
   return 16;
 }
}
var oi = null,
 og = null,
 cc = null;
function iS() {
 if (cc) return cc;
 var t,
  e = og,
  n = e.length,
  r,
  i = "value" in oi ? oi.value : oi.textContent,
  o = i.length;
 for (t = 0; t < n && e[t] === i[t]; t++);
 var s = n - t;
 for (r = 1; r <= s && e[n - r] === i[o - r]; r++);
 return (cc = i.slice(t, 1 < r ? 1 - r : void 0));
}
function dc(t) {
 var e = t.keyCode;
 return (
  "charCode" in t ? ((t = t.charCode), t === 0 && e === 13 && (t = 13)) : (t = e),
  t === 10 && (t = 13),
  32 <= t || t === 13 ? t : 0
 );
}
function xu() {
 return !0;
}
function O_() {
 return !1;
}
function gn(t) {
 function e(n, r, i, o, s) {
  (this._reactName = n),
   (this._targetInst = i),
   (this.type = r),
   (this.nativeEvent = o),
   (this.target = s),
   (this.currentTarget = null);
  for (var a in t) t.hasOwnProperty(a) && ((n = t[a]), (this[a] = n ? n(o) : o[a]));
  return (
   (this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? xu : O_),
   (this.isPropagationStopped = O_),
   this
  );
 }
 return (
  Fe(e.prototype, {
   preventDefault: function () {
    this.defaultPrevented = !0;
    var n = this.nativeEvent;
    n &&
     (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1),
     (this.isDefaultPrevented = xu));
   },
   stopPropagation: function () {
    var n = this.nativeEvent;
    n &&
     (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
     (this.isPropagationStopped = xu));
   },
   persist: function () {},
   isPersistent: xu,
  }),
  e
 );
}
var Us = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function (t) {
   return t.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0,
 },
 sg = gn(Us),
 Dl = Fe({}, Us, { view: 0, detail: 0 }),
 ix = gn(Dl),
 uh,
 ch,
 ga,
 Ld = Fe({}, Dl, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: ag,
  button: 0,
  buttons: 0,
  relatedTarget: function (t) {
   return t.relatedTarget === void 0 ? (t.fromElement === t.srcElement ? t.toElement : t.fromElement) : t.relatedTarget;
  },
  movementX: function (t) {
   return "movementX" in t
    ? t.movementX
    : (t !== ga &&
       (ga && t.type === "mousemove" ? ((uh = t.screenX - ga.screenX), (ch = t.screenY - ga.screenY)) : (ch = uh = 0),
       (ga = t)),
      uh);
  },
  movementY: function (t) {
   return "movementY" in t ? t.movementY : ch;
  },
 }),
 F_ = gn(Ld),
 ox = Fe({}, Ld, { dataTransfer: 0 }),
 sx = gn(ox),
 ax = Fe({}, Dl, { relatedTarget: 0 }),
 dh = gn(ax),
 lx = Fe({}, Us, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
 ux = gn(lx),
 cx = Fe({}, Us, {
  clipboardData: function (t) {
   return "clipboardData" in t ? t.clipboardData : window.clipboardData;
  },
 }),
 dx = gn(cx),
 fx = Fe({}, Us, { data: 0 }),
 B_ = gn(fx),
 hx = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified",
 },
 px = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta",
 },
 mx = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function gx(t) {
 var e = this.nativeEvent;
 return e.getModifierState ? e.getModifierState(t) : (t = mx[t]) ? !!e[t] : !1;
}
function ag() {
 return gx;
}
var yx = Fe({}, Dl, {
  key: function (t) {
   if (t.key) {
    var e = hx[t.key] || t.key;
    if (e !== "Unidentified") return e;
   }
   return t.type === "keypress"
    ? ((t = dc(t)), t === 13 ? "Enter" : String.fromCharCode(t))
    : t.type === "keydown" || t.type === "keyup"
      ? px[t.keyCode] || "Unidentified"
      : "";
  },
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: ag,
  charCode: function (t) {
   return t.type === "keypress" ? dc(t) : 0;
  },
  keyCode: function (t) {
   return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
  },
  which: function (t) {
   return t.type === "keypress" ? dc(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
  },
 }),
 vx = gn(yx),
 _x = Fe({}, Ld, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0,
 }),
 $_ = gn(_x),
 wx = Fe({}, Dl, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: ag,
 }),
 Ex = gn(wx),
 Tx = Fe({}, Us, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
 Ix = gn(Tx),
 Sx = Fe({}, Ld, {
  deltaX: function (t) {
   return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
  },
  deltaY: function (t) {
   return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0,
 }),
 Ax = gn(Sx),
 Cx = [9, 13, 27, 32],
 lg = Cr && "CompositionEvent" in window,
 Fa = null;
Cr && "documentMode" in document && (Fa = document.documentMode);
var Rx = Cr && "TextEvent" in window && !Fa,
 oS = Cr && (!lg || (Fa && 8 < Fa && 11 >= Fa)),
 H_ = " ",
 q_ = !1;
function sS(t, e) {
 switch (t) {
  case "keyup":
   return Cx.indexOf(e.keyCode) !== -1;
  case "keydown":
   return e.keyCode !== 229;
  case "keypress":
  case "mousedown":
  case "focusout":
   return !0;
  default:
   return !1;
 }
}
function aS(t) {
 return (t = t.detail), typeof t == "object" && "data" in t ? t.data : null;
}
var Ko = !1;
function Px(t, e) {
 switch (t) {
  case "compositionend":
   return aS(e);
  case "keypress":
   return e.which !== 32 ? null : ((q_ = !0), H_);
  case "textInput":
   return (t = e.data), t === H_ && q_ ? null : t;
  default:
   return null;
 }
}
function kx(t, e) {
 if (Ko) return t === "compositionend" || (!lg && sS(t, e)) ? ((t = iS()), (cc = og = oi = null), (Ko = !1), t) : null;
 switch (t) {
  case "paste":
   return null;
  case "keypress":
   if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
    if (e.char && 1 < e.char.length) return e.char;
    if (e.which) return String.fromCharCode(e.which);
   }
   return null;
  case "compositionend":
   return oS && e.locale !== "ko" ? null : e.data;
  default:
   return null;
 }
}
var bx = {
 color: !0,
 date: !0,
 datetime: !0,
 "datetime-local": !0,
 email: !0,
 month: !0,
 number: !0,
 password: !0,
 range: !0,
 search: !0,
 tel: !0,
 text: !0,
 time: !0,
 url: !0,
 week: !0,
};
function G_(t) {
 var e = t && t.nodeName && t.nodeName.toLowerCase();
 return e === "input" ? !!bx[t.type] : e === "textarea";
}
function lS(t, e, n, r) {
 FI(r),
  (e = Uc(e, "onChange")),
  0 < e.length && ((n = new sg("onChange", "change", null, n, r)), t.push({ event: n, listeners: e }));
}
var Ba = null,
 ol = null;
function Nx(t) {
 _S(t, 0);
}
function Vd(t) {
 var e = Qo(t);
 if (xI(e)) return t;
}
function xx(t, e) {
 if (t === "change") return e;
}
var uS = !1;
if (Cr) {
 var fh;
 if (Cr) {
  var hh = "oninput" in document;
  if (!hh) {
   var z_ = document.createElement("div");
   z_.setAttribute("oninput", "return;"), (hh = typeof z_.oninput == "function");
  }
  fh = hh;
 } else fh = !1;
 uS = fh && (!document.documentMode || 9 < document.documentMode);
}
function W_() {
 Ba && (Ba.detachEvent("onpropertychange", cS), (ol = Ba = null));
}
function cS(t) {
 if (t.propertyName === "value" && Vd(ol)) {
  var e = [];
  lS(e, ol, t, eg(t)), qI(Nx, e);
 }
}
function Mx(t, e, n) {
 t === "focusin" ? (W_(), (Ba = e), (ol = n), Ba.attachEvent("onpropertychange", cS)) : t === "focusout" && W_();
}
function Dx(t) {
 if (t === "selectionchange" || t === "keyup" || t === "keydown") return Vd(ol);
}
function Lx(t, e) {
 if (t === "click") return Vd(e);
}
function Vx(t, e) {
 if (t === "input" || t === "change") return Vd(e);
}
function Ux(t, e) {
 return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var $n = typeof Object.is == "function" ? Object.is : Ux;
function sl(t, e) {
 if ($n(t, e)) return !0;
 if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
 var n = Object.keys(t),
  r = Object.keys(e);
 if (n.length !== r.length) return !1;
 for (r = 0; r < n.length; r++) {
  var i = n[r];
  if (!rp.call(e, i) || !$n(t[i], e[i])) return !1;
 }
 return !0;
}
function K_(t) {
 for (; t && t.firstChild; ) t = t.firstChild;
 return t;
}
function J_(t, e) {
 var n = K_(t);
 t = 0;
 for (var r; n; ) {
  if (n.nodeType === 3) {
   if (((r = t + n.textContent.length), t <= e && r >= e)) return { node: n, offset: e - t };
   t = r;
  }
  e: {
   for (; n; ) {
    if (n.nextSibling) {
     n = n.nextSibling;
     break e;
    }
    n = n.parentNode;
   }
   n = void 0;
  }
  n = K_(n);
 }
}
function dS(t, e) {
 return t && e
  ? t === e
    ? !0
    : t && t.nodeType === 3
      ? !1
      : e && e.nodeType === 3
        ? dS(t, e.parentNode)
        : "contains" in t
          ? t.contains(e)
          : t.compareDocumentPosition
            ? !!(t.compareDocumentPosition(e) & 16)
            : !1
  : !1;
}
function fS() {
 for (var t = window, e = bc(); e instanceof t.HTMLIFrameElement; ) {
  try {
   var n = typeof e.contentWindow.location.href == "string";
  } catch {
   n = !1;
  }
  if (n) t = e.contentWindow;
  else break;
  e = bc(t.document);
 }
 return e;
}
function ug(t) {
 var e = t && t.nodeName && t.nodeName.toLowerCase();
 return (
  e &&
  ((e === "input" &&
   (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password")) ||
   e === "textarea" ||
   t.contentEditable === "true")
 );
}
function Ox(t) {
 var e = fS(),
  n = t.focusedElem,
  r = t.selectionRange;
 if (e !== n && n && n.ownerDocument && dS(n.ownerDocument.documentElement, n)) {
  if (r !== null && ug(n)) {
   if (((e = r.start), (t = r.end), t === void 0 && (t = e), "selectionStart" in n))
    (n.selectionStart = e), (n.selectionEnd = Math.min(t, n.value.length));
   else if (((t = ((e = n.ownerDocument || document) && e.defaultView) || window), t.getSelection)) {
    t = t.getSelection();
    var i = n.textContent.length,
     o = Math.min(r.start, i);
    (r = r.end === void 0 ? o : Math.min(r.end, i)), !t.extend && o > r && ((i = r), (r = o), (o = i)), (i = J_(n, o));
    var s = J_(n, r);
    i &&
     s &&
     (t.rangeCount !== 1 ||
      t.anchorNode !== i.node ||
      t.anchorOffset !== i.offset ||
      t.focusNode !== s.node ||
      t.focusOffset !== s.offset) &&
     ((e = e.createRange()),
     e.setStart(i.node, i.offset),
     t.removeAllRanges(),
     o > r ? (t.addRange(e), t.extend(s.node, s.offset)) : (e.setEnd(s.node, s.offset), t.addRange(e)));
   }
  }
  for (e = [], t = n; (t = t.parentNode); )
   t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
  for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
   (t = e[n]), (t.element.scrollLeft = t.left), (t.element.scrollTop = t.top);
 }
}
var Fx = Cr && "documentMode" in document && 11 >= document.documentMode,
 Jo = null,
 Tp = null,
 $a = null,
 Ip = !1;
function Y_(t, e, n) {
 var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
 Ip ||
  Jo == null ||
  Jo !== bc(r) ||
  ((r = Jo),
  "selectionStart" in r && ug(r)
   ? (r = { start: r.selectionStart, end: r.selectionEnd })
   : ((r = ((r.ownerDocument && r.ownerDocument.defaultView) || window).getSelection()),
     (r = {
      anchorNode: r.anchorNode,
      anchorOffset: r.anchorOffset,
      focusNode: r.focusNode,
      focusOffset: r.focusOffset,
     })),
  ($a && sl($a, r)) ||
   (($a = r),
   (r = Uc(Tp, "onSelect")),
   0 < r.length &&
    ((e = new sg("onSelect", "select", null, e, n)), t.push({ event: e, listeners: r }), (e.target = Jo))));
}
function Mu(t, e) {
 var n = {};
 return (n[t.toLowerCase()] = e.toLowerCase()), (n["Webkit" + t] = "webkit" + e), (n["Moz" + t] = "moz" + e), n;
}
var Yo = {
  animationend: Mu("Animation", "AnimationEnd"),
  animationiteration: Mu("Animation", "AnimationIteration"),
  animationstart: Mu("Animation", "AnimationStart"),
  transitionend: Mu("Transition", "TransitionEnd"),
 },
 ph = {},
 hS = {};
Cr &&
 ((hS = document.createElement("div").style),
 "AnimationEvent" in window ||
  (delete Yo.animationend.animation, delete Yo.animationiteration.animation, delete Yo.animationstart.animation),
 "TransitionEvent" in window || delete Yo.transitionend.transition);
function Ud(t) {
 if (ph[t]) return ph[t];
 if (!Yo[t]) return t;
 var e = Yo[t],
  n;
 for (n in e) if (e.hasOwnProperty(n) && n in hS) return (ph[t] = e[n]);
 return t;
}
var pS = Ud("animationend"),
 mS = Ud("animationiteration"),
 gS = Ud("animationstart"),
 yS = Ud("transitionend"),
 vS = new Map(),
 Q_ =
  "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
   " "
  );
function ki(t, e) {
 vS.set(t, e), To(e, [t]);
}
for (var mh = 0; mh < Q_.length; mh++) {
 var gh = Q_[mh],
  Bx = gh.toLowerCase(),
  $x = gh[0].toUpperCase() + gh.slice(1);
 ki(Bx, "on" + $x);
}
ki(pS, "onAnimationEnd");
ki(mS, "onAnimationIteration");
ki(gS, "onAnimationStart");
ki("dblclick", "onDoubleClick");
ki("focusin", "onFocus");
ki("focusout", "onBlur");
ki(yS, "onTransitionEnd");
_s("onMouseEnter", ["mouseout", "mouseover"]);
_s("onMouseLeave", ["mouseout", "mouseover"]);
_s("onPointerEnter", ["pointerout", "pointerover"]);
_s("onPointerLeave", ["pointerout", "pointerover"]);
To("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
To("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
To("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
To("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
To("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
To("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ka =
  "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
   " "
  ),
 Hx = new Set("cancel close invalid load scroll toggle".split(" ").concat(ka));
function X_(t, e, n) {
 var r = t.type || "unknown-event";
 (t.currentTarget = n), BN(r, e, void 0, t), (t.currentTarget = null);
}
function _S(t, e) {
 e = (e & 4) !== 0;
 for (var n = 0; n < t.length; n++) {
  var r = t[n],
   i = r.event;
  r = r.listeners;
  e: {
   var o = void 0;
   if (e)
    for (var s = r.length - 1; 0 <= s; s--) {
     var a = r[s],
      l = a.instance,
      u = a.currentTarget;
     if (((a = a.listener), l !== o && i.isPropagationStopped())) break e;
     X_(i, a, u), (o = l);
    }
   else
    for (s = 0; s < r.length; s++) {
     if (((a = r[s]), (l = a.instance), (u = a.currentTarget), (a = a.listener), l !== o && i.isPropagationStopped()))
      break e;
     X_(i, a, u), (o = l);
    }
  }
 }
 if (xc) throw ((t = vp), (xc = !1), (vp = null), t);
}
function be(t, e) {
 var n = e[Pp];
 n === void 0 && (n = e[Pp] = new Set());
 var r = t + "__bubble";
 n.has(r) || (wS(e, t, 2, !1), n.add(r));
}
function yh(t, e, n) {
 var r = 0;
 e && (r |= 4), wS(n, t, r, e);
}
var Du = "_reactListening" + Math.random().toString(36).slice(2);
function al(t) {
 if (!t[Du]) {
  (t[Du] = !0),
   RI.forEach(function (n) {
    n !== "selectionchange" && (Hx.has(n) || yh(n, !1, t), yh(n, !0, t));
   });
  var e = t.nodeType === 9 ? t : t.ownerDocument;
  e === null || e[Du] || ((e[Du] = !0), yh("selectionchange", !1, e));
 }
}
function wS(t, e, n, r) {
 switch (rS(e)) {
  case 1:
   var i = nx;
   break;
  case 4:
   i = rx;
   break;
  default:
   i = ig;
 }
 (n = i.bind(null, e, n, t)),
  (i = void 0),
  !yp || (e !== "touchstart" && e !== "touchmove" && e !== "wheel") || (i = !0),
  r
   ? i !== void 0
     ? t.addEventListener(e, n, { capture: !0, passive: i })
     : t.addEventListener(e, n, !0)
   : i !== void 0
     ? t.addEventListener(e, n, { passive: i })
     : t.addEventListener(e, n, !1);
}
function vh(t, e, n, r, i) {
 var o = r;
 if (!(e & 1) && !(e & 2) && r !== null)
  e: for (;;) {
   if (r === null) return;
   var s = r.tag;
   if (s === 3 || s === 4) {
    var a = r.stateNode.containerInfo;
    if (a === i || (a.nodeType === 8 && a.parentNode === i)) break;
    if (s === 4)
     for (s = r.return; s !== null; ) {
      var l = s.tag;
      if (
       (l === 3 || l === 4) &&
       ((l = s.stateNode.containerInfo), l === i || (l.nodeType === 8 && l.parentNode === i))
      )
       return;
      s = s.return;
     }
    for (; a !== null; ) {
     if (((s = Xi(a)), s === null)) return;
     if (((l = s.tag), l === 5 || l === 6)) {
      r = o = s;
      continue e;
     }
     a = a.parentNode;
    }
   }
   r = r.return;
  }
 qI(function () {
  var u = o,
   h = eg(n),
   p = [];
  e: {
   var m = vS.get(t);
   if (m !== void 0) {
    var v = sg,
     w = t;
    switch (t) {
     case "keypress":
      if (dc(n) === 0) break e;
     case "keydown":
     case "keyup":
      v = vx;
      break;
     case "focusin":
      (w = "focus"), (v = dh);
      break;
     case "focusout":
      (w = "blur"), (v = dh);
      break;
     case "beforeblur":
     case "afterblur":
      v = dh;
      break;
     case "click":
      if (n.button === 2) break e;
     case "auxclick":
     case "dblclick":
     case "mousedown":
     case "mousemove":
     case "mouseup":
     case "mouseout":
     case "mouseover":
     case "contextmenu":
      v = F_;
      break;
     case "drag":
     case "dragend":
     case "dragenter":
     case "dragexit":
     case "dragleave":
     case "dragover":
     case "dragstart":
     case "drop":
      v = sx;
      break;
     case "touchcancel":
     case "touchend":
     case "touchmove":
     case "touchstart":
      v = Ex;
      break;
     case pS:
     case mS:
     case gS:
      v = ux;
      break;
     case yS:
      v = Ix;
      break;
     case "scroll":
      v = ix;
      break;
     case "wheel":
      v = Ax;
      break;
     case "copy":
     case "cut":
     case "paste":
      v = dx;
      break;
     case "gotpointercapture":
     case "lostpointercapture":
     case "pointercancel":
     case "pointerdown":
     case "pointermove":
     case "pointerout":
     case "pointerover":
     case "pointerup":
      v = $_;
    }
    var C = (e & 4) !== 0,
     A = !C && t === "scroll",
     T = C ? (m !== null ? m + "Capture" : null) : m;
    C = [];
    for (var _ = u, E; _ !== null; ) {
     E = _;
     var N = E.stateNode;
     if ((E.tag === 5 && N !== null && ((E = N), T !== null && ((N = tl(_, T)), N != null && C.push(ll(_, N, E)))), A))
      break;
     _ = _.return;
    }
    0 < C.length && ((m = new v(m, w, null, n, h)), p.push({ event: m, listeners: C }));
   }
  }
  if (!(e & 7)) {
   e: {
    if (
     ((m = t === "mouseover" || t === "pointerover"),
     (v = t === "mouseout" || t === "pointerout"),
     m && n !== mp && (w = n.relatedTarget || n.fromElement) && (Xi(w) || w[Rr]))
    )
     break e;
    if (
     (v || m) &&
     ((m = h.window === h ? h : (m = h.ownerDocument) ? m.defaultView || m.parentWindow : window),
     v
      ? ((w = n.relatedTarget || n.toElement),
        (v = u),
        (w = w ? Xi(w) : null),
        w !== null && ((A = Io(w)), w !== A || (w.tag !== 5 && w.tag !== 6)) && (w = null))
      : ((v = null), (w = u)),
     v !== w)
    ) {
     if (
      ((C = F_),
      (N = "onMouseLeave"),
      (T = "onMouseEnter"),
      (_ = "mouse"),
      (t === "pointerout" || t === "pointerover") &&
       ((C = $_), (N = "onPointerLeave"), (T = "onPointerEnter"), (_ = "pointer")),
      (A = v == null ? m : Qo(v)),
      (E = w == null ? m : Qo(w)),
      (m = new C(N, _ + "leave", v, n, h)),
      (m.target = A),
      (m.relatedTarget = E),
      (N = null),
      Xi(h) === u && ((C = new C(T, _ + "enter", w, n, h)), (C.target = E), (C.relatedTarget = A), (N = C)),
      (A = N),
      v && w)
     )
      t: {
       for (C = v, T = w, _ = 0, E = C; E; E = Oo(E)) _++;
       for (E = 0, N = T; N; N = Oo(N)) E++;
       for (; 0 < _ - E; ) (C = Oo(C)), _--;
       for (; 0 < E - _; ) (T = Oo(T)), E--;
       for (; _--; ) {
        if (C === T || (T !== null && C === T.alternate)) break t;
        (C = Oo(C)), (T = Oo(T));
       }
       C = null;
      }
     else C = null;
     v !== null && j_(p, m, v, C, !1), w !== null && A !== null && j_(p, A, w, C, !0);
    }
   }
   e: {
    if (
     ((m = u ? Qo(u) : window),
     (v = m.nodeName && m.nodeName.toLowerCase()),
     v === "select" || (v === "input" && m.type === "file"))
    )
     var M = xx;
    else if (G_(m))
     if (uS) M = Vx;
     else {
      M = Dx;
      var F = Mx;
     }
    else (v = m.nodeName) && v.toLowerCase() === "input" && (m.type === "checkbox" || m.type === "radio") && (M = Lx);
    if (M && (M = M(t, u))) {
     lS(p, M, n, h);
     break e;
    }
    F && F(t, m, u),
     t === "focusout" && (F = m._wrapperState) && F.controlled && m.type === "number" && cp(m, "number", m.value);
   }
   switch (((F = u ? Qo(u) : window), t)) {
    case "focusin":
     (G_(F) || F.contentEditable === "true") && ((Jo = F), (Tp = u), ($a = null));
     break;
    case "focusout":
     $a = Tp = Jo = null;
     break;
    case "mousedown":
     Ip = !0;
     break;
    case "contextmenu":
    case "mouseup":
    case "dragend":
     (Ip = !1), Y_(p, n, h);
     break;
    case "selectionchange":
     if (Fx) break;
    case "keydown":
    case "keyup":
     Y_(p, n, h);
   }
   var P;
   if (lg)
    e: {
     switch (t) {
      case "compositionstart":
       var I = "onCompositionStart";
       break e;
      case "compositionend":
       I = "onCompositionEnd";
       break e;
      case "compositionupdate":
       I = "onCompositionUpdate";
       break e;
     }
     I = void 0;
    }
   else Ko ? sS(t, n) && (I = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (I = "onCompositionStart");
   I &&
    (oS &&
     n.locale !== "ko" &&
     (Ko || I !== "onCompositionStart"
      ? I === "onCompositionEnd" && Ko && (P = iS())
      : ((oi = h), (og = "value" in oi ? oi.value : oi.textContent), (Ko = !0))),
    (F = Uc(u, I)),
    0 < F.length &&
     ((I = new B_(I, t, null, n, h)),
     p.push({ event: I, listeners: F }),
     P ? (I.data = P) : ((P = aS(n)), P !== null && (I.data = P)))),
    (P = Rx ? Px(t, n) : kx(t, n)) &&
     ((u = Uc(u, "onBeforeInput")),
     0 < u.length &&
      ((h = new B_("onBeforeInput", "beforeinput", null, n, h)), p.push({ event: h, listeners: u }), (h.data = P)));
  }
  _S(p, e);
 });
}
function ll(t, e, n) {
 return { instance: t, listener: e, currentTarget: n };
}
function Uc(t, e) {
 for (var n = e + "Capture", r = []; t !== null; ) {
  var i = t,
   o = i.stateNode;
  i.tag === 5 &&
   o !== null &&
   ((i = o), (o = tl(t, n)), o != null && r.unshift(ll(t, o, i)), (o = tl(t, e)), o != null && r.push(ll(t, o, i))),
   (t = t.return);
 }
 return r;
}
function Oo(t) {
 if (t === null) return null;
 do t = t.return;
 while (t && t.tag !== 5);
 return t || null;
}
function j_(t, e, n, r, i) {
 for (var o = e._reactName, s = []; n !== null && n !== r; ) {
  var a = n,
   l = a.alternate,
   u = a.stateNode;
  if (l !== null && l === r) break;
  a.tag === 5 &&
   u !== null &&
   ((a = u),
   i ? ((l = tl(n, o)), l != null && s.unshift(ll(n, l, a))) : i || ((l = tl(n, o)), l != null && s.push(ll(n, l, a)))),
   (n = n.return);
 }
 s.length !== 0 && t.push({ event: e, listeners: s });
}
var qx = /\r\n?/g,
 Gx = /\u0000|\uFFFD/g;
function Z_(t) {
 return (typeof t == "string" ? t : "" + t)
  .replace(
   qx,
   `
`
  )
  .replace(Gx, "");
}
function Lu(t, e, n) {
 if (((e = Z_(e)), Z_(t) !== e && n)) throw Error(H(425));
}
function Oc() {}
var Sp = null,
 Ap = null;
function Cp(t, e) {
 return (
  t === "textarea" ||
  t === "noscript" ||
  typeof e.children == "string" ||
  typeof e.children == "number" ||
  (typeof e.dangerouslySetInnerHTML == "object" &&
   e.dangerouslySetInnerHTML !== null &&
   e.dangerouslySetInnerHTML.__html != null)
 );
}
var Rp = typeof setTimeout == "function" ? setTimeout : void 0,
 zx = typeof clearTimeout == "function" ? clearTimeout : void 0,
 ew = typeof Promise == "function" ? Promise : void 0,
 Wx =
  typeof queueMicrotask == "function"
   ? queueMicrotask
   : typeof ew < "u"
     ? function (t) {
        return ew.resolve(null).then(t).catch(Kx);
       }
     : Rp;
function Kx(t) {
 setTimeout(function () {
  throw t;
 });
}
function _h(t, e) {
 var n = e,
  r = 0;
 do {
  var i = n.nextSibling;
  if ((t.removeChild(n), i && i.nodeType === 8))
   if (((n = i.data), n === "/$")) {
    if (r === 0) {
     t.removeChild(i), il(e);
     return;
    }
    r--;
   } else (n !== "$" && n !== "$?" && n !== "$!") || r++;
  n = i;
 } while (n);
 il(e);
}
function mi(t) {
 for (; t != null; t = t.nextSibling) {
  var e = t.nodeType;
  if (e === 1 || e === 3) break;
  if (e === 8) {
   if (((e = t.data), e === "$" || e === "$!" || e === "$?")) break;
   if (e === "/$") return null;
  }
 }
 return t;
}
function tw(t) {
 t = t.previousSibling;
 for (var e = 0; t; ) {
  if (t.nodeType === 8) {
   var n = t.data;
   if (n === "$" || n === "$!" || n === "$?") {
    if (e === 0) return t;
    e--;
   } else n === "/$" && e++;
  }
  t = t.previousSibling;
 }
 return null;
}
var Os = Math.random().toString(36).slice(2),
 jn = "__reactFiber$" + Os,
 ul = "__reactProps$" + Os,
 Rr = "__reactContainer$" + Os,
 Pp = "__reactEvents$" + Os,
 Jx = "__reactListeners$" + Os,
 Yx = "__reactHandles$" + Os;
function Xi(t) {
 var e = t[jn];
 if (e) return e;
 for (var n = t.parentNode; n; ) {
  if ((e = n[Rr] || n[jn])) {
   if (((n = e.alternate), e.child !== null || (n !== null && n.child !== null)))
    for (t = tw(t); t !== null; ) {
     if ((n = t[jn])) return n;
     t = tw(t);
    }
   return e;
  }
  (t = n), (n = t.parentNode);
 }
 return null;
}
function Ll(t) {
 return (t = t[jn] || t[Rr]), !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t;
}
function Qo(t) {
 if (t.tag === 5 || t.tag === 6) return t.stateNode;
 throw Error(H(33));
}
function Od(t) {
 return t[ul] || null;
}
var kp = [],
 Xo = -1;
function bi(t) {
 return { current: t };
}
function xe(t) {
 0 > Xo || ((t.current = kp[Xo]), (kp[Xo] = null), Xo--);
}
function Re(t, e) {
 Xo++, (kp[Xo] = t.current), (t.current = e);
}
var Ai = {},
 Mt = bi(Ai),
 Zt = bi(!1),
 ao = Ai;
function ws(t, e) {
 var n = t.type.contextTypes;
 if (!n) return Ai;
 var r = t.stateNode;
 if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext;
 var i = {},
  o;
 for (o in n) i[o] = e[o];
 return (
  r &&
   ((t = t.stateNode),
   (t.__reactInternalMemoizedUnmaskedChildContext = e),
   (t.__reactInternalMemoizedMaskedChildContext = i)),
  i
 );
}
function en(t) {
 return (t = t.childContextTypes), t != null;
}
function Fc() {
 xe(Zt), xe(Mt);
}
function nw(t, e, n) {
 if (Mt.current !== Ai) throw Error(H(168));
 Re(Mt, e), Re(Zt, n);
}
function ES(t, e, n) {
 var r = t.stateNode;
 if (((e = e.childContextTypes), typeof r.getChildContext != "function")) return n;
 r = r.getChildContext();
 for (var i in r) if (!(i in e)) throw Error(H(108, MN(t) || "Unknown", i));
 return Fe({}, n, r);
}
function Bc(t) {
 return (
  (t = ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || Ai),
  (ao = Mt.current),
  Re(Mt, t),
  Re(Zt, Zt.current),
  !0
 );
}
function rw(t, e, n) {
 var r = t.stateNode;
 if (!r) throw Error(H(169));
 n ? ((t = ES(t, e, ao)), (r.__reactInternalMemoizedMergedChildContext = t), xe(Zt), xe(Mt), Re(Mt, t)) : xe(Zt),
  Re(Zt, n);
}
var yr = null,
 Fd = !1,
 wh = !1;
function TS(t) {
 yr === null ? (yr = [t]) : yr.push(t);
}
function Qx(t) {
 (Fd = !0), TS(t);
}
function Ni() {
 if (!wh && yr !== null) {
  wh = !0;
  var t = 0,
   e = Ie;
  try {
   var n = yr;
   for (Ie = 1; t < n.length; t++) {
    var r = n[t];
    do r = r(!0);
    while (r !== null);
   }
   (yr = null), (Fd = !1);
  } catch (i) {
   throw (yr !== null && (yr = yr.slice(t + 1)), KI(tg, Ni), i);
  } finally {
   (Ie = e), (wh = !1);
  }
 }
 return null;
}
var jo = [],
 Zo = 0,
 $c = null,
 Hc = 0,
 wn = [],
 En = 0,
 lo = null,
 vr = 1,
 _r = "";
function Wi(t, e) {
 (jo[Zo++] = Hc), (jo[Zo++] = $c), ($c = t), (Hc = e);
}
function IS(t, e, n) {
 (wn[En++] = vr), (wn[En++] = _r), (wn[En++] = lo), (lo = t);
 var r = vr;
 t = _r;
 var i = 32 - Un(r) - 1;
 (r &= ~(1 << i)), (n += 1);
 var o = 32 - Un(e) + i;
 if (30 < o) {
  var s = i - (i % 5);
  (o = (r & ((1 << s) - 1)).toString(32)),
   (r >>= s),
   (i -= s),
   (vr = (1 << (32 - Un(e) + i)) | (n << i) | r),
   (_r = o + t);
 } else (vr = (1 << o) | (n << i) | r), (_r = t);
}
function cg(t) {
 t.return !== null && (Wi(t, 1), IS(t, 1, 0));
}
function dg(t) {
 for (; t === $c; ) ($c = jo[--Zo]), (jo[Zo] = null), (Hc = jo[--Zo]), (jo[Zo] = null);
 for (; t === lo; )
  (lo = wn[--En]), (wn[En] = null), (_r = wn[--En]), (wn[En] = null), (vr = wn[--En]), (wn[En] = null);
}
var dn = null,
 ln = null,
 Me = !1,
 Vn = null;
function SS(t, e) {
 var n = Tn(5, null, null, 0);
 (n.elementType = "DELETED"),
  (n.stateNode = e),
  (n.return = t),
  (e = t.deletions),
  e === null ? ((t.deletions = [n]), (t.flags |= 16)) : e.push(n);
}
function iw(t, e) {
 switch (t.tag) {
  case 5:
   var n = t.type;
   return (
    (e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e),
    e !== null ? ((t.stateNode = e), (dn = t), (ln = mi(e.firstChild)), !0) : !1
   );
  case 6:
   return (
    (e = t.pendingProps === "" || e.nodeType !== 3 ? null : e),
    e !== null ? ((t.stateNode = e), (dn = t), (ln = null), !0) : !1
   );
  case 13:
   return (
    (e = e.nodeType !== 8 ? null : e),
    e !== null
     ? ((n = lo !== null ? { id: vr, overflow: _r } : null),
       (t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }),
       (n = Tn(18, null, null, 0)),
       (n.stateNode = e),
       (n.return = t),
       (t.child = n),
       (dn = t),
       (ln = null),
       !0)
     : !1
   );
  default:
   return !1;
 }
}
function bp(t) {
 return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function Np(t) {
 if (Me) {
  var e = ln;
  if (e) {
   var n = e;
   if (!iw(t, e)) {
    if (bp(t)) throw Error(H(418));
    e = mi(n.nextSibling);
    var r = dn;
    e && iw(t, e) ? SS(r, n) : ((t.flags = (t.flags & -4097) | 2), (Me = !1), (dn = t));
   }
  } else {
   if (bp(t)) throw Error(H(418));
   (t.flags = (t.flags & -4097) | 2), (Me = !1), (dn = t);
  }
 }
}
function ow(t) {
 for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; ) t = t.return;
 dn = t;
}
function Vu(t) {
 if (t !== dn) return !1;
 if (!Me) return ow(t), (Me = !0), !1;
 var e;
 if (
  ((e = t.tag !== 3) &&
   !(e = t.tag !== 5) &&
   ((e = t.type), (e = e !== "head" && e !== "body" && !Cp(t.type, t.memoizedProps))),
  e && (e = ln))
 ) {
  if (bp(t)) throw (AS(), Error(H(418)));
  for (; e; ) SS(t, e), (e = mi(e.nextSibling));
 }
 if ((ow(t), t.tag === 13)) {
  if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t)) throw Error(H(317));
  e: {
   for (t = t.nextSibling, e = 0; t; ) {
    if (t.nodeType === 8) {
     var n = t.data;
     if (n === "/$") {
      if (e === 0) {
       ln = mi(t.nextSibling);
       break e;
      }
      e--;
     } else (n !== "$" && n !== "$!" && n !== "$?") || e++;
    }
    t = t.nextSibling;
   }
   ln = null;
  }
 } else ln = dn ? mi(t.stateNode.nextSibling) : null;
 return !0;
}
function AS() {
 for (var t = ln; t; ) t = mi(t.nextSibling);
}
function Es() {
 (ln = dn = null), (Me = !1);
}
function fg(t) {
 Vn === null ? (Vn = [t]) : Vn.push(t);
}
var Xx = Lr.ReactCurrentBatchConfig;
function ya(t, e, n) {
 if (((t = n.ref), t !== null && typeof t != "function" && typeof t != "object")) {
  if (n._owner) {
   if (((n = n._owner), n)) {
    if (n.tag !== 1) throw Error(H(309));
    var r = n.stateNode;
   }
   if (!r) throw Error(H(147, t));
   var i = r,
    o = "" + t;
   return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === o
    ? e.ref
    : ((e = function (s) {
       var a = i.refs;
       s === null ? delete a[o] : (a[o] = s);
      }),
      (e._stringRef = o),
      e);
  }
  if (typeof t != "string") throw Error(H(284));
  if (!n._owner) throw Error(H(290, t));
 }
 return t;
}
function Uu(t, e) {
 throw (
  ((t = Object.prototype.toString.call(e)),
  Error(H(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)))
 );
}
function sw(t) {
 var e = t._init;
 return e(t._payload);
}
function CS(t) {
 function e(T, _) {
  if (t) {
   var E = T.deletions;
   E === null ? ((T.deletions = [_]), (T.flags |= 16)) : E.push(_);
  }
 }
 function n(T, _) {
  if (!t) return null;
  for (; _ !== null; ) e(T, _), (_ = _.sibling);
  return null;
 }
 function r(T, _) {
  for (T = new Map(); _ !== null; ) _.key !== null ? T.set(_.key, _) : T.set(_.index, _), (_ = _.sibling);
  return T;
 }
 function i(T, _) {
  return (T = _i(T, _)), (T.index = 0), (T.sibling = null), T;
 }
 function o(T, _, E) {
  return (
   (T.index = E),
   t
    ? ((E = T.alternate), E !== null ? ((E = E.index), E < _ ? ((T.flags |= 2), _) : E) : ((T.flags |= 2), _))
    : ((T.flags |= 1048576), _)
  );
 }
 function s(T) {
  return t && T.alternate === null && (T.flags |= 2), T;
 }
 function a(T, _, E, N) {
  return _ === null || _.tag !== 6 ? ((_ = Rh(E, T.mode, N)), (_.return = T), _) : ((_ = i(_, E)), (_.return = T), _);
 }
 function l(T, _, E, N) {
  var M = E.type;
  return M === Wo
   ? h(T, _, E.props.children, N, E.key)
   : _ !== null &&
       (_.elementType === M || (typeof M == "object" && M !== null && M.$$typeof === Yr && sw(M) === _.type))
     ? ((N = i(_, E.props)), (N.ref = ya(T, _, E)), (N.return = T), N)
     : ((N = vc(E.type, E.key, E.props, null, T.mode, N)), (N.ref = ya(T, _, E)), (N.return = T), N);
 }
 function u(T, _, E, N) {
  return _ === null ||
   _.tag !== 4 ||
   _.stateNode.containerInfo !== E.containerInfo ||
   _.stateNode.implementation !== E.implementation
   ? ((_ = Ph(E, T.mode, N)), (_.return = T), _)
   : ((_ = i(_, E.children || [])), (_.return = T), _);
 }
 function h(T, _, E, N, M) {
  return _ === null || _.tag !== 7
   ? ((_ = ro(E, T.mode, N, M)), (_.return = T), _)
   : ((_ = i(_, E)), (_.return = T), _);
 }
 function p(T, _, E) {
  if ((typeof _ == "string" && _ !== "") || typeof _ == "number") return (_ = Rh("" + _, T.mode, E)), (_.return = T), _;
  if (typeof _ == "object" && _ !== null) {
   switch (_.$$typeof) {
    case Cu:
     return (E = vc(_.type, _.key, _.props, null, T.mode, E)), (E.ref = ya(T, null, _)), (E.return = T), E;
    case zo:
     return (_ = Ph(_, T.mode, E)), (_.return = T), _;
    case Yr:
     var N = _._init;
     return p(T, N(_._payload), E);
   }
   if (Ra(_) || fa(_)) return (_ = ro(_, T.mode, E, null)), (_.return = T), _;
   Uu(T, _);
  }
  return null;
 }
 function m(T, _, E, N) {
  var M = _ !== null ? _.key : null;
  if ((typeof E == "string" && E !== "") || typeof E == "number") return M !== null ? null : a(T, _, "" + E, N);
  if (typeof E == "object" && E !== null) {
   switch (E.$$typeof) {
    case Cu:
     return E.key === M ? l(T, _, E, N) : null;
    case zo:
     return E.key === M ? u(T, _, E, N) : null;
    case Yr:
     return (M = E._init), m(T, _, M(E._payload), N);
   }
   if (Ra(E) || fa(E)) return M !== null ? null : h(T, _, E, N, null);
   Uu(T, E);
  }
  return null;
 }
 function v(T, _, E, N, M) {
  if ((typeof N == "string" && N !== "") || typeof N == "number") return (T = T.get(E) || null), a(_, T, "" + N, M);
  if (typeof N == "object" && N !== null) {
   switch (N.$$typeof) {
    case Cu:
     return (T = T.get(N.key === null ? E : N.key) || null), l(_, T, N, M);
    case zo:
     return (T = T.get(N.key === null ? E : N.key) || null), u(_, T, N, M);
    case Yr:
     var F = N._init;
     return v(T, _, E, F(N._payload), M);
   }
   if (Ra(N) || fa(N)) return (T = T.get(E) || null), h(_, T, N, M, null);
   Uu(_, N);
  }
  return null;
 }
 function w(T, _, E, N) {
  for (var M = null, F = null, P = _, I = (_ = 0), R = null; P !== null && I < E.length; I++) {
   P.index > I ? ((R = P), (P = null)) : (R = P.sibling);
   var k = m(T, P, E[I], N);
   if (k === null) {
    P === null && (P = R);
    break;
   }
   t && P && k.alternate === null && e(T, P),
    (_ = o(k, _, I)),
    F === null ? (M = k) : (F.sibling = k),
    (F = k),
    (P = R);
  }
  if (I === E.length) return n(T, P), Me && Wi(T, I), M;
  if (P === null) {
   for (; I < E.length; I++)
    (P = p(T, E[I], N)), P !== null && ((_ = o(P, _, I)), F === null ? (M = P) : (F.sibling = P), (F = P));
   return Me && Wi(T, I), M;
  }
  for (P = r(T, P); I < E.length; I++)
   (R = v(P, T, I, E[I], N)),
    R !== null &&
     (t && R.alternate !== null && P.delete(R.key === null ? I : R.key),
     (_ = o(R, _, I)),
     F === null ? (M = R) : (F.sibling = R),
     (F = R));
  return (
   t &&
    P.forEach(function (x) {
     return e(T, x);
    }),
   Me && Wi(T, I),
   M
  );
 }
 function C(T, _, E, N) {
  var M = fa(E);
  if (typeof M != "function") throw Error(H(150));
  if (((E = M.call(E)), E == null)) throw Error(H(151));
  for (var F = (M = null), P = _, I = (_ = 0), R = null, k = E.next(); P !== null && !k.done; I++, k = E.next()) {
   P.index > I ? ((R = P), (P = null)) : (R = P.sibling);
   var x = m(T, P, k.value, N);
   if (x === null) {
    P === null && (P = R);
    break;
   }
   t && P && x.alternate === null && e(T, P),
    (_ = o(x, _, I)),
    F === null ? (M = x) : (F.sibling = x),
    (F = x),
    (P = R);
  }
  if (k.done) return n(T, P), Me && Wi(T, I), M;
  if (P === null) {
   for (; !k.done; I++, k = E.next())
    (k = p(T, k.value, N)), k !== null && ((_ = o(k, _, I)), F === null ? (M = k) : (F.sibling = k), (F = k));
   return Me && Wi(T, I), M;
  }
  for (P = r(T, P); !k.done; I++, k = E.next())
   (k = v(P, T, I, k.value, N)),
    k !== null &&
     (t && k.alternate !== null && P.delete(k.key === null ? I : k.key),
     (_ = o(k, _, I)),
     F === null ? (M = k) : (F.sibling = k),
     (F = k));
  return (
   t &&
    P.forEach(function (D) {
     return e(T, D);
    }),
   Me && Wi(T, I),
   M
  );
 }
 function A(T, _, E, N) {
  if (
   (typeof E == "object" && E !== null && E.type === Wo && E.key === null && (E = E.props.children),
   typeof E == "object" && E !== null)
  ) {
   switch (E.$$typeof) {
    case Cu:
     e: {
      for (var M = E.key, F = _; F !== null; ) {
       if (F.key === M) {
        if (((M = E.type), M === Wo)) {
         if (F.tag === 7) {
          n(T, F.sibling), (_ = i(F, E.props.children)), (_.return = T), (T = _);
          break e;
         }
        } else if (
         F.elementType === M ||
         (typeof M == "object" && M !== null && M.$$typeof === Yr && sw(M) === F.type)
        ) {
         n(T, F.sibling), (_ = i(F, E.props)), (_.ref = ya(T, F, E)), (_.return = T), (T = _);
         break e;
        }
        n(T, F);
        break;
       } else e(T, F);
       F = F.sibling;
      }
      E.type === Wo
       ? ((_ = ro(E.props.children, T.mode, N, E.key)), (_.return = T), (T = _))
       : ((N = vc(E.type, E.key, E.props, null, T.mode, N)), (N.ref = ya(T, _, E)), (N.return = T), (T = N));
     }
     return s(T);
    case zo:
     e: {
      for (F = E.key; _ !== null; ) {
       if (_.key === F)
        if (
         _.tag === 4 &&
         _.stateNode.containerInfo === E.containerInfo &&
         _.stateNode.implementation === E.implementation
        ) {
         n(T, _.sibling), (_ = i(_, E.children || [])), (_.return = T), (T = _);
         break e;
        } else {
         n(T, _);
         break;
        }
       else e(T, _);
       _ = _.sibling;
      }
      (_ = Ph(E, T.mode, N)), (_.return = T), (T = _);
     }
     return s(T);
    case Yr:
     return (F = E._init), A(T, _, F(E._payload), N);
   }
   if (Ra(E)) return w(T, _, E, N);
   if (fa(E)) return C(T, _, E, N);
   Uu(T, E);
  }
  return (typeof E == "string" && E !== "") || typeof E == "number"
   ? ((E = "" + E),
     _ !== null && _.tag === 6
      ? (n(T, _.sibling), (_ = i(_, E)), (_.return = T), (T = _))
      : (n(T, _), (_ = Rh(E, T.mode, N)), (_.return = T), (T = _)),
     s(T))
   : n(T, _);
 }
 return A;
}
var Ts = CS(!0),
 RS = CS(!1),
 qc = bi(null),
 Gc = null,
 es = null,
 hg = null;
function pg() {
 hg = es = Gc = null;
}
function mg(t) {
 var e = qc.current;
 xe(qc), (t._currentValue = e);
}
function xp(t, e, n) {
 for (; t !== null; ) {
  var r = t.alternate;
  if (
   ((t.childLanes & e) !== e
    ? ((t.childLanes |= e), r !== null && (r.childLanes |= e))
    : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
   t === n)
  )
   break;
  t = t.return;
 }
}
function cs(t, e) {
 (Gc = t),
  (hg = es = null),
  (t = t.dependencies),
  t !== null && t.firstContext !== null && (t.lanes & e && (jt = !0), (t.firstContext = null));
}
function An(t) {
 var e = t._currentValue;
 if (hg !== t)
  if (((t = { context: t, memoizedValue: e, next: null }), es === null)) {
   if (Gc === null) throw Error(H(308));
   (es = t), (Gc.dependencies = { lanes: 0, firstContext: t });
  } else es = es.next = t;
 return e;
}
var ji = null;
function gg(t) {
 ji === null ? (ji = [t]) : ji.push(t);
}
function PS(t, e, n, r) {
 var i = e.interleaved;
 return i === null ? ((n.next = n), gg(e)) : ((n.next = i.next), (i.next = n)), (e.interleaved = n), Pr(t, r);
}
function Pr(t, e) {
 t.lanes |= e;
 var n = t.alternate;
 for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
  (t.childLanes |= e), (n = t.alternate), n !== null && (n.childLanes |= e), (n = t), (t = t.return);
 return n.tag === 3 ? n.stateNode : null;
}
var Qr = !1;
function yg(t) {
 t.updateQueue = {
  baseState: t.memoizedState,
  firstBaseUpdate: null,
  lastBaseUpdate: null,
  shared: { pending: null, interleaved: null, lanes: 0 },
  effects: null,
 };
}
function kS(t, e) {
 (t = t.updateQueue),
  e.updateQueue === t &&
   (e.updateQueue = {
    baseState: t.baseState,
    firstBaseUpdate: t.firstBaseUpdate,
    lastBaseUpdate: t.lastBaseUpdate,
    shared: t.shared,
    effects: t.effects,
   });
}
function Ir(t, e) {
 return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null };
}
function gi(t, e, n) {
 var r = t.updateQueue;
 if (r === null) return null;
 if (((r = r.shared), pe & 2)) {
  var i = r.pending;
  return i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)), (r.pending = e), Pr(t, n);
 }
 return (
  (i = r.interleaved),
  i === null ? ((e.next = e), gg(r)) : ((e.next = i.next), (i.next = e)),
  (r.interleaved = e),
  Pr(t, n)
 );
}
function fc(t, e, n) {
 if (((e = e.updateQueue), e !== null && ((e = e.shared), (n & 4194240) !== 0))) {
  var r = e.lanes;
  (r &= t.pendingLanes), (n |= r), (e.lanes = n), ng(t, n);
 }
}
function aw(t, e) {
 var n = t.updateQueue,
  r = t.alternate;
 if (r !== null && ((r = r.updateQueue), n === r)) {
  var i = null,
   o = null;
  if (((n = n.firstBaseUpdate), n !== null)) {
   do {
    var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null };
    o === null ? (i = o = s) : (o = o.next = s), (n = n.next);
   } while (n !== null);
   o === null ? (i = o = e) : (o = o.next = e);
  } else i = o = e;
  (n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }),
   (t.updateQueue = n);
  return;
 }
 (t = n.lastBaseUpdate), t === null ? (n.firstBaseUpdate = e) : (t.next = e), (n.lastBaseUpdate = e);
}
function zc(t, e, n, r) {
 var i = t.updateQueue;
 Qr = !1;
 var o = i.firstBaseUpdate,
  s = i.lastBaseUpdate,
  a = i.shared.pending;
 if (a !== null) {
  i.shared.pending = null;
  var l = a,
   u = l.next;
  (l.next = null), s === null ? (o = u) : (s.next = u), (s = l);
  var h = t.alternate;
  h !== null &&
   ((h = h.updateQueue),
   (a = h.lastBaseUpdate),
   a !== s && (a === null ? (h.firstBaseUpdate = u) : (a.next = u), (h.lastBaseUpdate = l)));
 }
 if (o !== null) {
  var p = i.baseState;
  (s = 0), (h = u = l = null), (a = o);
  do {
   var m = a.lane,
    v = a.eventTime;
   if ((r & m) === m) {
    h !== null &&
     (h = h.next = { eventTime: v, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null });
    e: {
     var w = t,
      C = a;
     switch (((m = e), (v = n), C.tag)) {
      case 1:
       if (((w = C.payload), typeof w == "function")) {
        p = w.call(v, p, m);
        break e;
       }
       p = w;
       break e;
      case 3:
       w.flags = (w.flags & -65537) | 128;
      case 0:
       if (((w = C.payload), (m = typeof w == "function" ? w.call(v, p, m) : w), m == null)) break e;
       p = Fe({}, p, m);
       break e;
      case 2:
       Qr = !0;
     }
    }
    a.callback !== null &&
     a.lane !== 0 &&
     ((t.flags |= 64), (m = i.effects), m === null ? (i.effects = [a]) : m.push(a));
   } else
    (v = { eventTime: v, lane: m, tag: a.tag, payload: a.payload, callback: a.callback, next: null }),
     h === null ? ((u = h = v), (l = p)) : (h = h.next = v),
     (s |= m);
   if (((a = a.next), a === null)) {
    if (((a = i.shared.pending), a === null)) break;
    (m = a), (a = m.next), (m.next = null), (i.lastBaseUpdate = m), (i.shared.pending = null);
   }
  } while (!0);
  if (
   (h === null && (l = p),
   (i.baseState = l),
   (i.firstBaseUpdate = u),
   (i.lastBaseUpdate = h),
   (e = i.shared.interleaved),
   e !== null)
  ) {
   i = e;
   do (s |= i.lane), (i = i.next);
   while (i !== e);
  } else o === null && (i.shared.lanes = 0);
  (co |= s), (t.lanes = s), (t.memoizedState = p);
 }
}
function lw(t, e, n) {
 if (((t = e.effects), (e.effects = null), t !== null))
  for (e = 0; e < t.length; e++) {
   var r = t[e],
    i = r.callback;
   if (i !== null) {
    if (((r.callback = null), (r = n), typeof i != "function")) throw Error(H(191, i));
    i.call(r);
   }
  }
}
var Vl = {},
 nr = bi(Vl),
 cl = bi(Vl),
 dl = bi(Vl);
function Zi(t) {
 if (t === Vl) throw Error(H(174));
 return t;
}
function vg(t, e) {
 switch ((Re(dl, e), Re(cl, t), Re(nr, Vl), (t = e.nodeType), t)) {
  case 9:
  case 11:
   e = (e = e.documentElement) ? e.namespaceURI : fp(null, "");
   break;
  default:
   (t = t === 8 ? e.parentNode : e), (e = t.namespaceURI || null), (t = t.tagName), (e = fp(e, t));
 }
 xe(nr), Re(nr, e);
}
function Is() {
 xe(nr), xe(cl), xe(dl);
}
function bS(t) {
 Zi(dl.current);
 var e = Zi(nr.current),
  n = fp(e, t.type);
 e !== n && (Re(cl, t), Re(nr, n));
}
function _g(t) {
 cl.current === t && (xe(nr), xe(cl));
}
var Ue = bi(0);
function Wc(t) {
 for (var e = t; e !== null; ) {
  if (e.tag === 13) {
   var n = e.memoizedState;
   if (n !== null && ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")) return e;
  } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
   if (e.flags & 128) return e;
  } else if (e.child !== null) {
   (e.child.return = e), (e = e.child);
   continue;
  }
  if (e === t) break;
  for (; e.sibling === null; ) {
   if (e.return === null || e.return === t) return null;
   e = e.return;
  }
  (e.sibling.return = e.return), (e = e.sibling);
 }
 return null;
}
var Eh = [];
function wg() {
 for (var t = 0; t < Eh.length; t++) Eh[t]._workInProgressVersionPrimary = null;
 Eh.length = 0;
}
var hc = Lr.ReactCurrentDispatcher,
 Th = Lr.ReactCurrentBatchConfig,
 uo = 0,
 Oe = null,
 it = null,
 lt = null,
 Kc = !1,
 Ha = !1,
 fl = 0,
 jx = 0;
function It() {
 throw Error(H(321));
}
function Eg(t, e) {
 if (e === null) return !1;
 for (var n = 0; n < e.length && n < t.length; n++) if (!$n(t[n], e[n])) return !1;
 return !0;
}
function Tg(t, e, n, r, i, o) {
 if (
  ((uo = o),
  (Oe = e),
  (e.memoizedState = null),
  (e.updateQueue = null),
  (e.lanes = 0),
  (hc.current = t === null || t.memoizedState === null ? n2 : r2),
  (t = n(r, i)),
  Ha)
 ) {
  o = 0;
  do {
   if (((Ha = !1), (fl = 0), 25 <= o)) throw Error(H(301));
   (o += 1), (lt = it = null), (e.updateQueue = null), (hc.current = i2), (t = n(r, i));
  } while (Ha);
 }
 if (((hc.current = Jc), (e = it !== null && it.next !== null), (uo = 0), (lt = it = Oe = null), (Kc = !1), e))
  throw Error(H(300));
 return t;
}
function Ig() {
 var t = fl !== 0;
 return (fl = 0), t;
}
function Qn() {
 var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
 return lt === null ? (Oe.memoizedState = lt = t) : (lt = lt.next = t), lt;
}
function Cn() {
 if (it === null) {
  var t = Oe.alternate;
  t = t !== null ? t.memoizedState : null;
 } else t = it.next;
 var e = lt === null ? Oe.memoizedState : lt.next;
 if (e !== null) (lt = e), (it = t);
 else {
  if (t === null) throw Error(H(310));
  (it = t),
   (t = {
    memoizedState: it.memoizedState,
    baseState: it.baseState,
    baseQueue: it.baseQueue,
    queue: it.queue,
    next: null,
   }),
   lt === null ? (Oe.memoizedState = lt = t) : (lt = lt.next = t);
 }
 return lt;
}
function hl(t, e) {
 return typeof e == "function" ? e(t) : e;
}
function Ih(t) {
 var e = Cn(),
  n = e.queue;
 if (n === null) throw Error(H(311));
 n.lastRenderedReducer = t;
 var r = it,
  i = r.baseQueue,
  o = n.pending;
 if (o !== null) {
  if (i !== null) {
   var s = i.next;
   (i.next = o.next), (o.next = s);
  }
  (r.baseQueue = i = o), (n.pending = null);
 }
 if (i !== null) {
  (o = i.next), (r = r.baseState);
  var a = (s = null),
   l = null,
   u = o;
  do {
   var h = u.lane;
   if ((uo & h) === h)
    l !== null &&
     (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }),
     (r = u.hasEagerState ? u.eagerState : t(r, u.action));
   else {
    var p = { lane: h, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null };
    l === null ? ((a = l = p), (s = r)) : (l = l.next = p), (Oe.lanes |= h), (co |= h);
   }
   u = u.next;
  } while (u !== null && u !== o);
  l === null ? (s = r) : (l.next = a),
   $n(r, e.memoizedState) || (jt = !0),
   (e.memoizedState = r),
   (e.baseState = s),
   (e.baseQueue = l),
   (n.lastRenderedState = r);
 }
 if (((t = n.interleaved), t !== null)) {
  i = t;
  do (o = i.lane), (Oe.lanes |= o), (co |= o), (i = i.next);
  while (i !== t);
 } else i === null && (n.lanes = 0);
 return [e.memoizedState, n.dispatch];
}
function Sh(t) {
 var e = Cn(),
  n = e.queue;
 if (n === null) throw Error(H(311));
 n.lastRenderedReducer = t;
 var r = n.dispatch,
  i = n.pending,
  o = e.memoizedState;
 if (i !== null) {
  n.pending = null;
  var s = (i = i.next);
  do (o = t(o, s.action)), (s = s.next);
  while (s !== i);
  $n(o, e.memoizedState) || (jt = !0),
   (e.memoizedState = o),
   e.baseQueue === null && (e.baseState = o),
   (n.lastRenderedState = o);
 }
 return [o, r];
}
function NS() {}
function xS(t, e) {
 var n = Oe,
  r = Cn(),
  i = e(),
  o = !$n(r.memoizedState, i);
 if (
  (o && ((r.memoizedState = i), (jt = !0)),
  (r = r.queue),
  Sg(LS.bind(null, n, r, t), [t]),
  r.getSnapshot !== e || o || (lt !== null && lt.memoizedState.tag & 1))
 ) {
  if (((n.flags |= 2048), pl(9, DS.bind(null, n, r, i, e), void 0, null), ut === null)) throw Error(H(349));
  uo & 30 || MS(n, e, i);
 }
 return i;
}
function MS(t, e, n) {
 (t.flags |= 16384),
  (t = { getSnapshot: e, value: n }),
  (e = Oe.updateQueue),
  e === null
   ? ((e = { lastEffect: null, stores: null }), (Oe.updateQueue = e), (e.stores = [t]))
   : ((n = e.stores), n === null ? (e.stores = [t]) : n.push(t));
}
function DS(t, e, n, r) {
 (e.value = n), (e.getSnapshot = r), VS(e) && US(t);
}
function LS(t, e, n) {
 return n(function () {
  VS(e) && US(t);
 });
}
function VS(t) {
 var e = t.getSnapshot;
 t = t.value;
 try {
  var n = e();
  return !$n(t, n);
 } catch {
  return !0;
 }
}
function US(t) {
 var e = Pr(t, 1);
 e !== null && On(e, t, 1, -1);
}
function uw(t) {
 var e = Qn();
 return (
  typeof t == "function" && (t = t()),
  (e.memoizedState = e.baseState = t),
  (t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: hl, lastRenderedState: t }),
  (e.queue = t),
  (t = t.dispatch = t2.bind(null, Oe, t)),
  [e.memoizedState, t]
 );
}
function pl(t, e, n, r) {
 return (
  (t = { tag: t, create: e, destroy: n, deps: r, next: null }),
  (e = Oe.updateQueue),
  e === null
   ? ((e = { lastEffect: null, stores: null }), (Oe.updateQueue = e), (e.lastEffect = t.next = t))
   : ((n = e.lastEffect),
     n === null ? (e.lastEffect = t.next = t) : ((r = n.next), (n.next = t), (t.next = r), (e.lastEffect = t))),
  t
 );
}
function OS() {
 return Cn().memoizedState;
}
function pc(t, e, n, r) {
 var i = Qn();
 (Oe.flags |= t), (i.memoizedState = pl(1 | e, n, void 0, r === void 0 ? null : r));
}
function Bd(t, e, n, r) {
 var i = Cn();
 r = r === void 0 ? null : r;
 var o = void 0;
 if (it !== null) {
  var s = it.memoizedState;
  if (((o = s.destroy), r !== null && Eg(r, s.deps))) {
   i.memoizedState = pl(e, n, o, r);
   return;
  }
 }
 (Oe.flags |= t), (i.memoizedState = pl(1 | e, n, o, r));
}
function cw(t, e) {
 return pc(8390656, 8, t, e);
}
function Sg(t, e) {
 return Bd(2048, 8, t, e);
}
function FS(t, e) {
 return Bd(4, 2, t, e);
}
function BS(t, e) {
 return Bd(4, 4, t, e);
}
function $S(t, e) {
 if (typeof e == "function")
  return (
   (t = t()),
   e(t),
   function () {
    e(null);
   }
  );
 if (e != null)
  return (
   (t = t()),
   (e.current = t),
   function () {
    e.current = null;
   }
  );
}
function HS(t, e, n) {
 return (n = n != null ? n.concat([t]) : null), Bd(4, 4, $S.bind(null, e, t), n);
}
function Ag() {}
function qS(t, e) {
 var n = Cn();
 e = e === void 0 ? null : e;
 var r = n.memoizedState;
 return r !== null && e !== null && Eg(e, r[1]) ? r[0] : ((n.memoizedState = [t, e]), t);
}
function GS(t, e) {
 var n = Cn();
 e = e === void 0 ? null : e;
 var r = n.memoizedState;
 return r !== null && e !== null && Eg(e, r[1]) ? r[0] : ((t = t()), (n.memoizedState = [t, e]), t);
}
function zS(t, e, n) {
 return uo & 21
  ? ($n(n, e) || ((n = QI()), (Oe.lanes |= n), (co |= n), (t.baseState = !0)), e)
  : (t.baseState && ((t.baseState = !1), (jt = !0)), (t.memoizedState = n));
}
function Zx(t, e) {
 var n = Ie;
 (Ie = n !== 0 && 4 > n ? n : 4), t(!0);
 var r = Th.transition;
 Th.transition = {};
 try {
  t(!1), e();
 } finally {
  (Ie = n), (Th.transition = r);
 }
}
function WS() {
 return Cn().memoizedState;
}
function e2(t, e, n) {
 var r = vi(t);
 if (((n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }), KS(t))) JS(e, n);
 else if (((n = PS(t, e, n, r)), n !== null)) {
  var i = $t();
  On(n, t, r, i), YS(n, e, r);
 }
}
function t2(t, e, n) {
 var r = vi(t),
  i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null };
 if (KS(t)) JS(e, i);
 else {
  var o = t.alternate;
  if (t.lanes === 0 && (o === null || o.lanes === 0) && ((o = e.lastRenderedReducer), o !== null))
   try {
    var s = e.lastRenderedState,
     a = o(s, n);
    if (((i.hasEagerState = !0), (i.eagerState = a), $n(a, s))) {
     var l = e.interleaved;
     l === null ? ((i.next = i), gg(e)) : ((i.next = l.next), (l.next = i)), (e.interleaved = i);
     return;
    }
   } catch {
   } finally {
   }
  (n = PS(t, e, i, r)), n !== null && ((i = $t()), On(n, t, r, i), YS(n, e, r));
 }
}
function KS(t) {
 var e = t.alternate;
 return t === Oe || (e !== null && e === Oe);
}
function JS(t, e) {
 Ha = Kc = !0;
 var n = t.pending;
 n === null ? (e.next = e) : ((e.next = n.next), (n.next = e)), (t.pending = e);
}
function YS(t, e, n) {
 if (n & 4194240) {
  var r = e.lanes;
  (r &= t.pendingLanes), (n |= r), (e.lanes = n), ng(t, n);
 }
}
var Jc = {
  readContext: An,
  useCallback: It,
  useContext: It,
  useEffect: It,
  useImperativeHandle: It,
  useInsertionEffect: It,
  useLayoutEffect: It,
  useMemo: It,
  useReducer: It,
  useRef: It,
  useState: It,
  useDebugValue: It,
  useDeferredValue: It,
  useTransition: It,
  useMutableSource: It,
  useSyncExternalStore: It,
  useId: It,
  unstable_isNewReconciler: !1,
 },
 n2 = {
  readContext: An,
  useCallback: function (t, e) {
   return (Qn().memoizedState = [t, e === void 0 ? null : e]), t;
  },
  useContext: An,
  useEffect: cw,
  useImperativeHandle: function (t, e, n) {
   return (n = n != null ? n.concat([t]) : null), pc(4194308, 4, $S.bind(null, e, t), n);
  },
  useLayoutEffect: function (t, e) {
   return pc(4194308, 4, t, e);
  },
  useInsertionEffect: function (t, e) {
   return pc(4, 2, t, e);
  },
  useMemo: function (t, e) {
   var n = Qn();
   return (e = e === void 0 ? null : e), (t = t()), (n.memoizedState = [t, e]), t;
  },
  useReducer: function (t, e, n) {
   var r = Qn();
   return (
    (e = n !== void 0 ? n(e) : e),
    (r.memoizedState = r.baseState = e),
    (t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }),
    (r.queue = t),
    (t = t.dispatch = e2.bind(null, Oe, t)),
    [r.memoizedState, t]
   );
  },
  useRef: function (t) {
   var e = Qn();
   return (t = { current: t }), (e.memoizedState = t);
  },
  useState: uw,
  useDebugValue: Ag,
  useDeferredValue: function (t) {
   return (Qn().memoizedState = t);
  },
  useTransition: function () {
   var t = uw(!1),
    e = t[0];
   return (t = Zx.bind(null, t[1])), (Qn().memoizedState = t), [e, t];
  },
  useMutableSource: function () {},
  useSyncExternalStore: function (t, e, n) {
   var r = Oe,
    i = Qn();
   if (Me) {
    if (n === void 0) throw Error(H(407));
    n = n();
   } else {
    if (((n = e()), ut === null)) throw Error(H(349));
    uo & 30 || MS(r, e, n);
   }
   i.memoizedState = n;
   var o = { value: n, getSnapshot: e };
   return (
    (i.queue = o), cw(LS.bind(null, r, o, t), [t]), (r.flags |= 2048), pl(9, DS.bind(null, r, o, n, e), void 0, null), n
   );
  },
  useId: function () {
   var t = Qn(),
    e = ut.identifierPrefix;
   if (Me) {
    var n = _r,
     r = vr;
    (n = (r & ~(1 << (32 - Un(r) - 1))).toString(32) + n),
     (e = ":" + e + "R" + n),
     (n = fl++),
     0 < n && (e += "H" + n.toString(32)),
     (e += ":");
   } else (n = jx++), (e = ":" + e + "r" + n.toString(32) + ":");
   return (t.memoizedState = e);
  },
  unstable_isNewReconciler: !1,
 },
 r2 = {
  readContext: An,
  useCallback: qS,
  useContext: An,
  useEffect: Sg,
  useImperativeHandle: HS,
  useInsertionEffect: FS,
  useLayoutEffect: BS,
  useMemo: GS,
  useReducer: Ih,
  useRef: OS,
  useState: function () {
   return Ih(hl);
  },
  useDebugValue: Ag,
  useDeferredValue: function (t) {
   var e = Cn();
   return zS(e, it.memoizedState, t);
  },
  useTransition: function () {
   var t = Ih(hl)[0],
    e = Cn().memoizedState;
   return [t, e];
  },
  useMutableSource: NS,
  useSyncExternalStore: xS,
  useId: WS,
  unstable_isNewReconciler: !1,
 },
 i2 = {
  readContext: An,
  useCallback: qS,
  useContext: An,
  useEffect: Sg,
  useImperativeHandle: HS,
  useInsertionEffect: FS,
  useLayoutEffect: BS,
  useMemo: GS,
  useReducer: Sh,
  useRef: OS,
  useState: function () {
   return Sh(hl);
  },
  useDebugValue: Ag,
  useDeferredValue: function (t) {
   var e = Cn();
   return it === null ? (e.memoizedState = t) : zS(e, it.memoizedState, t);
  },
  useTransition: function () {
   var t = Sh(hl)[0],
    e = Cn().memoizedState;
   return [t, e];
  },
  useMutableSource: NS,
  useSyncExternalStore: xS,
  useId: WS,
  unstable_isNewReconciler: !1,
 };
function Dn(t, e) {
 if (t && t.defaultProps) {
  (e = Fe({}, e)), (t = t.defaultProps);
  for (var n in t) e[n] === void 0 && (e[n] = t[n]);
  return e;
 }
 return e;
}
function Mp(t, e, n, r) {
 (e = t.memoizedState),
  (n = n(r, e)),
  (n = n == null ? e : Fe({}, e, n)),
  (t.memoizedState = n),
  t.lanes === 0 && (t.updateQueue.baseState = n);
}
var $d = {
 isMounted: function (t) {
  return (t = t._reactInternals) ? Io(t) === t : !1;
 },
 enqueueSetState: function (t, e, n) {
  t = t._reactInternals;
  var r = $t(),
   i = vi(t),
   o = Ir(r, i);
  (o.payload = e), n != null && (o.callback = n), (e = gi(t, o, i)), e !== null && (On(e, t, i, r), fc(e, t, i));
 },
 enqueueReplaceState: function (t, e, n) {
  t = t._reactInternals;
  var r = $t(),
   i = vi(t),
   o = Ir(r, i);
  (o.tag = 1),
   (o.payload = e),
   n != null && (o.callback = n),
   (e = gi(t, o, i)),
   e !== null && (On(e, t, i, r), fc(e, t, i));
 },
 enqueueForceUpdate: function (t, e) {
  t = t._reactInternals;
  var n = $t(),
   r = vi(t),
   i = Ir(n, r);
  (i.tag = 2), e != null && (i.callback = e), (e = gi(t, i, r)), e !== null && (On(e, t, r, n), fc(e, t, r));
 },
};
function dw(t, e, n, r, i, o, s) {
 return (
  (t = t.stateNode),
  typeof t.shouldComponentUpdate == "function"
   ? t.shouldComponentUpdate(r, o, s)
   : e.prototype && e.prototype.isPureReactComponent
     ? !sl(n, r) || !sl(i, o)
     : !0
 );
}
function QS(t, e, n) {
 var r = !1,
  i = Ai,
  o = e.contextType;
 return (
  typeof o == "object" && o !== null
   ? (o = An(o))
   : ((i = en(e) ? ao : Mt.current), (r = e.contextTypes), (o = (r = r != null) ? ws(t, i) : Ai)),
  (e = new e(n, o)),
  (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
  (e.updater = $d),
  (t.stateNode = e),
  (e._reactInternals = t),
  r &&
   ((t = t.stateNode),
   (t.__reactInternalMemoizedUnmaskedChildContext = i),
   (t.__reactInternalMemoizedMaskedChildContext = o)),
  e
 );
}
function fw(t, e, n, r) {
 (t = e.state),
  typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r),
  typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r),
  e.state !== t && $d.enqueueReplaceState(e, e.state, null);
}
function Dp(t, e, n, r) {
 var i = t.stateNode;
 (i.props = n), (i.state = t.memoizedState), (i.refs = {}), yg(t);
 var o = e.contextType;
 typeof o == "object" && o !== null ? (i.context = An(o)) : ((o = en(e) ? ao : Mt.current), (i.context = ws(t, o))),
  (i.state = t.memoizedState),
  (o = e.getDerivedStateFromProps),
  typeof o == "function" && (Mp(t, e, o, n), (i.state = t.memoizedState)),
  typeof e.getDerivedStateFromProps == "function" ||
   typeof i.getSnapshotBeforeUpdate == "function" ||
   (typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function") ||
   ((e = i.state),
   typeof i.componentWillMount == "function" && i.componentWillMount(),
   typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(),
   e !== i.state && $d.enqueueReplaceState(i, i.state, null),
   zc(t, n, i, r),
   (i.state = t.memoizedState)),
  typeof i.componentDidMount == "function" && (t.flags |= 4194308);
}
function Ss(t, e) {
 try {
  var n = "",
   r = e;
  do (n += xN(r)), (r = r.return);
  while (r);
  var i = n;
 } catch (o) {
  i =
   `
Error generating stack: ` +
   o.message +
   `
` +
   o.stack;
 }
 return { value: t, source: e, stack: i, digest: null };
}
function Ah(t, e, n) {
 return { value: t, source: null, stack: n ?? null, digest: e ?? null };
}
function Lp(t, e) {
 try {
  console.error(e.value);
 } catch (n) {
  setTimeout(function () {
   throw n;
  });
 }
}
var o2 = typeof WeakMap == "function" ? WeakMap : Map;
function XS(t, e, n) {
 (n = Ir(-1, n)), (n.tag = 3), (n.payload = { element: null });
 var r = e.value;
 return (
  (n.callback = function () {
   Qc || ((Qc = !0), (zp = r)), Lp(t, e);
  }),
  n
 );
}
function jS(t, e, n) {
 (n = Ir(-1, n)), (n.tag = 3);
 var r = t.type.getDerivedStateFromError;
 if (typeof r == "function") {
  var i = e.value;
  (n.payload = function () {
   return r(i);
  }),
   (n.callback = function () {
    Lp(t, e);
   });
 }
 var o = t.stateNode;
 return (
  o !== null &&
   typeof o.componentDidCatch == "function" &&
   (n.callback = function () {
    Lp(t, e), typeof r != "function" && (yi === null ? (yi = new Set([this])) : yi.add(this));
    var s = e.stack;
    this.componentDidCatch(e.value, { componentStack: s !== null ? s : "" });
   }),
  n
 );
}
function hw(t, e, n) {
 var r = t.pingCache;
 if (r === null) {
  r = t.pingCache = new o2();
  var i = new Set();
  r.set(e, i);
 } else (i = r.get(e)), i === void 0 && ((i = new Set()), r.set(e, i));
 i.has(n) || (i.add(n), (t = _2.bind(null, t, e, n)), e.then(t, t));
}
function pw(t) {
 do {
  var e;
  if (((e = t.tag === 13) && ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)), e)) return t;
  t = t.return;
 } while (t !== null);
 return null;
}
function mw(t, e, n, r, i) {
 return t.mode & 1
  ? ((t.flags |= 65536), (t.lanes = i), t)
  : (t === e
     ? (t.flags |= 65536)
     : ((t.flags |= 128),
       (n.flags |= 131072),
       (n.flags &= -52805),
       n.tag === 1 && (n.alternate === null ? (n.tag = 17) : ((e = Ir(-1, 1)), (e.tag = 2), gi(n, e, 1))),
       (n.lanes |= 1)),
    t);
}
var s2 = Lr.ReactCurrentOwner,
 jt = !1;
function Bt(t, e, n, r) {
 e.child = t === null ? RS(e, null, n, r) : Ts(e, t.child, n, r);
}
function gw(t, e, n, r, i) {
 n = n.render;
 var o = e.ref;
 return (
  cs(e, i),
  (r = Tg(t, e, n, r, o, i)),
  (n = Ig()),
  t !== null && !jt
   ? ((e.updateQueue = t.updateQueue), (e.flags &= -2053), (t.lanes &= ~i), kr(t, e, i))
   : (Me && n && cg(e), (e.flags |= 1), Bt(t, e, r, i), e.child)
 );
}
function yw(t, e, n, r, i) {
 if (t === null) {
  var o = n.type;
  return typeof o == "function" &&
   !Mg(o) &&
   o.defaultProps === void 0 &&
   n.compare === null &&
   n.defaultProps === void 0
   ? ((e.tag = 15), (e.type = o), ZS(t, e, o, r, i))
   : ((t = vc(n.type, null, r, e, e.mode, i)), (t.ref = e.ref), (t.return = e), (e.child = t));
 }
 if (((o = t.child), !(t.lanes & i))) {
  var s = o.memoizedProps;
  if (((n = n.compare), (n = n !== null ? n : sl), n(s, r) && t.ref === e.ref)) return kr(t, e, i);
 }
 return (e.flags |= 1), (t = _i(o, r)), (t.ref = e.ref), (t.return = e), (e.child = t);
}
function ZS(t, e, n, r, i) {
 if (t !== null) {
  var o = t.memoizedProps;
  if (sl(o, r) && t.ref === e.ref)
   if (((jt = !1), (e.pendingProps = r = o), (t.lanes & i) !== 0)) t.flags & 131072 && (jt = !0);
   else return (e.lanes = t.lanes), kr(t, e, i);
 }
 return Vp(t, e, n, r, i);
}
function eA(t, e, n) {
 var r = e.pendingProps,
  i = r.children,
  o = t !== null ? t.memoizedState : null;
 if (r.mode === "hidden")
  if (!(e.mode & 1)) (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }), Re(ns, an), (an |= n);
  else {
   if (!(n & 1073741824))
    return (
     (t = o !== null ? o.baseLanes | n : n),
     (e.lanes = e.childLanes = 1073741824),
     (e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }),
     (e.updateQueue = null),
     Re(ns, an),
     (an |= t),
     null
    );
   (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
    (r = o !== null ? o.baseLanes : n),
    Re(ns, an),
    (an |= r);
  }
 else o !== null ? ((r = o.baseLanes | n), (e.memoizedState = null)) : (r = n), Re(ns, an), (an |= r);
 return Bt(t, e, i, n), e.child;
}
function tA(t, e) {
 var n = e.ref;
 ((t === null && n !== null) || (t !== null && t.ref !== n)) && ((e.flags |= 512), (e.flags |= 2097152));
}
function Vp(t, e, n, r, i) {
 var o = en(n) ? ao : Mt.current;
 return (
  (o = ws(e, o)),
  cs(e, i),
  (n = Tg(t, e, n, r, o, i)),
  (r = Ig()),
  t !== null && !jt
   ? ((e.updateQueue = t.updateQueue), (e.flags &= -2053), (t.lanes &= ~i), kr(t, e, i))
   : (Me && r && cg(e), (e.flags |= 1), Bt(t, e, n, i), e.child)
 );
}
function vw(t, e, n, r, i) {
 if (en(n)) {
  var o = !0;
  Bc(e);
 } else o = !1;
 if ((cs(e, i), e.stateNode === null)) mc(t, e), QS(e, n, r), Dp(e, n, r, i), (r = !0);
 else if (t === null) {
  var s = e.stateNode,
   a = e.memoizedProps;
  s.props = a;
  var l = s.context,
   u = n.contextType;
  typeof u == "object" && u !== null ? (u = An(u)) : ((u = en(n) ? ao : Mt.current), (u = ws(e, u)));
  var h = n.getDerivedStateFromProps,
   p = typeof h == "function" || typeof s.getSnapshotBeforeUpdate == "function";
  p ||
   (typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function") ||
   ((a !== r || l !== u) && fw(e, s, r, u)),
   (Qr = !1);
  var m = e.memoizedState;
  (s.state = m),
   zc(e, r, s, i),
   (l = e.memoizedState),
   a !== r || m !== l || Zt.current || Qr
    ? (typeof h == "function" && (Mp(e, n, h, r), (l = e.memoizedState)),
      (a = Qr || dw(e, n, a, r, m, l, u))
       ? (p ||
          (typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function") ||
          (typeof s.componentWillMount == "function" && s.componentWillMount(),
          typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()),
         typeof s.componentDidMount == "function" && (e.flags |= 4194308))
       : (typeof s.componentDidMount == "function" && (e.flags |= 4194308),
         (e.memoizedProps = r),
         (e.memoizedState = l)),
      (s.props = r),
      (s.state = l),
      (s.context = u),
      (r = a))
    : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), (r = !1));
 } else {
  (s = e.stateNode),
   kS(t, e),
   (a = e.memoizedProps),
   (u = e.type === e.elementType ? a : Dn(e.type, a)),
   (s.props = u),
   (p = e.pendingProps),
   (m = s.context),
   (l = n.contextType),
   typeof l == "object" && l !== null ? (l = An(l)) : ((l = en(n) ? ao : Mt.current), (l = ws(e, l)));
  var v = n.getDerivedStateFromProps;
  (h = typeof v == "function" || typeof s.getSnapshotBeforeUpdate == "function") ||
   (typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function") ||
   ((a !== p || m !== l) && fw(e, s, r, l)),
   (Qr = !1),
   (m = e.memoizedState),
   (s.state = m),
   zc(e, r, s, i);
  var w = e.memoizedState;
  a !== p || m !== w || Zt.current || Qr
   ? (typeof v == "function" && (Mp(e, n, v, r), (w = e.memoizedState)),
     (u = Qr || dw(e, n, u, r, m, w, l) || !1)
      ? (h ||
         (typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function") ||
         (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, w, l),
         typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, w, l)),
        typeof s.componentDidUpdate == "function" && (e.flags |= 4),
        typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
      : (typeof s.componentDidUpdate != "function" ||
         (a === t.memoizedProps && m === t.memoizedState) ||
         (e.flags |= 4),
        typeof s.getSnapshotBeforeUpdate != "function" ||
         (a === t.memoizedProps && m === t.memoizedState) ||
         (e.flags |= 1024),
        (e.memoizedProps = r),
        (e.memoizedState = w)),
     (s.props = r),
     (s.state = w),
     (s.context = l),
     (r = u))
   : (typeof s.componentDidUpdate != "function" || (a === t.memoizedProps && m === t.memoizedState) || (e.flags |= 4),
     typeof s.getSnapshotBeforeUpdate != "function" ||
      (a === t.memoizedProps && m === t.memoizedState) ||
      (e.flags |= 1024),
     (r = !1));
 }
 return Up(t, e, n, r, o, i);
}
function Up(t, e, n, r, i, o) {
 tA(t, e);
 var s = (e.flags & 128) !== 0;
 if (!r && !s) return i && rw(e, n, !1), kr(t, e, o);
 (r = e.stateNode), (s2.current = e);
 var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render();
 return (
  (e.flags |= 1),
  t !== null && s ? ((e.child = Ts(e, t.child, null, o)), (e.child = Ts(e, null, a, o))) : Bt(t, e, a, o),
  (e.memoizedState = r.state),
  i && rw(e, n, !0),
  e.child
 );
}
function nA(t) {
 var e = t.stateNode;
 e.pendingContext ? nw(t, e.pendingContext, e.pendingContext !== e.context) : e.context && nw(t, e.context, !1),
  vg(t, e.containerInfo);
}
function _w(t, e, n, r, i) {
 return Es(), fg(i), (e.flags |= 256), Bt(t, e, n, r), e.child;
}
var Op = { dehydrated: null, treeContext: null, retryLane: 0 };
function Fp(t) {
 return { baseLanes: t, cachePool: null, transitions: null };
}
function rA(t, e, n) {
 var r = e.pendingProps,
  i = Ue.current,
  o = !1,
  s = (e.flags & 128) !== 0,
  a;
 if (
  ((a = s) || (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0),
  a ? ((o = !0), (e.flags &= -129)) : (t === null || t.memoizedState !== null) && (i |= 1),
  Re(Ue, i & 1),
  t === null)
 )
  return (
   Np(e),
   (t = e.memoizedState),
   t !== null && ((t = t.dehydrated), t !== null)
    ? (e.mode & 1 ? (t.data === "$!" ? (e.lanes = 8) : (e.lanes = 1073741824)) : (e.lanes = 1), null)
    : ((s = r.children),
      (t = r.fallback),
      o
       ? ((r = e.mode),
         (o = e.child),
         (s = { mode: "hidden", children: s }),
         !(r & 1) && o !== null ? ((o.childLanes = 0), (o.pendingProps = s)) : (o = Gd(s, r, 0, null)),
         (t = ro(t, r, n, null)),
         (o.return = e),
         (t.return = e),
         (o.sibling = t),
         (e.child = o),
         (e.child.memoizedState = Fp(n)),
         (e.memoizedState = Op),
         t)
       : Cg(e, s))
  );
 if (((i = t.memoizedState), i !== null && ((a = i.dehydrated), a !== null))) return a2(t, e, s, r, a, i, n);
 if (o) {
  (o = r.fallback), (s = e.mode), (i = t.child), (a = i.sibling);
  var l = { mode: "hidden", children: r.children };
  return (
   !(s & 1) && e.child !== i
    ? ((r = e.child), (r.childLanes = 0), (r.pendingProps = l), (e.deletions = null))
    : ((r = _i(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
   a !== null ? (o = _i(a, o)) : ((o = ro(o, s, n, null)), (o.flags |= 2)),
   (o.return = e),
   (r.return = e),
   (r.sibling = o),
   (e.child = r),
   (r = o),
   (o = e.child),
   (s = t.child.memoizedState),
   (s = s === null ? Fp(n) : { baseLanes: s.baseLanes | n, cachePool: null, transitions: s.transitions }),
   (o.memoizedState = s),
   (o.childLanes = t.childLanes & ~n),
   (e.memoizedState = Op),
   r
  );
 }
 return (
  (o = t.child),
  (t = o.sibling),
  (r = _i(o, { mode: "visible", children: r.children })),
  !(e.mode & 1) && (r.lanes = n),
  (r.return = e),
  (r.sibling = null),
  t !== null && ((n = e.deletions), n === null ? ((e.deletions = [t]), (e.flags |= 16)) : n.push(t)),
  (e.child = r),
  (e.memoizedState = null),
  r
 );
}
function Cg(t, e) {
 return (e = Gd({ mode: "visible", children: e }, t.mode, 0, null)), (e.return = t), (t.child = e);
}
function Ou(t, e, n, r) {
 return (
  r !== null && fg(r),
  Ts(e, t.child, null, n),
  (t = Cg(e, e.pendingProps.children)),
  (t.flags |= 2),
  (e.memoizedState = null),
  t
 );
}
function a2(t, e, n, r, i, o, s) {
 if (n)
  return e.flags & 256
   ? ((e.flags &= -257), (r = Ah(Error(H(422)))), Ou(t, e, s, r))
   : e.memoizedState !== null
     ? ((e.child = t.child), (e.flags |= 128), null)
     : ((o = r.fallback),
       (i = e.mode),
       (r = Gd({ mode: "visible", children: r.children }, i, 0, null)),
       (o = ro(o, i, s, null)),
       (o.flags |= 2),
       (r.return = e),
       (o.return = e),
       (r.sibling = o),
       (e.child = r),
       e.mode & 1 && Ts(e, t.child, null, s),
       (e.child.memoizedState = Fp(s)),
       (e.memoizedState = Op),
       o);
 if (!(e.mode & 1)) return Ou(t, e, s, null);
 if (i.data === "$!") {
  if (((r = i.nextSibling && i.nextSibling.dataset), r)) var a = r.dgst;
  return (r = a), (o = Error(H(419))), (r = Ah(o, r, void 0)), Ou(t, e, s, r);
 }
 if (((a = (s & t.childLanes) !== 0), jt || a)) {
  if (((r = ut), r !== null)) {
   switch (s & -s) {
    case 4:
     i = 2;
     break;
    case 16:
     i = 8;
     break;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
     i = 32;
     break;
    case 536870912:
     i = 268435456;
     break;
    default:
     i = 0;
   }
   (i = i & (r.suspendedLanes | s) ? 0 : i),
    i !== 0 && i !== o.retryLane && ((o.retryLane = i), Pr(t, i), On(r, t, i, -1));
  }
  return xg(), (r = Ah(Error(H(421)))), Ou(t, e, s, r);
 }
 return i.data === "$?"
  ? ((e.flags |= 128), (e.child = t.child), (e = w2.bind(null, t)), (i._reactRetry = e), null)
  : ((t = o.treeContext),
    (ln = mi(i.nextSibling)),
    (dn = e),
    (Me = !0),
    (Vn = null),
    t !== null && ((wn[En++] = vr), (wn[En++] = _r), (wn[En++] = lo), (vr = t.id), (_r = t.overflow), (lo = e)),
    (e = Cg(e, r.children)),
    (e.flags |= 4096),
    e);
}
function ww(t, e, n) {
 t.lanes |= e;
 var r = t.alternate;
 r !== null && (r.lanes |= e), xp(t.return, e, n);
}
function Ch(t, e, n, r, i) {
 var o = t.memoizedState;
 o === null
  ? (t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i })
  : ((o.isBackwards = e),
    (o.rendering = null),
    (o.renderingStartTime = 0),
    (o.last = r),
    (o.tail = n),
    (o.tailMode = i));
}
function iA(t, e, n) {
 var r = e.pendingProps,
  i = r.revealOrder,
  o = r.tail;
 if ((Bt(t, e, r.children, n), (r = Ue.current), r & 2)) (r = (r & 1) | 2), (e.flags |= 128);
 else {
  if (t !== null && t.flags & 128)
   e: for (t = e.child; t !== null; ) {
    if (t.tag === 13) t.memoizedState !== null && ww(t, n, e);
    else if (t.tag === 19) ww(t, n, e);
    else if (t.child !== null) {
     (t.child.return = t), (t = t.child);
     continue;
    }
    if (t === e) break e;
    for (; t.sibling === null; ) {
     if (t.return === null || t.return === e) break e;
     t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
   }
  r &= 1;
 }
 if ((Re(Ue, r), !(e.mode & 1))) e.memoizedState = null;
 else
  switch (i) {
   case "forwards":
    for (n = e.child, i = null; n !== null; )
     (t = n.alternate), t !== null && Wc(t) === null && (i = n), (n = n.sibling);
    (n = i), n === null ? ((i = e.child), (e.child = null)) : ((i = n.sibling), (n.sibling = null)), Ch(e, !1, i, n, o);
    break;
   case "backwards":
    for (n = null, i = e.child, e.child = null; i !== null; ) {
     if (((t = i.alternate), t !== null && Wc(t) === null)) {
      e.child = i;
      break;
     }
     (t = i.sibling), (i.sibling = n), (n = i), (i = t);
    }
    Ch(e, !0, n, null, o);
    break;
   case "together":
    Ch(e, !1, null, null, void 0);
    break;
   default:
    e.memoizedState = null;
  }
 return e.child;
}
function mc(t, e) {
 !(e.mode & 1) && t !== null && ((t.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function kr(t, e, n) {
 if ((t !== null && (e.dependencies = t.dependencies), (co |= e.lanes), !(n & e.childLanes))) return null;
 if (t !== null && e.child !== t.child) throw Error(H(153));
 if (e.child !== null) {
  for (t = e.child, n = _i(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null; )
   (t = t.sibling), (n = n.sibling = _i(t, t.pendingProps)), (n.return = e);
  n.sibling = null;
 }
 return e.child;
}
function l2(t, e, n) {
 switch (e.tag) {
  case 3:
   nA(e), Es();
   break;
  case 5:
   bS(e);
   break;
  case 1:
   en(e.type) && Bc(e);
   break;
  case 4:
   vg(e, e.stateNode.containerInfo);
   break;
  case 10:
   var r = e.type._context,
    i = e.memoizedProps.value;
   Re(qc, r._currentValue), (r._currentValue = i);
   break;
  case 13:
   if (((r = e.memoizedState), r !== null))
    return r.dehydrated !== null
     ? (Re(Ue, Ue.current & 1), (e.flags |= 128), null)
     : n & e.child.childLanes
       ? rA(t, e, n)
       : (Re(Ue, Ue.current & 1), (t = kr(t, e, n)), t !== null ? t.sibling : null);
   Re(Ue, Ue.current & 1);
   break;
  case 19:
   if (((r = (n & e.childLanes) !== 0), t.flags & 128)) {
    if (r) return iA(t, e, n);
    e.flags |= 128;
   }
   if (
    ((i = e.memoizedState),
    i !== null && ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
    Re(Ue, Ue.current),
    r)
   )
    break;
   return null;
  case 22:
  case 23:
   return (e.lanes = 0), eA(t, e, n);
 }
 return kr(t, e, n);
}
var oA, Bp, sA, aA;
oA = function (t, e) {
 for (var n = e.child; n !== null; ) {
  if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
  else if (n.tag !== 4 && n.child !== null) {
   (n.child.return = n), (n = n.child);
   continue;
  }
  if (n === e) break;
  for (; n.sibling === null; ) {
   if (n.return === null || n.return === e) return;
   n = n.return;
  }
  (n.sibling.return = n.return), (n = n.sibling);
 }
};
Bp = function () {};
sA = function (t, e, n, r) {
 var i = t.memoizedProps;
 if (i !== r) {
  (t = e.stateNode), Zi(nr.current);
  var o = null;
  switch (n) {
   case "input":
    (i = lp(t, i)), (r = lp(t, r)), (o = []);
    break;
   case "select":
    (i = Fe({}, i, { value: void 0 })), (r = Fe({}, r, { value: void 0 })), (o = []);
    break;
   case "textarea":
    (i = dp(t, i)), (r = dp(t, r)), (o = []);
    break;
   default:
    typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = Oc);
  }
  hp(n, r);
  var s;
  n = null;
  for (u in i)
   if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null)
    if (u === "style") {
     var a = i[u];
     for (s in a) a.hasOwnProperty(s) && (n || (n = {}), (n[s] = ""));
    } else
     u !== "dangerouslySetInnerHTML" &&
      u !== "children" &&
      u !== "suppressContentEditableWarning" &&
      u !== "suppressHydrationWarning" &&
      u !== "autoFocus" &&
      (Za.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null));
  for (u in r) {
   var l = r[u];
   if (((a = i != null ? i[u] : void 0), r.hasOwnProperty(u) && l !== a && (l != null || a != null)))
    if (u === "style")
     if (a) {
      for (s in a) !a.hasOwnProperty(s) || (l && l.hasOwnProperty(s)) || (n || (n = {}), (n[s] = ""));
      for (s in l) l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), (n[s] = l[s]));
     } else n || (o || (o = []), o.push(u, n)), (n = l);
    else
     u === "dangerouslySetInnerHTML"
      ? ((l = l ? l.__html : void 0), (a = a ? a.__html : void 0), l != null && a !== l && (o = o || []).push(u, l))
      : u === "children"
        ? (typeof l != "string" && typeof l != "number") || (o = o || []).push(u, "" + l)
        : u !== "suppressContentEditableWarning" &&
          u !== "suppressHydrationWarning" &&
          (Za.hasOwnProperty(u)
           ? (l != null && u === "onScroll" && be("scroll", t), o || a === l || (o = []))
           : (o = o || []).push(u, l));
  }
  n && (o = o || []).push("style", n);
  var u = o;
  (e.updateQueue = u) && (e.flags |= 4);
 }
};
aA = function (t, e, n, r) {
 n !== r && (e.flags |= 4);
};
function va(t, e) {
 if (!Me)
  switch (t.tailMode) {
   case "hidden":
    e = t.tail;
    for (var n = null; e !== null; ) e.alternate !== null && (n = e), (e = e.sibling);
    n === null ? (t.tail = null) : (n.sibling = null);
    break;
   case "collapsed":
    n = t.tail;
    for (var r = null; n !== null; ) n.alternate !== null && (r = n), (n = n.sibling);
    r === null ? (e || t.tail === null ? (t.tail = null) : (t.tail.sibling = null)) : (r.sibling = null);
  }
}
function St(t) {
 var e = t.alternate !== null && t.alternate.child === t.child,
  n = 0,
  r = 0;
 if (e)
  for (var i = t.child; i !== null; )
   (n |= i.lanes | i.childLanes),
    (r |= i.subtreeFlags & 14680064),
    (r |= i.flags & 14680064),
    (i.return = t),
    (i = i.sibling);
 else
  for (i = t.child; i !== null; )
   (n |= i.lanes | i.childLanes), (r |= i.subtreeFlags), (r |= i.flags), (i.return = t), (i = i.sibling);
 return (t.subtreeFlags |= r), (t.childLanes = n), e;
}
function u2(t, e, n) {
 var r = e.pendingProps;
 switch ((dg(e), e.tag)) {
  case 2:
  case 16:
  case 15:
  case 0:
  case 11:
  case 7:
  case 8:
  case 12:
  case 9:
  case 14:
   return St(e), null;
  case 1:
   return en(e.type) && Fc(), St(e), null;
  case 3:
   return (
    (r = e.stateNode),
    Is(),
    xe(Zt),
    xe(Mt),
    wg(),
    r.pendingContext && ((r.context = r.pendingContext), (r.pendingContext = null)),
    (t === null || t.child === null) &&
     (Vu(e)
      ? (e.flags |= 4)
      : t === null ||
        (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
        ((e.flags |= 1024), Vn !== null && (Jp(Vn), (Vn = null)))),
    Bp(t, e),
    St(e),
    null
   );
  case 5:
   _g(e);
   var i = Zi(dl.current);
   if (((n = e.type), t !== null && e.stateNode != null))
    sA(t, e, n, r, i), t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
   else {
    if (!r) {
     if (e.stateNode === null) throw Error(H(166));
     return St(e), null;
    }
    if (((t = Zi(nr.current)), Vu(e))) {
     (r = e.stateNode), (n = e.type);
     var o = e.memoizedProps;
     switch (((r[jn] = e), (r[ul] = o), (t = (e.mode & 1) !== 0), n)) {
      case "dialog":
       be("cancel", r), be("close", r);
       break;
      case "iframe":
      case "object":
      case "embed":
       be("load", r);
       break;
      case "video":
      case "audio":
       for (i = 0; i < ka.length; i++) be(ka[i], r);
       break;
      case "source":
       be("error", r);
       break;
      case "img":
      case "image":
      case "link":
       be("error", r), be("load", r);
       break;
      case "details":
       be("toggle", r);
       break;
      case "input":
       k_(r, o), be("invalid", r);
       break;
      case "select":
       (r._wrapperState = { wasMultiple: !!o.multiple }), be("invalid", r);
       break;
      case "textarea":
       N_(r, o), be("invalid", r);
     }
     hp(n, o), (i = null);
     for (var s in o)
      if (o.hasOwnProperty(s)) {
       var a = o[s];
       s === "children"
        ? typeof a == "string"
          ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && Lu(r.textContent, a, t), (i = ["children", a]))
          : typeof a == "number" &&
            r.textContent !== "" + a &&
            (o.suppressHydrationWarning !== !0 && Lu(r.textContent, a, t), (i = ["children", "" + a]))
        : Za.hasOwnProperty(s) && a != null && s === "onScroll" && be("scroll", r);
      }
     switch (n) {
      case "input":
       Ru(r), b_(r, o, !0);
       break;
      case "textarea":
       Ru(r), x_(r);
       break;
      case "select":
      case "option":
       break;
      default:
       typeof o.onClick == "function" && (r.onclick = Oc);
     }
     (r = i), (e.updateQueue = r), r !== null && (e.flags |= 4);
    } else {
     (s = i.nodeType === 9 ? i : i.ownerDocument),
      t === "http://www.w3.org/1999/xhtml" && (t = LI(n)),
      t === "http://www.w3.org/1999/xhtml"
       ? n === "script"
         ? ((t = s.createElement("div")), (t.innerHTML = "<script></script>"), (t = t.removeChild(t.firstChild)))
         : typeof r.is == "string"
           ? (t = s.createElement(n, { is: r.is }))
           : ((t = s.createElement(n)),
             n === "select" && ((s = t), r.multiple ? (s.multiple = !0) : r.size && (s.size = r.size)))
       : (t = s.createElementNS(t, n)),
      (t[jn] = e),
      (t[ul] = r),
      oA(t, e, !1, !1),
      (e.stateNode = t);
     e: {
      switch (((s = pp(n, r)), n)) {
       case "dialog":
        be("cancel", t), be("close", t), (i = r);
        break;
       case "iframe":
       case "object":
       case "embed":
        be("load", t), (i = r);
        break;
       case "video":
       case "audio":
        for (i = 0; i < ka.length; i++) be(ka[i], t);
        i = r;
        break;
       case "source":
        be("error", t), (i = r);
        break;
       case "img":
       case "image":
       case "link":
        be("error", t), be("load", t), (i = r);
        break;
       case "details":
        be("toggle", t), (i = r);
        break;
       case "input":
        k_(t, r), (i = lp(t, r)), be("invalid", t);
        break;
       case "option":
        i = r;
        break;
       case "select":
        (t._wrapperState = { wasMultiple: !!r.multiple }), (i = Fe({}, r, { value: void 0 })), be("invalid", t);
        break;
       case "textarea":
        N_(t, r), (i = dp(t, r)), be("invalid", t);
        break;
       default:
        i = r;
      }
      hp(n, i), (a = i);
      for (o in a)
       if (a.hasOwnProperty(o)) {
        var l = a[o];
        o === "style"
         ? OI(t, l)
         : o === "dangerouslySetInnerHTML"
           ? ((l = l ? l.__html : void 0), l != null && VI(t, l))
           : o === "children"
             ? typeof l == "string"
               ? (n !== "textarea" || l !== "") && el(t, l)
               : typeof l == "number" && el(t, "" + l)
             : o !== "suppressContentEditableWarning" &&
               o !== "suppressHydrationWarning" &&
               o !== "autoFocus" &&
               (Za.hasOwnProperty(o) ? l != null && o === "onScroll" && be("scroll", t) : l != null && Qm(t, o, l, s));
       }
      switch (n) {
       case "input":
        Ru(t), b_(t, r, !1);
        break;
       case "textarea":
        Ru(t), x_(t);
        break;
       case "option":
        r.value != null && t.setAttribute("value", "" + Si(r.value));
        break;
       case "select":
        (t.multiple = !!r.multiple),
         (o = r.value),
         o != null ? ss(t, !!r.multiple, o, !1) : r.defaultValue != null && ss(t, !!r.multiple, r.defaultValue, !0);
        break;
       default:
        typeof i.onClick == "function" && (t.onclick = Oc);
      }
      switch (n) {
       case "button":
       case "input":
       case "select":
       case "textarea":
        r = !!r.autoFocus;
        break e;
       case "img":
        r = !0;
        break e;
       default:
        r = !1;
      }
     }
     r && (e.flags |= 4);
    }
    e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
   }
   return St(e), null;
  case 6:
   if (t && e.stateNode != null) aA(t, e, t.memoizedProps, r);
   else {
    if (typeof r != "string" && e.stateNode === null) throw Error(H(166));
    if (((n = Zi(dl.current)), Zi(nr.current), Vu(e))) {
     if (((r = e.stateNode), (n = e.memoizedProps), (r[jn] = e), (o = r.nodeValue !== n) && ((t = dn), t !== null)))
      switch (t.tag) {
       case 3:
        Lu(r.nodeValue, n, (t.mode & 1) !== 0);
        break;
       case 5:
        t.memoizedProps.suppressHydrationWarning !== !0 && Lu(r.nodeValue, n, (t.mode & 1) !== 0);
      }
     o && (e.flags |= 4);
    } else (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)), (r[jn] = e), (e.stateNode = r);
   }
   return St(e), null;
  case 13:
   if (
    (xe(Ue), (r = e.memoizedState), t === null || (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
   ) {
    if (Me && ln !== null && e.mode & 1 && !(e.flags & 128)) AS(), Es(), (e.flags |= 98560), (o = !1);
    else if (((o = Vu(e)), r !== null && r.dehydrated !== null)) {
     if (t === null) {
      if (!o) throw Error(H(318));
      if (((o = e.memoizedState), (o = o !== null ? o.dehydrated : null), !o)) throw Error(H(317));
      o[jn] = e;
     } else Es(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
     St(e), (o = !1);
    } else Vn !== null && (Jp(Vn), (Vn = null)), (o = !0);
    if (!o) return e.flags & 65536 ? e : null;
   }
   return e.flags & 128
    ? ((e.lanes = n), e)
    : ((r = r !== null),
      r !== (t !== null && t.memoizedState !== null) &&
       r &&
       ((e.child.flags |= 8192), e.mode & 1 && (t === null || Ue.current & 1 ? ot === 0 && (ot = 3) : xg())),
      e.updateQueue !== null && (e.flags |= 4),
      St(e),
      null);
  case 4:
   return Is(), Bp(t, e), t === null && al(e.stateNode.containerInfo), St(e), null;
  case 10:
   return mg(e.type._context), St(e), null;
  case 17:
   return en(e.type) && Fc(), St(e), null;
  case 19:
   if ((xe(Ue), (o = e.memoizedState), o === null)) return St(e), null;
   if (((r = (e.flags & 128) !== 0), (s = o.rendering), s === null))
    if (r) va(o, !1);
    else {
     if (ot !== 0 || (t !== null && t.flags & 128))
      for (t = e.child; t !== null; ) {
       if (((s = Wc(t)), s !== null)) {
        for (
         e.flags |= 128,
          va(o, !1),
          r = s.updateQueue,
          r !== null && ((e.updateQueue = r), (e.flags |= 4)),
          e.subtreeFlags = 0,
          r = n,
          n = e.child;
         n !== null;

        )
         (o = n),
          (t = r),
          (o.flags &= 14680066),
          (s = o.alternate),
          s === null
           ? ((o.childLanes = 0),
             (o.lanes = t),
             (o.child = null),
             (o.subtreeFlags = 0),
             (o.memoizedProps = null),
             (o.memoizedState = null),
             (o.updateQueue = null),
             (o.dependencies = null),
             (o.stateNode = null))
           : ((o.childLanes = s.childLanes),
             (o.lanes = s.lanes),
             (o.child = s.child),
             (o.subtreeFlags = 0),
             (o.deletions = null),
             (o.memoizedProps = s.memoizedProps),
             (o.memoizedState = s.memoizedState),
             (o.updateQueue = s.updateQueue),
             (o.type = s.type),
             (t = s.dependencies),
             (o.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext })),
          (n = n.sibling);
        return Re(Ue, (Ue.current & 1) | 2), e.child;
       }
       t = t.sibling;
      }
     o.tail !== null && Ye() > As && ((e.flags |= 128), (r = !0), va(o, !1), (e.lanes = 4194304));
    }
   else {
    if (!r)
     if (((t = Wc(s)), t !== null)) {
      if (
       ((e.flags |= 128),
       (r = !0),
       (n = t.updateQueue),
       n !== null && ((e.updateQueue = n), (e.flags |= 4)),
       va(o, !0),
       o.tail === null && o.tailMode === "hidden" && !s.alternate && !Me)
      )
       return St(e), null;
     } else
      2 * Ye() - o.renderingStartTime > As &&
       n !== 1073741824 &&
       ((e.flags |= 128), (r = !0), va(o, !1), (e.lanes = 4194304));
    o.isBackwards
     ? ((s.sibling = e.child), (e.child = s))
     : ((n = o.last), n !== null ? (n.sibling = s) : (e.child = s), (o.last = s));
   }
   return o.tail !== null
    ? ((e = o.tail),
      (o.rendering = e),
      (o.tail = e.sibling),
      (o.renderingStartTime = Ye()),
      (e.sibling = null),
      (n = Ue.current),
      Re(Ue, r ? (n & 1) | 2 : n & 1),
      e)
    : (St(e), null);
  case 22:
  case 23:
   return (
    Ng(),
    (r = e.memoizedState !== null),
    t !== null && (t.memoizedState !== null) !== r && (e.flags |= 8192),
    r && e.mode & 1 ? an & 1073741824 && (St(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : St(e),
    null
   );
  case 24:
   return null;
  case 25:
   return null;
 }
 throw Error(H(156, e.tag));
}
function c2(t, e) {
 switch ((dg(e), e.tag)) {
  case 1:
   return en(e.type) && Fc(), (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null;
  case 3:
   return (
    Is(), xe(Zt), xe(Mt), wg(), (t = e.flags), t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
   );
  case 5:
   return _g(e), null;
  case 13:
   if ((xe(Ue), (t = e.memoizedState), t !== null && t.dehydrated !== null)) {
    if (e.alternate === null) throw Error(H(340));
    Es();
   }
   return (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null;
  case 19:
   return xe(Ue), null;
  case 4:
   return Is(), null;
  case 10:
   return mg(e.type._context), null;
  case 22:
  case 23:
   return Ng(), null;
  case 24:
   return null;
  default:
   return null;
 }
}
var Fu = !1,
 Pt = !1,
 d2 = typeof WeakSet == "function" ? WeakSet : Set,
 Y = null;
function ts(t, e) {
 var n = t.ref;
 if (n !== null)
  if (typeof n == "function")
   try {
    n(null);
   } catch (r) {
    He(t, e, r);
   }
  else n.current = null;
}
function $p(t, e, n) {
 try {
  n();
 } catch (r) {
  He(t, e, r);
 }
}
var Ew = !1;
function f2(t, e) {
 if (((Sp = Lc), (t = fS()), ug(t))) {
  if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd };
  else
   e: {
    n = ((n = t.ownerDocument) && n.defaultView) || window;
    var r = n.getSelection && n.getSelection();
    if (r && r.rangeCount !== 0) {
     n = r.anchorNode;
     var i = r.anchorOffset,
      o = r.focusNode;
     r = r.focusOffset;
     try {
      n.nodeType, o.nodeType;
     } catch {
      n = null;
      break e;
     }
     var s = 0,
      a = -1,
      l = -1,
      u = 0,
      h = 0,
      p = t,
      m = null;
     t: for (;;) {
      for (
       var v;
       p !== n || (i !== 0 && p.nodeType !== 3) || (a = s + i),
        p !== o || (r !== 0 && p.nodeType !== 3) || (l = s + r),
        p.nodeType === 3 && (s += p.nodeValue.length),
        (v = p.firstChild) !== null;

      )
       (m = p), (p = v);
      for (;;) {
       if (p === t) break t;
       if ((m === n && ++u === i && (a = s), m === o && ++h === r && (l = s), (v = p.nextSibling) !== null)) break;
       (p = m), (m = p.parentNode);
      }
      p = v;
     }
     n = a === -1 || l === -1 ? null : { start: a, end: l };
    } else n = null;
   }
  n = n || { start: 0, end: 0 };
 } else n = null;
 for (Ap = { focusedElem: t, selectionRange: n }, Lc = !1, Y = e; Y !== null; )
  if (((e = Y), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null)) (t.return = e), (Y = t);
  else
   for (; Y !== null; ) {
    e = Y;
    try {
     var w = e.alternate;
     if (e.flags & 1024)
      switch (e.tag) {
       case 0:
       case 11:
       case 15:
        break;
       case 1:
        if (w !== null) {
         var C = w.memoizedProps,
          A = w.memoizedState,
          T = e.stateNode,
          _ = T.getSnapshotBeforeUpdate(e.elementType === e.type ? C : Dn(e.type, C), A);
         T.__reactInternalSnapshotBeforeUpdate = _;
        }
        break;
       case 3:
        var E = e.stateNode.containerInfo;
        E.nodeType === 1
         ? (E.textContent = "")
         : E.nodeType === 9 && E.documentElement && E.removeChild(E.documentElement);
        break;
       case 5:
       case 6:
       case 4:
       case 17:
        break;
       default:
        throw Error(H(163));
      }
    } catch (N) {
     He(e, e.return, N);
    }
    if (((t = e.sibling), t !== null)) {
     (t.return = e.return), (Y = t);
     break;
    }
    Y = e.return;
   }
 return (w = Ew), (Ew = !1), w;
}
function qa(t, e, n) {
 var r = e.updateQueue;
 if (((r = r !== null ? r.lastEffect : null), r !== null)) {
  var i = (r = r.next);
  do {
   if ((i.tag & t) === t) {
    var o = i.destroy;
    (i.destroy = void 0), o !== void 0 && $p(e, n, o);
   }
   i = i.next;
  } while (i !== r);
 }
}
function Hd(t, e) {
 if (((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)) {
  var n = (e = e.next);
  do {
   if ((n.tag & t) === t) {
    var r = n.create;
    n.destroy = r();
   }
   n = n.next;
  } while (n !== e);
 }
}
function Hp(t) {
 var e = t.ref;
 if (e !== null) {
  var n = t.stateNode;
  switch (t.tag) {
   case 5:
    t = n;
    break;
   default:
    t = n;
  }
  typeof e == "function" ? e(t) : (e.current = t);
 }
}
function lA(t) {
 var e = t.alternate;
 e !== null && ((t.alternate = null), lA(e)),
  (t.child = null),
  (t.deletions = null),
  (t.sibling = null),
  t.tag === 5 &&
   ((e = t.stateNode), e !== null && (delete e[jn], delete e[ul], delete e[Pp], delete e[Jx], delete e[Yx])),
  (t.stateNode = null),
  (t.return = null),
  (t.dependencies = null),
  (t.memoizedProps = null),
  (t.memoizedState = null),
  (t.pendingProps = null),
  (t.stateNode = null),
  (t.updateQueue = null);
}
function uA(t) {
 return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function Tw(t) {
 e: for (;;) {
  for (; t.sibling === null; ) {
   if (t.return === null || uA(t.return)) return null;
   t = t.return;
  }
  for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
   if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
   (t.child.return = t), (t = t.child);
  }
  if (!(t.flags & 2)) return t.stateNode;
 }
}
function qp(t, e, n) {
 var r = t.tag;
 if (r === 5 || r === 6)
  (t = t.stateNode),
   e
    ? n.nodeType === 8
      ? n.parentNode.insertBefore(t, e)
      : n.insertBefore(t, e)
    : (n.nodeType === 8 ? ((e = n.parentNode), e.insertBefore(t, n)) : ((e = n), e.appendChild(t)),
      (n = n._reactRootContainer),
      n != null || e.onclick !== null || (e.onclick = Oc));
 else if (r !== 4 && ((t = t.child), t !== null))
  for (qp(t, e, n), t = t.sibling; t !== null; ) qp(t, e, n), (t = t.sibling);
}
function Gp(t, e, n) {
 var r = t.tag;
 if (r === 5 || r === 6) (t = t.stateNode), e ? n.insertBefore(t, e) : n.appendChild(t);
 else if (r !== 4 && ((t = t.child), t !== null))
  for (Gp(t, e, n), t = t.sibling; t !== null; ) Gp(t, e, n), (t = t.sibling);
}
var ht = null,
 Ln = !1;
function zr(t, e, n) {
 for (n = n.child; n !== null; ) cA(t, e, n), (n = n.sibling);
}
function cA(t, e, n) {
 if (tr && typeof tr.onCommitFiberUnmount == "function")
  try {
   tr.onCommitFiberUnmount(Dd, n);
  } catch {}
 switch (n.tag) {
  case 5:
   Pt || ts(n, e);
  case 6:
   var r = ht,
    i = Ln;
   (ht = null),
    zr(t, e, n),
    (ht = r),
    (Ln = i),
    ht !== null &&
     (Ln
      ? ((t = ht), (n = n.stateNode), t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n))
      : ht.removeChild(n.stateNode));
   break;
  case 18:
   ht !== null &&
    (Ln
     ? ((t = ht), (n = n.stateNode), t.nodeType === 8 ? _h(t.parentNode, n) : t.nodeType === 1 && _h(t, n), il(t))
     : _h(ht, n.stateNode));
   break;
  case 4:
   (r = ht), (i = Ln), (ht = n.stateNode.containerInfo), (Ln = !0), zr(t, e, n), (ht = r), (Ln = i);
   break;
  case 0:
  case 11:
  case 14:
  case 15:
   if (!Pt && ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))) {
    i = r = r.next;
    do {
     var o = i,
      s = o.destroy;
     (o = o.tag), s !== void 0 && (o & 2 || o & 4) && $p(n, e, s), (i = i.next);
    } while (i !== r);
   }
   zr(t, e, n);
   break;
  case 1:
   if (!Pt && (ts(n, e), (r = n.stateNode), typeof r.componentWillUnmount == "function"))
    try {
     (r.props = n.memoizedProps), (r.state = n.memoizedState), r.componentWillUnmount();
    } catch (a) {
     He(n, e, a);
    }
   zr(t, e, n);
   break;
  case 21:
   zr(t, e, n);
   break;
  case 22:
   n.mode & 1 ? ((Pt = (r = Pt) || n.memoizedState !== null), zr(t, e, n), (Pt = r)) : zr(t, e, n);
   break;
  default:
   zr(t, e, n);
 }
}
function Iw(t) {
 var e = t.updateQueue;
 if (e !== null) {
  t.updateQueue = null;
  var n = t.stateNode;
  n === null && (n = t.stateNode = new d2()),
   e.forEach(function (r) {
    var i = E2.bind(null, t, r);
    n.has(r) || (n.add(r), r.then(i, i));
   });
 }
}
function xn(t, e) {
 var n = e.deletions;
 if (n !== null)
  for (var r = 0; r < n.length; r++) {
   var i = n[r];
   try {
    var o = t,
     s = e,
     a = s;
    e: for (; a !== null; ) {
     switch (a.tag) {
      case 5:
       (ht = a.stateNode), (Ln = !1);
       break e;
      case 3:
       (ht = a.stateNode.containerInfo), (Ln = !0);
       break e;
      case 4:
       (ht = a.stateNode.containerInfo), (Ln = !0);
       break e;
     }
     a = a.return;
    }
    if (ht === null) throw Error(H(160));
    cA(o, s, i), (ht = null), (Ln = !1);
    var l = i.alternate;
    l !== null && (l.return = null), (i.return = null);
   } catch (u) {
    He(i, e, u);
   }
  }
 if (e.subtreeFlags & 12854) for (e = e.child; e !== null; ) dA(e, t), (e = e.sibling);
}
function dA(t, e) {
 var n = t.alternate,
  r = t.flags;
 switch (t.tag) {
  case 0:
  case 11:
  case 14:
  case 15:
   if ((xn(e, t), Kn(t), r & 4)) {
    try {
     qa(3, t, t.return), Hd(3, t);
    } catch (C) {
     He(t, t.return, C);
    }
    try {
     qa(5, t, t.return);
    } catch (C) {
     He(t, t.return, C);
    }
   }
   break;
  case 1:
   xn(e, t), Kn(t), r & 512 && n !== null && ts(n, n.return);
   break;
  case 5:
   if ((xn(e, t), Kn(t), r & 512 && n !== null && ts(n, n.return), t.flags & 32)) {
    var i = t.stateNode;
    try {
     el(i, "");
    } catch (C) {
     He(t, t.return, C);
    }
   }
   if (r & 4 && ((i = t.stateNode), i != null)) {
    var o = t.memoizedProps,
     s = n !== null ? n.memoizedProps : o,
     a = t.type,
     l = t.updateQueue;
    if (((t.updateQueue = null), l !== null))
     try {
      a === "input" && o.type === "radio" && o.name != null && MI(i, o), pp(a, s);
      var u = pp(a, o);
      for (s = 0; s < l.length; s += 2) {
       var h = l[s],
        p = l[s + 1];
       h === "style"
        ? OI(i, p)
        : h === "dangerouslySetInnerHTML"
          ? VI(i, p)
          : h === "children"
            ? el(i, p)
            : Qm(i, h, p, u);
      }
      switch (a) {
       case "input":
        up(i, o);
        break;
       case "textarea":
        DI(i, o);
        break;
       case "select":
        var m = i._wrapperState.wasMultiple;
        i._wrapperState.wasMultiple = !!o.multiple;
        var v = o.value;
        v != null
         ? ss(i, !!o.multiple, v, !1)
         : m !== !!o.multiple &&
           (o.defaultValue != null
            ? ss(i, !!o.multiple, o.defaultValue, !0)
            : ss(i, !!o.multiple, o.multiple ? [] : "", !1));
      }
      i[ul] = o;
     } catch (C) {
      He(t, t.return, C);
     }
   }
   break;
  case 6:
   if ((xn(e, t), Kn(t), r & 4)) {
    if (t.stateNode === null) throw Error(H(162));
    (i = t.stateNode), (o = t.memoizedProps);
    try {
     i.nodeValue = o;
    } catch (C) {
     He(t, t.return, C);
    }
   }
   break;
  case 3:
   if ((xn(e, t), Kn(t), r & 4 && n !== null && n.memoizedState.isDehydrated))
    try {
     il(e.containerInfo);
    } catch (C) {
     He(t, t.return, C);
    }
   break;
  case 4:
   xn(e, t), Kn(t);
   break;
  case 13:
   xn(e, t),
    Kn(t),
    (i = t.child),
    i.flags & 8192 &&
     ((o = i.memoizedState !== null),
     (i.stateNode.isHidden = o),
     !o || (i.alternate !== null && i.alternate.memoizedState !== null) || (kg = Ye())),
    r & 4 && Iw(t);
   break;
  case 22:
   if (
    ((h = n !== null && n.memoizedState !== null),
    t.mode & 1 ? ((Pt = (u = Pt) || h), xn(e, t), (Pt = u)) : xn(e, t),
    Kn(t),
    r & 8192)
   ) {
    if (((u = t.memoizedState !== null), (t.stateNode.isHidden = u) && !h && t.mode & 1))
     for (Y = t, h = t.child; h !== null; ) {
      for (p = Y = h; Y !== null; ) {
       switch (((m = Y), (v = m.child), m.tag)) {
        case 0:
        case 11:
        case 14:
        case 15:
         qa(4, m, m.return);
         break;
        case 1:
         ts(m, m.return);
         var w = m.stateNode;
         if (typeof w.componentWillUnmount == "function") {
          (r = m), (n = m.return);
          try {
           (e = r), (w.props = e.memoizedProps), (w.state = e.memoizedState), w.componentWillUnmount();
          } catch (C) {
           He(r, n, C);
          }
         }
         break;
        case 5:
         ts(m, m.return);
         break;
        case 22:
         if (m.memoizedState !== null) {
          Aw(p);
          continue;
         }
       }
       v !== null ? ((v.return = m), (Y = v)) : Aw(p);
      }
      h = h.sibling;
     }
    e: for (h = null, p = t; ; ) {
     if (p.tag === 5) {
      if (h === null) {
       h = p;
       try {
        (i = p.stateNode),
         u
          ? ((o = i.style),
            typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : (o.display = "none"))
          : ((a = p.stateNode),
            (l = p.memoizedProps.style),
            (s = l != null && l.hasOwnProperty("display") ? l.display : null),
            (a.style.display = UI("display", s)));
       } catch (C) {
        He(t, t.return, C);
       }
      }
     } else if (p.tag === 6) {
      if (h === null)
       try {
        p.stateNode.nodeValue = u ? "" : p.memoizedProps;
       } catch (C) {
        He(t, t.return, C);
       }
     } else if (((p.tag !== 22 && p.tag !== 23) || p.memoizedState === null || p === t) && p.child !== null) {
      (p.child.return = p), (p = p.child);
      continue;
     }
     if (p === t) break e;
     for (; p.sibling === null; ) {
      if (p.return === null || p.return === t) break e;
      h === p && (h = null), (p = p.return);
     }
     h === p && (h = null), (p.sibling.return = p.return), (p = p.sibling);
    }
   }
   break;
  case 19:
   xn(e, t), Kn(t), r & 4 && Iw(t);
   break;
  case 21:
   break;
  default:
   xn(e, t), Kn(t);
 }
}
function Kn(t) {
 var e = t.flags;
 if (e & 2) {
  try {
   e: {
    for (var n = t.return; n !== null; ) {
     if (uA(n)) {
      var r = n;
      break e;
     }
     n = n.return;
    }
    throw Error(H(160));
   }
   switch (r.tag) {
    case 5:
     var i = r.stateNode;
     r.flags & 32 && (el(i, ""), (r.flags &= -33));
     var o = Tw(t);
     Gp(t, o, i);
     break;
    case 3:
    case 4:
     var s = r.stateNode.containerInfo,
      a = Tw(t);
     qp(t, a, s);
     break;
    default:
     throw Error(H(161));
   }
  } catch (l) {
   He(t, t.return, l);
  }
  t.flags &= -3;
 }
 e & 4096 && (t.flags &= -4097);
}
function h2(t, e, n) {
 (Y = t), fA(t);
}
function fA(t, e, n) {
 for (var r = (t.mode & 1) !== 0; Y !== null; ) {
  var i = Y,
   o = i.child;
  if (i.tag === 22 && r) {
   var s = i.memoizedState !== null || Fu;
   if (!s) {
    var a = i.alternate,
     l = (a !== null && a.memoizedState !== null) || Pt;
    a = Fu;
    var u = Pt;
    if (((Fu = s), (Pt = l) && !u))
     for (Y = i; Y !== null; )
      (s = Y),
       (l = s.child),
       s.tag === 22 && s.memoizedState !== null ? Cw(i) : l !== null ? ((l.return = s), (Y = l)) : Cw(i);
    for (; o !== null; ) (Y = o), fA(o), (o = o.sibling);
    (Y = i), (Fu = a), (Pt = u);
   }
   Sw(t);
  } else i.subtreeFlags & 8772 && o !== null ? ((o.return = i), (Y = o)) : Sw(t);
 }
}
function Sw(t) {
 for (; Y !== null; ) {
  var e = Y;
  if (e.flags & 8772) {
   var n = e.alternate;
   try {
    if (e.flags & 8772)
     switch (e.tag) {
      case 0:
      case 11:
      case 15:
       Pt || Hd(5, e);
       break;
      case 1:
       var r = e.stateNode;
       if (e.flags & 4 && !Pt)
        if (n === null) r.componentDidMount();
        else {
         var i = e.elementType === e.type ? n.memoizedProps : Dn(e.type, n.memoizedProps);
         r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate);
        }
       var o = e.updateQueue;
       o !== null && lw(e, o, r);
       break;
      case 3:
       var s = e.updateQueue;
       if (s !== null) {
        if (((n = null), e.child !== null))
         switch (e.child.tag) {
          case 5:
           n = e.child.stateNode;
           break;
          case 1:
           n = e.child.stateNode;
         }
        lw(e, s, n);
       }
       break;
      case 5:
       var a = e.stateNode;
       if (n === null && e.flags & 4) {
        n = a;
        var l = e.memoizedProps;
        switch (e.type) {
         case "button":
         case "input":
         case "select":
         case "textarea":
          l.autoFocus && n.focus();
          break;
         case "img":
          l.src && (n.src = l.src);
        }
       }
       break;
      case 6:
       break;
      case 4:
       break;
      case 12:
       break;
      case 13:
       if (e.memoizedState === null) {
        var u = e.alternate;
        if (u !== null) {
         var h = u.memoizedState;
         if (h !== null) {
          var p = h.dehydrated;
          p !== null && il(p);
         }
        }
       }
       break;
      case 19:
      case 17:
      case 21:
      case 22:
      case 23:
      case 25:
       break;
      default:
       throw Error(H(163));
     }
    Pt || (e.flags & 512 && Hp(e));
   } catch (m) {
    He(e, e.return, m);
   }
  }
  if (e === t) {
   Y = null;
   break;
  }
  if (((n = e.sibling), n !== null)) {
   (n.return = e.return), (Y = n);
   break;
  }
  Y = e.return;
 }
}
function Aw(t) {
 for (; Y !== null; ) {
  var e = Y;
  if (e === t) {
   Y = null;
   break;
  }
  var n = e.sibling;
  if (n !== null) {
   (n.return = e.return), (Y = n);
   break;
  }
  Y = e.return;
 }
}
function Cw(t) {
 for (; Y !== null; ) {
  var e = Y;
  try {
   switch (e.tag) {
    case 0:
    case 11:
    case 15:
     var n = e.return;
     try {
      Hd(4, e);
     } catch (l) {
      He(e, n, l);
     }
     break;
    case 1:
     var r = e.stateNode;
     if (typeof r.componentDidMount == "function") {
      var i = e.return;
      try {
       r.componentDidMount();
      } catch (l) {
       He(e, i, l);
      }
     }
     var o = e.return;
     try {
      Hp(e);
     } catch (l) {
      He(e, o, l);
     }
     break;
    case 5:
     var s = e.return;
     try {
      Hp(e);
     } catch (l) {
      He(e, s, l);
     }
   }
  } catch (l) {
   He(e, e.return, l);
  }
  if (e === t) {
   Y = null;
   break;
  }
  var a = e.sibling;
  if (a !== null) {
   (a.return = e.return), (Y = a);
   break;
  }
  Y = e.return;
 }
}
var p2 = Math.ceil,
 Yc = Lr.ReactCurrentDispatcher,
 Rg = Lr.ReactCurrentOwner,
 In = Lr.ReactCurrentBatchConfig,
 pe = 0,
 ut = null,
 et = null,
 gt = 0,
 an = 0,
 ns = bi(0),
 ot = 0,
 ml = null,
 co = 0,
 qd = 0,
 Pg = 0,
 Ga = null,
 Qt = null,
 kg = 0,
 As = 1 / 0,
 gr = null,
 Qc = !1,
 zp = null,
 yi = null,
 Bu = !1,
 si = null,
 Xc = 0,
 za = 0,
 Wp = null,
 gc = -1,
 yc = 0;
function $t() {
 return pe & 6 ? Ye() : gc !== -1 ? gc : (gc = Ye());
}
function vi(t) {
 return t.mode & 1
  ? pe & 2 && gt !== 0
    ? gt & -gt
    : Xx.transition !== null
      ? (yc === 0 && (yc = QI()), yc)
      : ((t = Ie), t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : rS(t.type))), t)
  : 1;
}
function On(t, e, n, r) {
 if (50 < za) throw ((za = 0), (Wp = null), Error(H(185)));
 Ml(t, n, r),
  (!(pe & 2) || t !== ut) &&
   (t === ut && (!(pe & 2) && (qd |= n), ot === 4 && jr(t, gt)),
   tn(t, r),
   n === 1 && pe === 0 && !(e.mode & 1) && ((As = Ye() + 500), Fd && Ni()));
}
function tn(t, e) {
 var n = t.callbackNode;
 XN(t, e);
 var r = Dc(t, t === ut ? gt : 0);
 if (r === 0) n !== null && L_(n), (t.callbackNode = null), (t.callbackPriority = 0);
 else if (((e = r & -r), t.callbackPriority !== e)) {
  if ((n != null && L_(n), e === 1))
   t.tag === 0 ? Qx(Rw.bind(null, t)) : TS(Rw.bind(null, t)),
    Wx(function () {
     !(pe & 6) && Ni();
    }),
    (n = null);
  else {
   switch (XI(r)) {
    case 1:
     n = tg;
     break;
    case 4:
     n = JI;
     break;
    case 16:
     n = Mc;
     break;
    case 536870912:
     n = YI;
     break;
    default:
     n = Mc;
   }
   n = wA(n, hA.bind(null, t));
  }
  (t.callbackPriority = e), (t.callbackNode = n);
 }
}
function hA(t, e) {
 if (((gc = -1), (yc = 0), pe & 6)) throw Error(H(327));
 var n = t.callbackNode;
 if (ds() && t.callbackNode !== n) return null;
 var r = Dc(t, t === ut ? gt : 0);
 if (r === 0) return null;
 if (r & 30 || r & t.expiredLanes || e) e = jc(t, r);
 else {
  e = r;
  var i = pe;
  pe |= 2;
  var o = mA();
  (ut !== t || gt !== e) && ((gr = null), (As = Ye() + 500), no(t, e));
  do
   try {
    y2();
    break;
   } catch (a) {
    pA(t, a);
   }
  while (!0);
  pg(), (Yc.current = o), (pe = i), et !== null ? (e = 0) : ((ut = null), (gt = 0), (e = ot));
 }
 if (e !== 0) {
  if ((e === 2 && ((i = _p(t)), i !== 0 && ((r = i), (e = Kp(t, i)))), e === 1))
   throw ((n = ml), no(t, 0), jr(t, r), tn(t, Ye()), n);
  if (e === 6) jr(t, r);
  else {
   if (
    ((i = t.current.alternate),
    !(r & 30) && !m2(i) && ((e = jc(t, r)), e === 2 && ((o = _p(t)), o !== 0 && ((r = o), (e = Kp(t, o)))), e === 1))
   )
    throw ((n = ml), no(t, 0), jr(t, r), tn(t, Ye()), n);
   switch (((t.finishedWork = i), (t.finishedLanes = r), e)) {
    case 0:
    case 1:
     throw Error(H(345));
    case 2:
     Ki(t, Qt, gr);
     break;
    case 3:
     if ((jr(t, r), (r & 130023424) === r && ((e = kg + 500 - Ye()), 10 < e))) {
      if (Dc(t, 0) !== 0) break;
      if (((i = t.suspendedLanes), (i & r) !== r)) {
       $t(), (t.pingedLanes |= t.suspendedLanes & i);
       break;
      }
      t.timeoutHandle = Rp(Ki.bind(null, t, Qt, gr), e);
      break;
     }
     Ki(t, Qt, gr);
     break;
    case 4:
     if ((jr(t, r), (r & 4194240) === r)) break;
     for (e = t.eventTimes, i = -1; 0 < r; ) {
      var s = 31 - Un(r);
      (o = 1 << s), (s = e[s]), s > i && (i = s), (r &= ~o);
     }
     if (
      ((r = i),
      (r = Ye() - r),
      (r =
       (120 > r
        ? 120
        : 480 > r
          ? 480
          : 1080 > r
            ? 1080
            : 1920 > r
              ? 1920
              : 3e3 > r
                ? 3e3
                : 4320 > r
                  ? 4320
                  : 1960 * p2(r / 1960)) - r),
      10 < r)
     ) {
      t.timeoutHandle = Rp(Ki.bind(null, t, Qt, gr), r);
      break;
     }
     Ki(t, Qt, gr);
     break;
    case 5:
     Ki(t, Qt, gr);
     break;
    default:
     throw Error(H(329));
   }
  }
 }
 return tn(t, Ye()), t.callbackNode === n ? hA.bind(null, t) : null;
}
function Kp(t, e) {
 var n = Ga;
 return (
  t.current.memoizedState.isDehydrated && (no(t, e).flags |= 256),
  (t = jc(t, e)),
  t !== 2 && ((e = Qt), (Qt = n), e !== null && Jp(e)),
  t
 );
}
function Jp(t) {
 Qt === null ? (Qt = t) : Qt.push.apply(Qt, t);
}
function m2(t) {
 for (var e = t; ; ) {
  if (e.flags & 16384) {
   var n = e.updateQueue;
   if (n !== null && ((n = n.stores), n !== null))
    for (var r = 0; r < n.length; r++) {
     var i = n[r],
      o = i.getSnapshot;
     i = i.value;
     try {
      if (!$n(o(), i)) return !1;
     } catch {
      return !1;
     }
    }
  }
  if (((n = e.child), e.subtreeFlags & 16384 && n !== null)) (n.return = e), (e = n);
  else {
   if (e === t) break;
   for (; e.sibling === null; ) {
    if (e.return === null || e.return === t) return !0;
    e = e.return;
   }
   (e.sibling.return = e.return), (e = e.sibling);
  }
 }
 return !0;
}
function jr(t, e) {
 for (e &= ~Pg, e &= ~qd, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e; ) {
  var n = 31 - Un(e),
   r = 1 << n;
  (t[n] = -1), (e &= ~r);
 }
}
function Rw(t) {
 if (pe & 6) throw Error(H(327));
 ds();
 var e = Dc(t, 0);
 if (!(e & 1)) return tn(t, Ye()), null;
 var n = jc(t, e);
 if (t.tag !== 0 && n === 2) {
  var r = _p(t);
  r !== 0 && ((e = r), (n = Kp(t, r)));
 }
 if (n === 1) throw ((n = ml), no(t, 0), jr(t, e), tn(t, Ye()), n);
 if (n === 6) throw Error(H(345));
 return (t.finishedWork = t.current.alternate), (t.finishedLanes = e), Ki(t, Qt, gr), tn(t, Ye()), null;
}
function bg(t, e) {
 var n = pe;
 pe |= 1;
 try {
  return t(e);
 } finally {
  (pe = n), pe === 0 && ((As = Ye() + 500), Fd && Ni());
 }
}
function fo(t) {
 si !== null && si.tag === 0 && !(pe & 6) && ds();
 var e = pe;
 pe |= 1;
 var n = In.transition,
  r = Ie;
 try {
  if (((In.transition = null), (Ie = 1), t)) return t();
 } finally {
  (Ie = r), (In.transition = n), (pe = e), !(pe & 6) && Ni();
 }
}
function Ng() {
 (an = ns.current), xe(ns);
}
function no(t, e) {
 (t.finishedWork = null), (t.finishedLanes = 0);
 var n = t.timeoutHandle;
 if ((n !== -1 && ((t.timeoutHandle = -1), zx(n)), et !== null))
  for (n = et.return; n !== null; ) {
   var r = n;
   switch ((dg(r), r.tag)) {
    case 1:
     (r = r.type.childContextTypes), r != null && Fc();
     break;
    case 3:
     Is(), xe(Zt), xe(Mt), wg();
     break;
    case 5:
     _g(r);
     break;
    case 4:
     Is();
     break;
    case 13:
     xe(Ue);
     break;
    case 19:
     xe(Ue);
     break;
    case 10:
     mg(r.type._context);
     break;
    case 22:
    case 23:
     Ng();
   }
   n = n.return;
  }
 if (
  ((ut = t),
  (et = t = _i(t.current, null)),
  (gt = an = e),
  (ot = 0),
  (ml = null),
  (Pg = qd = co = 0),
  (Qt = Ga = null),
  ji !== null)
 ) {
  for (e = 0; e < ji.length; e++)
   if (((n = ji[e]), (r = n.interleaved), r !== null)) {
    n.interleaved = null;
    var i = r.next,
     o = n.pending;
    if (o !== null) {
     var s = o.next;
     (o.next = i), (r.next = s);
    }
    n.pending = r;
   }
  ji = null;
 }
 return t;
}
function pA(t, e) {
 do {
  var n = et;
  try {
   if ((pg(), (hc.current = Jc), Kc)) {
    for (var r = Oe.memoizedState; r !== null; ) {
     var i = r.queue;
     i !== null && (i.pending = null), (r = r.next);
    }
    Kc = !1;
   }
   if (((uo = 0), (lt = it = Oe = null), (Ha = !1), (fl = 0), (Rg.current = null), n === null || n.return === null)) {
    (ot = 1), (ml = e), (et = null);
    break;
   }
   e: {
    var o = t,
     s = n.return,
     a = n,
     l = e;
    if (((e = gt), (a.flags |= 32768), l !== null && typeof l == "object" && typeof l.then == "function")) {
     var u = l,
      h = a,
      p = h.tag;
     if (!(h.mode & 1) && (p === 0 || p === 11 || p === 15)) {
      var m = h.alternate;
      m
       ? ((h.updateQueue = m.updateQueue), (h.memoizedState = m.memoizedState), (h.lanes = m.lanes))
       : ((h.updateQueue = null), (h.memoizedState = null));
     }
     var v = pw(s);
     if (v !== null) {
      (v.flags &= -257), mw(v, s, a, o, e), v.mode & 1 && hw(o, u, e), (e = v), (l = u);
      var w = e.updateQueue;
      if (w === null) {
       var C = new Set();
       C.add(l), (e.updateQueue = C);
      } else w.add(l);
      break e;
     } else {
      if (!(e & 1)) {
       hw(o, u, e), xg();
       break e;
      }
      l = Error(H(426));
     }
    } else if (Me && a.mode & 1) {
     var A = pw(s);
     if (A !== null) {
      !(A.flags & 65536) && (A.flags |= 256), mw(A, s, a, o, e), fg(Ss(l, a));
      break e;
     }
    }
    (o = l = Ss(l, a)), ot !== 4 && (ot = 2), Ga === null ? (Ga = [o]) : Ga.push(o), (o = s);
    do {
     switch (o.tag) {
      case 3:
       (o.flags |= 65536), (e &= -e), (o.lanes |= e);
       var T = XS(o, l, e);
       aw(o, T);
       break e;
      case 1:
       a = l;
       var _ = o.type,
        E = o.stateNode;
       if (
        !(o.flags & 128) &&
        (typeof _.getDerivedStateFromError == "function" ||
         (E !== null && typeof E.componentDidCatch == "function" && (yi === null || !yi.has(E))))
       ) {
        (o.flags |= 65536), (e &= -e), (o.lanes |= e);
        var N = jS(o, a, e);
        aw(o, N);
        break e;
       }
     }
     o = o.return;
    } while (o !== null);
   }
   yA(n);
  } catch (M) {
   (e = M), et === n && n !== null && (et = n = n.return);
   continue;
  }
  break;
 } while (!0);
}
function mA() {
 var t = Yc.current;
 return (Yc.current = Jc), t === null ? Jc : t;
}
function xg() {
 (ot === 0 || ot === 3 || ot === 2) && (ot = 4), ut === null || (!(co & 268435455) && !(qd & 268435455)) || jr(ut, gt);
}
function jc(t, e) {
 var n = pe;
 pe |= 2;
 var r = mA();
 (ut !== t || gt !== e) && ((gr = null), no(t, e));
 do
  try {
   g2();
   break;
  } catch (i) {
   pA(t, i);
  }
 while (!0);
 if ((pg(), (pe = n), (Yc.current = r), et !== null)) throw Error(H(261));
 return (ut = null), (gt = 0), ot;
}
function g2() {
 for (; et !== null; ) gA(et);
}
function y2() {
 for (; et !== null && !HN(); ) gA(et);
}
function gA(t) {
 var e = _A(t.alternate, t, an);
 (t.memoizedProps = t.pendingProps), e === null ? yA(t) : (et = e), (Rg.current = null);
}
function yA(t) {
 var e = t;
 do {
  var n = e.alternate;
  if (((t = e.return), e.flags & 32768)) {
   if (((n = c2(n, e)), n !== null)) {
    (n.flags &= 32767), (et = n);
    return;
   }
   if (t !== null) (t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null);
   else {
    (ot = 6), (et = null);
    return;
   }
  } else if (((n = u2(n, e, an)), n !== null)) {
   et = n;
   return;
  }
  if (((e = e.sibling), e !== null)) {
   et = e;
   return;
  }
  et = e = t;
 } while (e !== null);
 ot === 0 && (ot = 5);
}
function Ki(t, e, n) {
 var r = Ie,
  i = In.transition;
 try {
  (In.transition = null), (Ie = 1), v2(t, e, n, r);
 } finally {
  (In.transition = i), (Ie = r);
 }
 return null;
}
function v2(t, e, n, r) {
 do ds();
 while (si !== null);
 if (pe & 6) throw Error(H(327));
 n = t.finishedWork;
 var i = t.finishedLanes;
 if (n === null) return null;
 if (((t.finishedWork = null), (t.finishedLanes = 0), n === t.current)) throw Error(H(177));
 (t.callbackNode = null), (t.callbackPriority = 0);
 var o = n.lanes | n.childLanes;
 if (
  (jN(t, o),
  t === ut && ((et = ut = null), (gt = 0)),
  (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
   Bu ||
   ((Bu = !0),
   wA(Mc, function () {
    return ds(), null;
   })),
  (o = (n.flags & 15990) !== 0),
  n.subtreeFlags & 15990 || o)
 ) {
  (o = In.transition), (In.transition = null);
  var s = Ie;
  Ie = 1;
  var a = pe;
  (pe |= 4),
   (Rg.current = null),
   f2(t, n),
   dA(n, t),
   Ox(Ap),
   (Lc = !!Sp),
   (Ap = Sp = null),
   (t.current = n),
   h2(n),
   qN(),
   (pe = a),
   (Ie = s),
   (In.transition = o);
 } else t.current = n;
 if (
  (Bu && ((Bu = !1), (si = t), (Xc = i)),
  (o = t.pendingLanes),
  o === 0 && (yi = null),
  WN(n.stateNode),
  tn(t, Ye()),
  e !== null)
 )
  for (r = t.onRecoverableError, n = 0; n < e.length; n++)
   (i = e[n]), r(i.value, { componentStack: i.stack, digest: i.digest });
 if (Qc) throw ((Qc = !1), (t = zp), (zp = null), t);
 return (
  Xc & 1 && t.tag !== 0 && ds(),
  (o = t.pendingLanes),
  o & 1 ? (t === Wp ? za++ : ((za = 0), (Wp = t))) : (za = 0),
  Ni(),
  null
 );
}
function ds() {
 if (si !== null) {
  var t = XI(Xc),
   e = In.transition,
   n = Ie;
  try {
   if (((In.transition = null), (Ie = 16 > t ? 16 : t), si === null)) var r = !1;
   else {
    if (((t = si), (si = null), (Xc = 0), pe & 6)) throw Error(H(331));
    var i = pe;
    for (pe |= 4, Y = t.current; Y !== null; ) {
     var o = Y,
      s = o.child;
     if (Y.flags & 16) {
      var a = o.deletions;
      if (a !== null) {
       for (var l = 0; l < a.length; l++) {
        var u = a[l];
        for (Y = u; Y !== null; ) {
         var h = Y;
         switch (h.tag) {
          case 0:
          case 11:
          case 15:
           qa(8, h, o);
         }
         var p = h.child;
         if (p !== null) (p.return = h), (Y = p);
         else
          for (; Y !== null; ) {
           h = Y;
           var m = h.sibling,
            v = h.return;
           if ((lA(h), h === u)) {
            Y = null;
            break;
           }
           if (m !== null) {
            (m.return = v), (Y = m);
            break;
           }
           Y = v;
          }
        }
       }
       var w = o.alternate;
       if (w !== null) {
        var C = w.child;
        if (C !== null) {
         w.child = null;
         do {
          var A = C.sibling;
          (C.sibling = null), (C = A);
         } while (C !== null);
        }
       }
       Y = o;
      }
     }
     if (o.subtreeFlags & 2064 && s !== null) (s.return = o), (Y = s);
     else
      e: for (; Y !== null; ) {
       if (((o = Y), o.flags & 2048))
        switch (o.tag) {
         case 0:
         case 11:
         case 15:
          qa(9, o, o.return);
        }
       var T = o.sibling;
       if (T !== null) {
        (T.return = o.return), (Y = T);
        break e;
       }
       Y = o.return;
      }
    }
    var _ = t.current;
    for (Y = _; Y !== null; ) {
     s = Y;
     var E = s.child;
     if (s.subtreeFlags & 2064 && E !== null) (E.return = s), (Y = E);
     else
      e: for (s = _; Y !== null; ) {
       if (((a = Y), a.flags & 2048))
        try {
         switch (a.tag) {
          case 0:
          case 11:
          case 15:
           Hd(9, a);
         }
        } catch (M) {
         He(a, a.return, M);
        }
       if (a === s) {
        Y = null;
        break e;
       }
       var N = a.sibling;
       if (N !== null) {
        (N.return = a.return), (Y = N);
        break e;
       }
       Y = a.return;
      }
    }
    if (((pe = i), Ni(), tr && typeof tr.onPostCommitFiberRoot == "function"))
     try {
      tr.onPostCommitFiberRoot(Dd, t);
     } catch {}
    r = !0;
   }
   return r;
  } finally {
   (Ie = n), (In.transition = e);
  }
 }
 return !1;
}
function Pw(t, e, n) {
 (e = Ss(n, e)), (e = XS(t, e, 1)), (t = gi(t, e, 1)), (e = $t()), t !== null && (Ml(t, 1, e), tn(t, e));
}
function He(t, e, n) {
 if (t.tag === 3) Pw(t, t, n);
 else
  for (; e !== null; ) {
   if (e.tag === 3) {
    Pw(e, t, n);
    break;
   } else if (e.tag === 1) {
    var r = e.stateNode;
    if (
     typeof e.type.getDerivedStateFromError == "function" ||
     (typeof r.componentDidCatch == "function" && (yi === null || !yi.has(r)))
    ) {
     (t = Ss(n, t)), (t = jS(e, t, 1)), (e = gi(e, t, 1)), (t = $t()), e !== null && (Ml(e, 1, t), tn(e, t));
     break;
    }
   }
   e = e.return;
  }
}
function _2(t, e, n) {
 var r = t.pingCache;
 r !== null && r.delete(e),
  (e = $t()),
  (t.pingedLanes |= t.suspendedLanes & n),
  ut === t &&
   (gt & n) === n &&
   (ot === 4 || (ot === 3 && (gt & 130023424) === gt && 500 > Ye() - kg) ? no(t, 0) : (Pg |= n)),
  tn(t, e);
}
function vA(t, e) {
 e === 0 && (t.mode & 1 ? ((e = bu), (bu <<= 1), !(bu & 130023424) && (bu = 4194304)) : (e = 1));
 var n = $t();
 (t = Pr(t, e)), t !== null && (Ml(t, e, n), tn(t, n));
}
function w2(t) {
 var e = t.memoizedState,
  n = 0;
 e !== null && (n = e.retryLane), vA(t, n);
}
function E2(t, e) {
 var n = 0;
 switch (t.tag) {
  case 13:
   var r = t.stateNode,
    i = t.memoizedState;
   i !== null && (n = i.retryLane);
   break;
  case 19:
   r = t.stateNode;
   break;
  default:
   throw Error(H(314));
 }
 r !== null && r.delete(e), vA(t, n);
}
var _A;
_A = function (t, e, n) {
 if (t !== null)
  if (t.memoizedProps !== e.pendingProps || Zt.current) jt = !0;
  else {
   if (!(t.lanes & n) && !(e.flags & 128)) return (jt = !1), l2(t, e, n);
   jt = !!(t.flags & 131072);
  }
 else (jt = !1), Me && e.flags & 1048576 && IS(e, Hc, e.index);
 switch (((e.lanes = 0), e.tag)) {
  case 2:
   var r = e.type;
   mc(t, e), (t = e.pendingProps);
   var i = ws(e, Mt.current);
   cs(e, n), (i = Tg(null, e, r, t, i, n));
   var o = Ig();
   return (
    (e.flags |= 1),
    typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0
     ? ((e.tag = 1),
       (e.memoizedState = null),
       (e.updateQueue = null),
       en(r) ? ((o = !0), Bc(e)) : (o = !1),
       (e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null),
       yg(e),
       (i.updater = $d),
       (e.stateNode = i),
       (i._reactInternals = e),
       Dp(e, r, t, n),
       (e = Up(null, e, r, !0, o, n)))
     : ((e.tag = 0), Me && o && cg(e), Bt(null, e, i, n), (e = e.child)),
    e
   );
  case 16:
   r = e.elementType;
   e: {
    switch (
     (mc(t, e),
     (t = e.pendingProps),
     (i = r._init),
     (r = i(r._payload)),
     (e.type = r),
     (i = e.tag = I2(r)),
     (t = Dn(r, t)),
     i)
    ) {
     case 0:
      e = Vp(null, e, r, t, n);
      break e;
     case 1:
      e = vw(null, e, r, t, n);
      break e;
     case 11:
      e = gw(null, e, r, t, n);
      break e;
     case 14:
      e = yw(null, e, r, Dn(r.type, t), n);
      break e;
    }
    throw Error(H(306, r, ""));
   }
   return e;
  case 0:
   return (r = e.type), (i = e.pendingProps), (i = e.elementType === r ? i : Dn(r, i)), Vp(t, e, r, i, n);
  case 1:
   return (r = e.type), (i = e.pendingProps), (i = e.elementType === r ? i : Dn(r, i)), vw(t, e, r, i, n);
  case 3:
   e: {
    if ((nA(e), t === null)) throw Error(H(387));
    (r = e.pendingProps), (o = e.memoizedState), (i = o.element), kS(t, e), zc(e, r, null, n);
    var s = e.memoizedState;
    if (((r = s.element), o.isDehydrated))
     if (
      ((o = {
       element: r,
       isDehydrated: !1,
       cache: s.cache,
       pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
       transitions: s.transitions,
      }),
      (e.updateQueue.baseState = o),
      (e.memoizedState = o),
      e.flags & 256)
     ) {
      (i = Ss(Error(H(423)), e)), (e = _w(t, e, r, n, i));
      break e;
     } else if (r !== i) {
      (i = Ss(Error(H(424)), e)), (e = _w(t, e, r, n, i));
      break e;
     } else
      for (
       ln = mi(e.stateNode.containerInfo.firstChild), dn = e, Me = !0, Vn = null, n = RS(e, null, r, n), e.child = n;
       n;

      )
       (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
    else {
     if ((Es(), r === i)) {
      e = kr(t, e, n);
      break e;
     }
     Bt(t, e, r, n);
    }
    e = e.child;
   }
   return e;
  case 5:
   return (
    bS(e),
    t === null && Np(e),
    (r = e.type),
    (i = e.pendingProps),
    (o = t !== null ? t.memoizedProps : null),
    (s = i.children),
    Cp(r, i) ? (s = null) : o !== null && Cp(r, o) && (e.flags |= 32),
    tA(t, e),
    Bt(t, e, s, n),
    e.child
   );
  case 6:
   return t === null && Np(e), null;
  case 13:
   return rA(t, e, n);
  case 4:
   return (
    vg(e, e.stateNode.containerInfo),
    (r = e.pendingProps),
    t === null ? (e.child = Ts(e, null, r, n)) : Bt(t, e, r, n),
    e.child
   );
  case 11:
   return (r = e.type), (i = e.pendingProps), (i = e.elementType === r ? i : Dn(r, i)), gw(t, e, r, i, n);
  case 7:
   return Bt(t, e, e.pendingProps, n), e.child;
  case 8:
   return Bt(t, e, e.pendingProps.children, n), e.child;
  case 12:
   return Bt(t, e, e.pendingProps.children, n), e.child;
  case 10:
   e: {
    if (
     ((r = e.type._context),
     (i = e.pendingProps),
     (o = e.memoizedProps),
     (s = i.value),
     Re(qc, r._currentValue),
     (r._currentValue = s),
     o !== null)
    )
     if ($n(o.value, s)) {
      if (o.children === i.children && !Zt.current) {
       e = kr(t, e, n);
       break e;
      }
     } else
      for (o = e.child, o !== null && (o.return = e); o !== null; ) {
       var a = o.dependencies;
       if (a !== null) {
        s = o.child;
        for (var l = a.firstContext; l !== null; ) {
         if (l.context === r) {
          if (o.tag === 1) {
           (l = Ir(-1, n & -n)), (l.tag = 2);
           var u = o.updateQueue;
           if (u !== null) {
            u = u.shared;
            var h = u.pending;
            h === null ? (l.next = l) : ((l.next = h.next), (h.next = l)), (u.pending = l);
           }
          }
          (o.lanes |= n), (l = o.alternate), l !== null && (l.lanes |= n), xp(o.return, n, e), (a.lanes |= n);
          break;
         }
         l = l.next;
        }
       } else if (o.tag === 10) s = o.type === e.type ? null : o.child;
       else if (o.tag === 18) {
        if (((s = o.return), s === null)) throw Error(H(341));
        (s.lanes |= n), (a = s.alternate), a !== null && (a.lanes |= n), xp(s, n, e), (s = o.sibling);
       } else s = o.child;
       if (s !== null) s.return = o;
       else
        for (s = o; s !== null; ) {
         if (s === e) {
          s = null;
          break;
         }
         if (((o = s.sibling), o !== null)) {
          (o.return = s.return), (s = o);
          break;
         }
         s = s.return;
        }
       o = s;
      }
    Bt(t, e, i.children, n), (e = e.child);
   }
   return e;
  case 9:
   return (
    (i = e.type),
    (r = e.pendingProps.children),
    cs(e, n),
    (i = An(i)),
    (r = r(i)),
    (e.flags |= 1),
    Bt(t, e, r, n),
    e.child
   );
  case 14:
   return (r = e.type), (i = Dn(r, e.pendingProps)), (i = Dn(r.type, i)), yw(t, e, r, i, n);
  case 15:
   return ZS(t, e, e.type, e.pendingProps, n);
  case 17:
   return (
    (r = e.type),
    (i = e.pendingProps),
    (i = e.elementType === r ? i : Dn(r, i)),
    mc(t, e),
    (e.tag = 1),
    en(r) ? ((t = !0), Bc(e)) : (t = !1),
    cs(e, n),
    QS(e, r, i),
    Dp(e, r, i, n),
    Up(null, e, r, !0, t, n)
   );
  case 19:
   return iA(t, e, n);
  case 22:
   return eA(t, e, n);
 }
 throw Error(H(156, e.tag));
};
function wA(t, e) {
 return KI(t, e);
}
function T2(t, e, n, r) {
 (this.tag = t),
  (this.key = n),
  (this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null),
  (this.index = 0),
  (this.ref = null),
  (this.pendingProps = e),
  (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
  (this.mode = r),
  (this.subtreeFlags = this.flags = 0),
  (this.deletions = null),
  (this.childLanes = this.lanes = 0),
  (this.alternate = null);
}
function Tn(t, e, n, r) {
 return new T2(t, e, n, r);
}
function Mg(t) {
 return (t = t.prototype), !(!t || !t.isReactComponent);
}
function I2(t) {
 if (typeof t == "function") return Mg(t) ? 1 : 0;
 if (t != null) {
  if (((t = t.$$typeof), t === jm)) return 11;
  if (t === Zm) return 14;
 }
 return 2;
}
function _i(t, e) {
 var n = t.alternate;
 return (
  n === null
   ? ((n = Tn(t.tag, e, t.key, t.mode)),
     (n.elementType = t.elementType),
     (n.type = t.type),
     (n.stateNode = t.stateNode),
     (n.alternate = t),
     (t.alternate = n))
   : ((n.pendingProps = e), (n.type = t.type), (n.flags = 0), (n.subtreeFlags = 0), (n.deletions = null)),
  (n.flags = t.flags & 14680064),
  (n.childLanes = t.childLanes),
  (n.lanes = t.lanes),
  (n.child = t.child),
  (n.memoizedProps = t.memoizedProps),
  (n.memoizedState = t.memoizedState),
  (n.updateQueue = t.updateQueue),
  (e = t.dependencies),
  (n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
  (n.sibling = t.sibling),
  (n.index = t.index),
  (n.ref = t.ref),
  n
 );
}
function vc(t, e, n, r, i, o) {
 var s = 2;
 if (((r = t), typeof t == "function")) Mg(t) && (s = 1);
 else if (typeof t == "string") s = 5;
 else
  e: switch (t) {
   case Wo:
    return ro(n.children, i, o, e);
   case Xm:
    (s = 8), (i |= 8);
    break;
   case ip:
    return (t = Tn(12, n, e, i | 2)), (t.elementType = ip), (t.lanes = o), t;
   case op:
    return (t = Tn(13, n, e, i)), (t.elementType = op), (t.lanes = o), t;
   case sp:
    return (t = Tn(19, n, e, i)), (t.elementType = sp), (t.lanes = o), t;
   case bI:
    return Gd(n, i, o, e);
   default:
    if (typeof t == "object" && t !== null)
     switch (t.$$typeof) {
      case PI:
       s = 10;
       break e;
      case kI:
       s = 9;
       break e;
      case jm:
       s = 11;
       break e;
      case Zm:
       s = 14;
       break e;
      case Yr:
       (s = 16), (r = null);
       break e;
     }
    throw Error(H(130, t == null ? t : typeof t, ""));
  }
 return (e = Tn(s, n, e, i)), (e.elementType = t), (e.type = r), (e.lanes = o), e;
}
function ro(t, e, n, r) {
 return (t = Tn(7, t, r, e)), (t.lanes = n), t;
}
function Gd(t, e, n, r) {
 return (t = Tn(22, t, r, e)), (t.elementType = bI), (t.lanes = n), (t.stateNode = { isHidden: !1 }), t;
}
function Rh(t, e, n) {
 return (t = Tn(6, t, null, e)), (t.lanes = n), t;
}
function Ph(t, e, n) {
 return (
  (e = Tn(4, t.children !== null ? t.children : [], t.key, e)),
  (e.lanes = n),
  (e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }),
  e
 );
}
function S2(t, e, n, r, i) {
 (this.tag = e),
  (this.containerInfo = t),
  (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
  (this.timeoutHandle = -1),
  (this.callbackNode = this.pendingContext = this.context = null),
  (this.callbackPriority = 0),
  (this.eventTimes = lh(0)),
  (this.expirationTimes = lh(-1)),
  (this.entangledLanes =
   this.finishedLanes =
   this.mutableReadLanes =
   this.expiredLanes =
   this.pingedLanes =
   this.suspendedLanes =
   this.pendingLanes =
    0),
  (this.entanglements = lh(0)),
  (this.identifierPrefix = r),
  (this.onRecoverableError = i),
  (this.mutableSourceEagerHydrationData = null);
}
function Dg(t, e, n, r, i, o, s, a, l) {
 return (
  (t = new S2(t, e, n, a, l)),
  e === 1 ? ((e = 1), o === !0 && (e |= 8)) : (e = 0),
  (o = Tn(3, null, null, e)),
  (t.current = o),
  (o.stateNode = t),
  (o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }),
  yg(o),
  t
 );
}
function A2(t, e, n) {
 var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
 return { $$typeof: zo, key: r == null ? null : "" + r, children: t, containerInfo: e, implementation: n };
}
function EA(t) {
 if (!t) return Ai;
 t = t._reactInternals;
 e: {
  if (Io(t) !== t || t.tag !== 1) throw Error(H(170));
  var e = t;
  do {
   switch (e.tag) {
    case 3:
     e = e.stateNode.context;
     break e;
    case 1:
     if (en(e.type)) {
      e = e.stateNode.__reactInternalMemoizedMergedChildContext;
      break e;
     }
   }
   e = e.return;
  } while (e !== null);
  throw Error(H(171));
 }
 if (t.tag === 1) {
  var n = t.type;
  if (en(n)) return ES(t, n, e);
 }
 return e;
}
function TA(t, e, n, r, i, o, s, a, l) {
 return (
  (t = Dg(n, r, !0, t, i, o, s, a, l)),
  (t.context = EA(null)),
  (n = t.current),
  (r = $t()),
  (i = vi(n)),
  (o = Ir(r, i)),
  (o.callback = e ?? null),
  gi(n, o, i),
  (t.current.lanes = i),
  Ml(t, i, r),
  tn(t, r),
  t
 );
}
function zd(t, e, n, r) {
 var i = e.current,
  o = $t(),
  s = vi(i);
 return (
  (n = EA(n)),
  e.context === null ? (e.context = n) : (e.pendingContext = n),
  (e = Ir(o, s)),
  (e.payload = { element: t }),
  (r = r === void 0 ? null : r),
  r !== null && (e.callback = r),
  (t = gi(i, e, s)),
  t !== null && (On(t, i, s, o), fc(t, i, s)),
  s
 );
}
function Zc(t) {
 if (((t = t.current), !t.child)) return null;
 switch (t.child.tag) {
  case 5:
   return t.child.stateNode;
  default:
   return t.child.stateNode;
 }
}
function kw(t, e) {
 if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
  var n = t.retryLane;
  t.retryLane = n !== 0 && n < e ? n : e;
 }
}
function Lg(t, e) {
 kw(t, e), (t = t.alternate) && kw(t, e);
}
function C2() {
 return null;
}
var IA =
 typeof reportError == "function"
  ? reportError
  : function (t) {
     console.error(t);
    };
function Vg(t) {
 this._internalRoot = t;
}
Wd.prototype.render = Vg.prototype.render = function (t) {
 var e = this._internalRoot;
 if (e === null) throw Error(H(409));
 zd(t, e, null, null);
};
Wd.prototype.unmount = Vg.prototype.unmount = function () {
 var t = this._internalRoot;
 if (t !== null) {
  this._internalRoot = null;
  var e = t.containerInfo;
  fo(function () {
   zd(null, t, null, null);
  }),
   (e[Rr] = null);
 }
};
function Wd(t) {
 this._internalRoot = t;
}
Wd.prototype.unstable_scheduleHydration = function (t) {
 if (t) {
  var e = eS();
  t = { blockedOn: null, target: t, priority: e };
  for (var n = 0; n < Xr.length && e !== 0 && e < Xr[n].priority; n++);
  Xr.splice(n, 0, t), n === 0 && nS(t);
 }
};
function Ug(t) {
 return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11));
}
function Kd(t) {
 return !(
  !t ||
  (t.nodeType !== 1 &&
   t.nodeType !== 9 &&
   t.nodeType !== 11 &&
   (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
 );
}
function bw() {}
function R2(t, e, n, r, i) {
 if (i) {
  if (typeof r == "function") {
   var o = r;
   r = function () {
    var u = Zc(s);
    o.call(u);
   };
  }
  var s = TA(e, r, t, 0, null, !1, !1, "", bw);
  return (t._reactRootContainer = s), (t[Rr] = s.current), al(t.nodeType === 8 ? t.parentNode : t), fo(), s;
 }
 for (; (i = t.lastChild); ) t.removeChild(i);
 if (typeof r == "function") {
  var a = r;
  r = function () {
   var u = Zc(l);
   a.call(u);
  };
 }
 var l = Dg(t, 0, !1, null, null, !1, !1, "", bw);
 return (
  (t._reactRootContainer = l),
  (t[Rr] = l.current),
  al(t.nodeType === 8 ? t.parentNode : t),
  fo(function () {
   zd(e, l, n, r);
  }),
  l
 );
}
function Jd(t, e, n, r, i) {
 var o = n._reactRootContainer;
 if (o) {
  var s = o;
  if (typeof i == "function") {
   var a = i;
   i = function () {
    var l = Zc(s);
    a.call(l);
   };
  }
  zd(e, s, t, i);
 } else s = R2(n, e, t, i, r);
 return Zc(s);
}
jI = function (t) {
 switch (t.tag) {
  case 3:
   var e = t.stateNode;
   if (e.current.memoizedState.isDehydrated) {
    var n = Pa(e.pendingLanes);
    n !== 0 && (ng(e, n | 1), tn(e, Ye()), !(pe & 6) && ((As = Ye() + 500), Ni()));
   }
   break;
  case 13:
   fo(function () {
    var r = Pr(t, 1);
    if (r !== null) {
     var i = $t();
     On(r, t, 1, i);
    }
   }),
    Lg(t, 1);
 }
};
rg = function (t) {
 if (t.tag === 13) {
  var e = Pr(t, 134217728);
  if (e !== null) {
   var n = $t();
   On(e, t, 134217728, n);
  }
  Lg(t, 134217728);
 }
};
ZI = function (t) {
 if (t.tag === 13) {
  var e = vi(t),
   n = Pr(t, e);
  if (n !== null) {
   var r = $t();
   On(n, t, e, r);
  }
  Lg(t, e);
 }
};
eS = function () {
 return Ie;
};
tS = function (t, e) {
 var n = Ie;
 try {
  return (Ie = t), e();
 } finally {
  Ie = n;
 }
};
gp = function (t, e, n) {
 switch (e) {
  case "input":
   if ((up(t, n), (e = n.name), n.type === "radio" && e != null)) {
    for (n = t; n.parentNode; ) n = n.parentNode;
    for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
     var r = n[e];
     if (r !== t && r.form === t.form) {
      var i = Od(r);
      if (!i) throw Error(H(90));
      xI(r), up(r, i);
     }
    }
   }
   break;
  case "textarea":
   DI(t, n);
   break;
  case "select":
   (e = n.value), e != null && ss(t, !!n.multiple, e, !1);
 }
};
$I = bg;
HI = fo;
var P2 = { usingClientEntryPoint: !1, Events: [Ll, Qo, Od, FI, BI, bg] },
 _a = { findFiberByHostInstance: Xi, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" },
 k2 = {
  bundleType: _a.bundleType,
  version: _a.version,
  rendererPackageName: _a.rendererPackageName,
  rendererConfig: _a.rendererConfig,
  overrideHookState: null,
  overrideHookStateDeletePath: null,
  overrideHookStateRenamePath: null,
  overrideProps: null,
  overridePropsDeletePath: null,
  overridePropsRenamePath: null,
  setErrorHandler: null,
  setSuspenseHandler: null,
  scheduleUpdate: null,
  currentDispatcherRef: Lr.ReactCurrentDispatcher,
  findHostInstanceByFiber: function (t) {
   return (t = zI(t)), t === null ? null : t.stateNode;
  },
  findFiberByHostInstance: _a.findFiberByHostInstance || C2,
  findHostInstancesForRefresh: null,
  scheduleRefresh: null,
  scheduleRoot: null,
  setRefreshHandler: null,
  getCurrentFiber: null,
  reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
 };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
 var $u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
 if (!$u.isDisabled && $u.supportsFiber)
  try {
   (Dd = $u.inject(k2)), (tr = $u);
  } catch {}
}
mn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = P2;
mn.createPortal = function (t, e) {
 var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
 if (!Ug(e)) throw Error(H(200));
 return A2(t, e, null, n);
};
mn.createRoot = function (t, e) {
 if (!Ug(t)) throw Error(H(299));
 var n = !1,
  r = "",
  i = IA;
 return (
  e != null &&
   (e.unstable_strictMode === !0 && (n = !0),
   e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
   e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
  (e = Dg(t, 1, !1, null, null, n, !1, r, i)),
  (t[Rr] = e.current),
  al(t.nodeType === 8 ? t.parentNode : t),
  new Vg(e)
 );
};
mn.findDOMNode = function (t) {
 if (t == null) return null;
 if (t.nodeType === 1) return t;
 var e = t._reactInternals;
 if (e === void 0)
  throw typeof t.render == "function" ? Error(H(188)) : ((t = Object.keys(t).join(",")), Error(H(268, t)));
 return (t = zI(e)), (t = t === null ? null : t.stateNode), t;
};
mn.flushSync = function (t) {
 return fo(t);
};
mn.hydrate = function (t, e, n) {
 if (!Kd(e)) throw Error(H(200));
 return Jd(null, t, e, !0, n);
};
mn.hydrateRoot = function (t, e, n) {
 if (!Ug(t)) throw Error(H(405));
 var r = (n != null && n.hydratedSources) || null,
  i = !1,
  o = "",
  s = IA;
 if (
  (n != null &&
   (n.unstable_strictMode === !0 && (i = !0),
   n.identifierPrefix !== void 0 && (o = n.identifierPrefix),
   n.onRecoverableError !== void 0 && (s = n.onRecoverableError)),
  (e = TA(e, null, t, 1, n ?? null, i, !1, o, s)),
  (t[Rr] = e.current),
  al(t),
  r)
 )
  for (t = 0; t < r.length; t++)
   (n = r[t]),
    (i = n._getVersion),
    (i = i(n._source)),
    e.mutableSourceEagerHydrationData == null
     ? (e.mutableSourceEagerHydrationData = [n, i])
     : e.mutableSourceEagerHydrationData.push(n, i);
 return new Wd(e);
};
mn.render = function (t, e, n) {
 if (!Kd(e)) throw Error(H(200));
 return Jd(null, t, e, !1, n);
};
mn.unmountComponentAtNode = function (t) {
 if (!Kd(t)) throw Error(H(40));
 return t._reactRootContainer
  ? (fo(function () {
     Jd(null, null, t, !1, function () {
      (t._reactRootContainer = null), (t[Rr] = null);
     });
    }),
    !0)
  : !1;
};
mn.unstable_batchedUpdates = bg;
mn.unstable_renderSubtreeIntoContainer = function (t, e, n, r) {
 if (!Kd(n)) throw Error(H(200));
 if (t == null || t._reactInternals === void 0) throw Error(H(38));
 return Jd(t, e, n, !1, r);
};
mn.version = "18.3.1-next-f1338f8080-20240426";
function SA() {
 if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
  try {
   __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(SA);
  } catch (t) {
   console.error(t);
  }
}
SA(), (SI.exports = mn);
var b2 = SI.exports,
 Nw = b2;
(np.createRoot = Nw.createRoot), (np.hydrateRoot = Nw.hydrateRoot);
const N2 = "modulepreload",
 x2 = function (t) {
  return "/" + t;
 },
 xw = {},
 Ge = function (e, n, r) {
  let i = Promise.resolve();
  if (n && n.length > 0) {
   document.getElementsByTagName("link");
   const s = document.querySelector("meta[property=csp-nonce]"),
    a = (s == null ? void 0 : s.nonce) || (s == null ? void 0 : s.getAttribute("nonce"));
   i = Promise.allSettled(
    n.map((l) => {
     if (((l = x2(l)), l in xw)) return;
     xw[l] = !0;
     const u = l.endsWith(".css"),
      h = u ? '[rel="stylesheet"]' : "";
     if (document.querySelector(`link[href="${l}"]${h}`)) return;
     const p = document.createElement("link");
     if (
      ((p.rel = u ? "stylesheet" : N2),
      u || (p.as = "script"),
      (p.crossOrigin = ""),
      (p.href = l),
      a && p.setAttribute("nonce", a),
      document.head.appendChild(p),
      u)
     )
      return new Promise((m, v) => {
       p.addEventListener("load", m), p.addEventListener("error", () => v(new Error(`Unable to preload CSS for ${l}`)));
      });
    })
   );
  }
  function o(s) {
   const a = new Event("vite:preloadError", { cancelable: !0 });
   if (((a.payload = s), window.dispatchEvent(a), !a.defaultPrevented)) throw s;
  }
  return i.then((s) => {
   for (const a of s || []) a.status === "rejected" && o(a.reason);
   return e().catch(o);
  });
 };
/**
 * @remix-run/router v1.23.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function gl() {
 return (
  (gl = Object.assign
   ? Object.assign.bind()
   : function (t) {
      for (var e = 1; e < arguments.length; e++) {
       var n = arguments[e];
       for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
      }
      return t;
     }),
  gl.apply(this, arguments)
 );
}
var ai;
(function (t) {
 (t.Pop = "POP"), (t.Push = "PUSH"), (t.Replace = "REPLACE");
})(ai || (ai = {}));
const Mw = "popstate";
function M2(t) {
 t === void 0 && (t = {});
 function e(i, o) {
  let { pathname: s = "/", search: a = "", hash: l = "" } = So(i.location.hash.substr(1));
  return (
   !s.startsWith("/") && !s.startsWith(".") && (s = "/" + s),
   Yp("", { pathname: s, search: a, hash: l }, (o.state && o.state.usr) || null, (o.state && o.state.key) || "default")
  );
 }
 function n(i, o) {
  let s = i.document.querySelector("base"),
   a = "";
  if (s && s.getAttribute("href")) {
   let l = i.location.href,
    u = l.indexOf("#");
   a = u === -1 ? l : l.slice(0, u);
  }
  return a + "#" + (typeof o == "string" ? o : ed(o));
 }
 function r(i, o) {
  Yd(
   i.pathname.charAt(0) === "/",
   "relative pathnames are not supported in hash history.push(" + JSON.stringify(o) + ")"
  );
 }
 return L2(e, n, r, t);
}
function Qe(t, e) {
 if (t === !1 || t === null || typeof t > "u") throw new Error(e);
}
function Yd(t, e) {
 if (!t) {
  typeof console < "u" && console.warn(e);
  try {
   throw new Error(e);
  } catch {}
 }
}
function D2() {
 return Math.random().toString(36).substr(2, 8);
}
function Dw(t, e) {
 return { usr: t.state, key: t.key, idx: e };
}
function Yp(t, e, n, r) {
 return (
  n === void 0 && (n = null),
  gl({ pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "" }, typeof e == "string" ? So(e) : e, {
   state: n,
   key: (e && e.key) || r || D2(),
  })
 );
}
function ed(t) {
 let { pathname: e = "/", search: n = "", hash: r = "" } = t;
 return (
  n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n),
  r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r),
  e
 );
}
function So(t) {
 let e = {};
 if (t) {
  let n = t.indexOf("#");
  n >= 0 && ((e.hash = t.substr(n)), (t = t.substr(0, n)));
  let r = t.indexOf("?");
  r >= 0 && ((e.search = t.substr(r)), (t = t.substr(0, r))), t && (e.pathname = t);
 }
 return e;
}
function L2(t, e, n, r) {
 r === void 0 && (r = {});
 let { window: i = document.defaultView, v5Compat: o = !1 } = r,
  s = i.history,
  a = ai.Pop,
  l = null,
  u = h();
 u == null && ((u = 0), s.replaceState(gl({}, s.state, { idx: u }), ""));
 function h() {
  return (s.state || { idx: null }).idx;
 }
 function p() {
  a = ai.Pop;
  let A = h(),
   T = A == null ? null : A - u;
  (u = A), l && l({ action: a, location: C.location, delta: T });
 }
 function m(A, T) {
  a = ai.Push;
  let _ = Yp(C.location, A, T);
  n && n(_, A), (u = h() + 1);
  let E = Dw(_, u),
   N = C.createHref(_);
  try {
   s.pushState(E, "", N);
  } catch (M) {
   if (M instanceof DOMException && M.name === "DataCloneError") throw M;
   i.location.assign(N);
  }
  o && l && l({ action: a, location: C.location, delta: 1 });
 }
 function v(A, T) {
  a = ai.Replace;
  let _ = Yp(C.location, A, T);
  n && n(_, A), (u = h());
  let E = Dw(_, u),
   N = C.createHref(_);
  s.replaceState(E, "", N), o && l && l({ action: a, location: C.location, delta: 0 });
 }
 function w(A) {
  let T = i.location.origin !== "null" ? i.location.origin : i.location.href,
   _ = typeof A == "string" ? A : ed(A);
  return (
   (_ = _.replace(/ $/, "%20")),
   Qe(T, "No window.location.(origin|href) available to create URL for href: " + _),
   new URL(_, T)
  );
 }
 let C = {
  get action() {
   return a;
  },
  get location() {
   return t(i, s);
  },
  listen(A) {
   if (l) throw new Error("A history only accepts one active listener");
   return (
    i.addEventListener(Mw, p),
    (l = A),
    () => {
     i.removeEventListener(Mw, p), (l = null);
    }
   );
  },
  createHref(A) {
   return e(i, A);
  },
  createURL: w,
  encodeLocation(A) {
   let T = w(A);
   return { pathname: T.pathname, search: T.search, hash: T.hash };
  },
  push: m,
  replace: v,
  go(A) {
   return s.go(A);
  },
 };
 return C;
}
var Lw;
(function (t) {
 (t.data = "data"), (t.deferred = "deferred"), (t.redirect = "redirect"), (t.error = "error");
})(Lw || (Lw = {}));
function V2(t, e, n) {
 return n === void 0 && (n = "/"), U2(t, e, n);
}
function U2(t, e, n, r) {
 let i = typeof e == "string" ? So(e) : e,
  o = Og(i.pathname || "/", n);
 if (o == null) return null;
 let s = AA(t);
 O2(s);
 let a = null;
 for (let l = 0; a == null && l < s.length; ++l) {
  let u = Q2(o);
  a = K2(s[l], u);
 }
 return a;
}
function AA(t, e, n, r) {
 e === void 0 && (e = []), n === void 0 && (n = []), r === void 0 && (r = "");
 let i = (o, s, a) => {
  let l = {
   relativePath: a === void 0 ? o.path || "" : a,
   caseSensitive: o.caseSensitive === !0,
   childrenIndex: s,
   route: o,
  };
  l.relativePath.startsWith("/") &&
   (Qe(
    l.relativePath.startsWith(r),
    'Absolute route path "' +
     l.relativePath +
     '" nested under path ' +
     ('"' + r + '" is not valid. An absolute child route path ') +
     "must start with the combined path of all its parent routes."
   ),
   (l.relativePath = l.relativePath.slice(r.length)));
  let u = wi([r, l.relativePath]),
   h = n.concat(l);
  o.children &&
   o.children.length > 0 &&
   (Qe(
    o.index !== !0,
    "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')
   ),
   AA(o.children, e, h, u)),
   !(o.path == null && !o.index) && e.push({ path: u, score: z2(u, o.index), routesMeta: h });
 };
 return (
  t.forEach((o, s) => {
   var a;
   if (o.path === "" || !((a = o.path) != null && a.includes("?"))) i(o, s);
   else for (let l of CA(o.path)) i(o, s, l);
  }),
  e
 );
}
function CA(t) {
 let e = t.split("/");
 if (e.length === 0) return [];
 let [n, ...r] = e,
  i = n.endsWith("?"),
  o = n.replace(/\?$/, "");
 if (r.length === 0) return i ? [o, ""] : [o];
 let s = CA(r.join("/")),
  a = [];
 return (
  a.push(...s.map((l) => (l === "" ? o : [o, l].join("/")))),
  i && a.push(...s),
  a.map((l) => (t.startsWith("/") && l === "" ? "/" : l))
 );
}
function O2(t) {
 t.sort((e, n) =>
  e.score !== n.score
   ? n.score - e.score
   : W2(
      e.routesMeta.map((r) => r.childrenIndex),
      n.routesMeta.map((r) => r.childrenIndex)
     )
 );
}
const F2 = /^:[\w-]+$/,
 B2 = 3,
 $2 = 2,
 H2 = 1,
 q2 = 10,
 G2 = -2,
 Vw = (t) => t === "*";
function z2(t, e) {
 let n = t.split("/"),
  r = n.length;
 return (
  n.some(Vw) && (r += G2),
  e && (r += $2),
  n.filter((i) => !Vw(i)).reduce((i, o) => i + (F2.test(o) ? B2 : o === "" ? H2 : q2), r)
 );
}
function W2(t, e) {
 return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i]) ? t[t.length - 1] - e[e.length - 1] : 0;
}
function K2(t, e, n) {
 let { routesMeta: r } = t,
  i = {},
  o = "/",
  s = [];
 for (let a = 0; a < r.length; ++a) {
  let l = r[a],
   u = a === r.length - 1,
   h = o === "/" ? e : e.slice(o.length) || "/",
   p = J2({ path: l.relativePath, caseSensitive: l.caseSensitive, end: u }, h),
   m = l.route;
  if (!p) return null;
  Object.assign(i, p.params),
   s.push({ params: i, pathname: wi([o, p.pathname]), pathnameBase: tM(wi([o, p.pathnameBase])), route: m }),
   p.pathnameBase !== "/" && (o = wi([o, p.pathnameBase]));
 }
 return s;
}
function J2(t, e) {
 typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 });
 let [n, r] = Y2(t.path, t.caseSensitive, t.end),
  i = e.match(n);
 if (!i) return null;
 let o = i[0],
  s = o.replace(/(.)\/+$/, "$1"),
  a = i.slice(1);
 return {
  params: r.reduce((u, h, p) => {
   let { paramName: m, isOptional: v } = h;
   if (m === "*") {
    let C = a[p] || "";
    s = o.slice(0, o.length - C.length).replace(/(.)\/+$/, "$1");
   }
   const w = a[p];
   return v && !w ? (u[m] = void 0) : (u[m] = (w || "").replace(/%2F/g, "/")), u;
  }, {}),
  pathname: o,
  pathnameBase: s,
  pattern: t,
 };
}
function Y2(t, e, n) {
 e === void 0 && (e = !1),
  n === void 0 && (n = !0),
  Yd(
   t === "*" || !t.endsWith("*") || t.endsWith("/*"),
   'Route path "' +
    t +
    '" will be treated as if it were ' +
    ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') +
    "always follow a `/` in the pattern. To get rid of this warning, " +
    ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')
  );
 let r = [],
  i =
   "^" +
   t
    .replace(/\/*\*?$/, "")
    .replace(/^\/*/, "/")
    .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
    .replace(
     /\/:([\w-]+)(\?)?/g,
     (s, a, l) => (r.push({ paramName: a, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")
    );
 return (
  t.endsWith("*")
   ? (r.push({ paramName: "*" }), (i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
   : n
     ? (i += "\\/*$")
     : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"),
  [new RegExp(i, e ? void 0 : "i"), r]
 );
}
function Q2(t) {
 try {
  return t
   .split("/")
   .map((e) => decodeURIComponent(e).replace(/\//g, "%2F"))
   .join("/");
 } catch (e) {
  return (
   Yd(
    !1,
    'The URL path "' +
     t +
     '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
     ("encoding (" + e + ").")
   ),
   t
  );
 }
}
function Og(t, e) {
 if (e === "/") return t;
 if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
 let n = e.endsWith("/") ? e.length - 1 : e.length,
  r = t.charAt(n);
 return r && r !== "/" ? null : t.slice(n) || "/";
}
const X2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
 j2 = (t) => X2.test(t);
function Z2(t, e) {
 e === void 0 && (e = "/");
 let { pathname: n, search: r = "", hash: i = "" } = typeof t == "string" ? So(t) : t,
  o;
 if (n)
  if (j2(n)) o = n;
  else {
   if (n.includes("//")) {
    let s = n;
    (n = n.replace(/\/\/+/g, "/")),
     Yd(!1, "Pathnames cannot have embedded double slashes - normalizing " + (s + " -> " + n));
   }
   n.startsWith("/") ? (o = Uw(n.substring(1), "/")) : (o = Uw(n, e));
  }
 else o = e;
 return { pathname: o, search: nM(r), hash: rM(i) };
}
function Uw(t, e) {
 let n = e.replace(/\/+$/, "").split("/");
 return (
  t.split("/").forEach((i) => {
   i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
  }),
  n.length > 1 ? n.join("/") : "/"
 );
}
function kh(t, e, n, r) {
 return (
  "Cannot include a '" +
  t +
  "' character in a manually specified " +
  ("`to." + e + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") +
  ("`to." + n + "` field. Alternatively you may provide the full path as ") +
  'a string in <Link to="..."> and the router will parse it for you.'
 );
}
function eM(t) {
 return t.filter((e, n) => n === 0 || (e.route.path && e.route.path.length > 0));
}
function Fg(t, e) {
 let n = eM(t);
 return e ? n.map((r, i) => (i === n.length - 1 ? r.pathname : r.pathnameBase)) : n.map((r) => r.pathnameBase);
}
function Bg(t, e, n, r) {
 r === void 0 && (r = !1);
 let i;
 typeof t == "string"
  ? (i = So(t))
  : ((i = gl({}, t)),
    Qe(!i.pathname || !i.pathname.includes("?"), kh("?", "pathname", "search", i)),
    Qe(!i.pathname || !i.pathname.includes("#"), kh("#", "pathname", "hash", i)),
    Qe(!i.search || !i.search.includes("#"), kh("#", "search", "hash", i)));
 let o = t === "" || i.pathname === "",
  s = o ? "/" : i.pathname,
  a;
 if (s == null) a = n;
 else {
  let p = e.length - 1;
  if (!r && s.startsWith("..")) {
   let m = s.split("/");
   for (; m[0] === ".."; ) m.shift(), (p -= 1);
   i.pathname = m.join("/");
  }
  a = p >= 0 ? e[p] : "/";
 }
 let l = Z2(i, a),
  u = s && s !== "/" && s.endsWith("/"),
  h = (o || s === ".") && n.endsWith("/");
 return !l.pathname.endsWith("/") && (u || h) && (l.pathname += "/"), l;
}
const wi = (t) => t.join("/").replace(/\/\/+/g, "/"),
 tM = (t) => t.replace(/\/+$/, "").replace(/^\/*/, "/"),
 nM = (t) => (!t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t),
 rM = (t) => (!t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t);
function iM(t) {
 return (
  t != null &&
  typeof t.status == "number" &&
  typeof t.statusText == "string" &&
  typeof t.internal == "boolean" &&
  "data" in t
 );
}
const RA = ["post", "put", "patch", "delete"];
new Set(RA);
const oM = ["get", ...RA];
new Set(oM);
/**
 * React Router v6.30.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function yl() {
 return (
  (yl = Object.assign
   ? Object.assign.bind()
   : function (t) {
      for (var e = 1; e < arguments.length; e++) {
       var n = arguments[e];
       for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
      }
      return t;
     }),
  yl.apply(this, arguments)
 );
}
const $g = W.createContext(null),
 sM = W.createContext(null),
 xi = W.createContext(null),
 Qd = W.createContext(null),
 Vr = W.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
 PA = W.createContext(null);
function aM(t, e) {
 let { relative: n } = e === void 0 ? {} : e;
 Fs() || Qe(!1);
 let { basename: r, navigator: i } = W.useContext(xi),
  { hash: o, pathname: s, search: a } = bA(t, { relative: n }),
  l = s;
 return r !== "/" && (l = s === "/" ? r : wi([r, s])), i.createHref({ pathname: l, search: a, hash: o });
}
function Fs() {
 return W.useContext(Qd) != null;
}
function Ao() {
 return Fs() || Qe(!1), W.useContext(Qd).location;
}
function kA(t) {
 W.useContext(xi).static || W.useLayoutEffect(t);
}
function Xd() {
 let { isDataRoute: t } = W.useContext(Vr);
 return t ? TM() : lM();
}
function lM() {
 Fs() || Qe(!1);
 let t = W.useContext($g),
  { basename: e, future: n, navigator: r } = W.useContext(xi),
  { matches: i } = W.useContext(Vr),
  { pathname: o } = Ao(),
  s = JSON.stringify(Fg(i, n.v7_relativeSplatPath)),
  a = W.useRef(!1);
 return (
  kA(() => {
   a.current = !0;
  }),
  W.useCallback(
   function (u, h) {
    if ((h === void 0 && (h = {}), !a.current)) return;
    if (typeof u == "number") {
     r.go(u);
     return;
    }
    let p = Bg(u, JSON.parse(s), o, h.relative === "path");
    t == null && e !== "/" && (p.pathname = p.pathname === "/" ? e : wi([e, p.pathname])),
     (h.replace ? r.replace : r.push)(p, h.state, h);
   },
   [e, r, s, o, t]
  )
 );
}
const uM = W.createContext(null);
function cM(t) {
 let e = W.useContext(Vr).outlet;
 return e && W.createElement(uM.Provider, { value: t }, e);
}
function bA(t, e) {
 let { relative: n } = e === void 0 ? {} : e,
  { future: r } = W.useContext(xi),
  { matches: i } = W.useContext(Vr),
  { pathname: o } = Ao(),
  s = JSON.stringify(Fg(i, r.v7_relativeSplatPath));
 return W.useMemo(() => Bg(t, JSON.parse(s), o, n === "path"), [t, s, o, n]);
}
function dM(t, e) {
 return fM(t, e);
}
function fM(t, e, n, r) {
 Fs() || Qe(!1);
 let { navigator: i } = W.useContext(xi),
  { matches: o } = W.useContext(Vr),
  s = o[o.length - 1],
  a = s ? s.params : {};
 s && s.pathname;
 let l = s ? s.pathnameBase : "/";
 s && s.route;
 let u = Ao(),
  h;
 if (e) {
  var p;
  let A = typeof e == "string" ? So(e) : e;
  l === "/" || ((p = A.pathname) != null && p.startsWith(l)) || Qe(!1), (h = A);
 } else h = u;
 let m = h.pathname || "/",
  v = m;
 if (l !== "/") {
  let A = l.replace(/^\//, "").split("/");
  v = "/" + m.replace(/^\//, "").split("/").slice(A.length).join("/");
 }
 let w = V2(t, { pathname: v }),
  C = yM(
   w &&
    w.map((A) =>
     Object.assign({}, A, {
      params: Object.assign({}, a, A.params),
      pathname: wi([l, i.encodeLocation ? i.encodeLocation(A.pathname).pathname : A.pathname]),
      pathnameBase:
       A.pathnameBase === "/"
        ? l
        : wi([l, i.encodeLocation ? i.encodeLocation(A.pathnameBase).pathname : A.pathnameBase]),
     })
    ),
   o,
   n,
   r
  );
 return e && C
  ? W.createElement(
     Qd.Provider,
     {
      value: {
       location: yl({ pathname: "/", search: "", hash: "", state: null, key: "default" }, h),
       navigationType: ai.Pop,
      },
     },
     C
    )
  : C;
}
function hM() {
 let t = EM(),
  e = iM(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t),
  n = t instanceof Error ? t.stack : null,
  i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" };
 return W.createElement(
  W.Fragment,
  null,
  W.createElement("h2", null, "Unexpected Application Error!"),
  W.createElement("h3", { style: { fontStyle: "italic" } }, e),
  n ? W.createElement("pre", { style: i }, n) : null,
  null
 );
}
const pM = W.createElement(hM, null);
class mM extends W.Component {
 constructor(e) {
  super(e), (this.state = { location: e.location, revalidation: e.revalidation, error: e.error });
 }
 static getDerivedStateFromError(e) {
  return { error: e };
 }
 static getDerivedStateFromProps(e, n) {
  return n.location !== e.location || (n.revalidation !== "idle" && e.revalidation === "idle")
   ? { error: e.error, location: e.location, revalidation: e.revalidation }
   : {
      error: e.error !== void 0 ? e.error : n.error,
      location: n.location,
      revalidation: e.revalidation || n.revalidation,
     };
 }
 componentDidCatch(e, n) {
  console.error("React Router caught the following error during render", e, n);
 }
 render() {
  return this.state.error !== void 0
   ? W.createElement(
      Vr.Provider,
      { value: this.props.routeContext },
      W.createElement(PA.Provider, { value: this.state.error, children: this.props.component })
     )
   : this.props.children;
 }
}
function gM(t) {
 let { routeContext: e, match: n, children: r } = t,
  i = W.useContext($g);
 return (
  i &&
   i.static &&
   i.staticContext &&
   (n.route.errorElement || n.route.ErrorBoundary) &&
   (i.staticContext._deepestRenderedBoundaryId = n.route.id),
  W.createElement(Vr.Provider, { value: e }, r)
 );
}
function yM(t, e, n, r) {
 var i;
 if ((e === void 0 && (e = []), n === void 0 && (n = null), r === void 0 && (r = null), t == null)) {
  var o;
  if (!n) return null;
  if (n.errors) t = n.matches;
  else if ((o = r) != null && o.v7_partialHydration && e.length === 0 && !n.initialized && n.matches.length > 0)
   t = n.matches;
  else return null;
 }
 let s = t,
  a = (i = n) == null ? void 0 : i.errors;
 if (a != null) {
  let h = s.findIndex((p) => p.route.id && (a == null ? void 0 : a[p.route.id]) !== void 0);
  h >= 0 || Qe(!1), (s = s.slice(0, Math.min(s.length, h + 1)));
 }
 let l = !1,
  u = -1;
 if (n && r && r.v7_partialHydration)
  for (let h = 0; h < s.length; h++) {
   let p = s[h];
   if (((p.route.HydrateFallback || p.route.hydrateFallbackElement) && (u = h), p.route.id)) {
    let { loaderData: m, errors: v } = n,
     w = p.route.loader && m[p.route.id] === void 0 && (!v || v[p.route.id] === void 0);
    if (p.route.lazy || w) {
     (l = !0), u >= 0 ? (s = s.slice(0, u + 1)) : (s = [s[0]]);
     break;
    }
   }
  }
 return s.reduceRight((h, p, m) => {
  let v,
   w = !1,
   C = null,
   A = null;
  n &&
   ((v = a && p.route.id ? a[p.route.id] : void 0),
   (C = p.route.errorElement || pM),
   l &&
    (u < 0 && m === 0
     ? (IM("route-fallback"), (w = !0), (A = null))
     : u === m && ((w = !0), (A = p.route.hydrateFallbackElement || null))));
  let T = e.concat(s.slice(0, m + 1)),
   _ = () => {
    let E;
    return (
     v
      ? (E = C)
      : w
        ? (E = A)
        : p.route.Component
          ? (E = W.createElement(p.route.Component, null))
          : p.route.element
            ? (E = p.route.element)
            : (E = h),
     W.createElement(gM, { match: p, routeContext: { outlet: h, matches: T, isDataRoute: n != null }, children: E })
    );
   };
  return n && (p.route.ErrorBoundary || p.route.errorElement || m === 0)
   ? W.createElement(mM, {
      location: n.location,
      revalidation: n.revalidation,
      component: C,
      error: v,
      children: _(),
      routeContext: { outlet: null, matches: T, isDataRoute: !0 },
     })
   : _();
 }, null);
}
var NA = (function (t) {
  return (t.UseBlocker = "useBlocker"), (t.UseRevalidator = "useRevalidator"), (t.UseNavigateStable = "useNavigate"), t;
 })(NA || {}),
 xA = (function (t) {
  return (
   (t.UseBlocker = "useBlocker"),
   (t.UseLoaderData = "useLoaderData"),
   (t.UseActionData = "useActionData"),
   (t.UseRouteError = "useRouteError"),
   (t.UseNavigation = "useNavigation"),
   (t.UseRouteLoaderData = "useRouteLoaderData"),
   (t.UseMatches = "useMatches"),
   (t.UseRevalidator = "useRevalidator"),
   (t.UseNavigateStable = "useNavigate"),
   (t.UseRouteId = "useRouteId"),
   t
  );
 })(xA || {});
function vM(t) {
 let e = W.useContext($g);
 return e || Qe(!1), e;
}
function _M(t) {
 let e = W.useContext(sM);
 return e || Qe(!1), e;
}
function wM(t) {
 let e = W.useContext(Vr);
 return e || Qe(!1), e;
}
function MA(t) {
 let e = wM(),
  n = e.matches[e.matches.length - 1];
 return n.route.id || Qe(!1), n.route.id;
}
function EM() {
 var t;
 let e = W.useContext(PA),
  n = _M(),
  r = MA();
 return e !== void 0 ? e : (t = n.errors) == null ? void 0 : t[r];
}
function TM() {
 let { router: t } = vM(NA.UseNavigateStable),
  e = MA(xA.UseNavigateStable),
  n = W.useRef(!1);
 return (
  kA(() => {
   n.current = !0;
  }),
  W.useCallback(
   function (i, o) {
    o === void 0 && (o = {}),
     n.current && (typeof i == "number" ? t.navigate(i) : t.navigate(i, yl({ fromRouteId: e }, o)));
   },
   [t, e]
  )
 );
}
const Ow = {};
function IM(t, e, n) {
 Ow[t] || (Ow[t] = !0);
}
function SM(t, e) {
 t == null || t.v7_startTransition, t == null || t.v7_relativeSplatPath;
}
function Jn(t) {
 let { to: e, replace: n, state: r, relative: i } = t;
 Fs() || Qe(!1);
 let { future: o, static: s } = W.useContext(xi),
  { matches: a } = W.useContext(Vr),
  { pathname: l } = Ao(),
  u = Xd(),
  h = Bg(e, Fg(a, o.v7_relativeSplatPath), l, i === "path"),
  p = JSON.stringify(h);
 return W.useEffect(() => u(JSON.parse(p), { replace: n, state: r, relative: i }), [u, p, i, n, r]), null;
}
function DA(t) {
 return cM(t.context);
}
function Te(t) {
 Qe(!1);
}
function AM(t) {
 let {
  basename: e = "/",
  children: n = null,
  location: r,
  navigationType: i = ai.Pop,
  navigator: o,
  static: s = !1,
  future: a,
 } = t;
 Fs() && Qe(!1);
 let l = e.replace(/^\/*/, "/"),
  u = W.useMemo(
   () => ({ basename: l, navigator: o, static: s, future: yl({ v7_relativeSplatPath: !1 }, a) }),
   [l, a, o, s]
  );
 typeof r == "string" && (r = So(r));
 let { pathname: h = "/", search: p = "", hash: m = "", state: v = null, key: w = "default" } = r,
  C = W.useMemo(() => {
   let A = Og(h, l);
   return A == null ? null : { location: { pathname: A, search: p, hash: m, state: v, key: w }, navigationType: i };
  }, [l, h, p, m, v, w, i]);
 return C == null
  ? null
  : W.createElement(xi.Provider, { value: u }, W.createElement(Qd.Provider, { children: n, value: C }));
}
function CM(t) {
 let { children: e, location: n } = t;
 return dM(Qp(e), n);
}
new Promise(() => {});
function Qp(t, e) {
 e === void 0 && (e = []);
 let n = [];
 return (
  W.Children.forEach(t, (r, i) => {
   if (!W.isValidElement(r)) return;
   let o = [...e, i];
   if (r.type === W.Fragment) {
    n.push.apply(n, Qp(r.props.children, o));
    return;
   }
   r.type !== Te && Qe(!1), !r.props.index || !r.props.children || Qe(!1);
   let s = {
    id: r.props.id || o.join("-"),
    caseSensitive: r.props.caseSensitive,
    element: r.props.element,
    Component: r.props.Component,
    index: r.props.index,
    path: r.props.path,
    loader: r.props.loader,
    action: r.props.action,
    errorElement: r.props.errorElement,
    ErrorBoundary: r.props.ErrorBoundary,
    hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
    shouldRevalidate: r.props.shouldRevalidate,
    handle: r.props.handle,
    lazy: r.props.lazy,
   };
   r.props.children && (s.children = Qp(r.props.children, o)), n.push(s);
  }),
  n
 );
}
/**
 * React Router DOM v6.30.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Xp() {
 return (
  (Xp = Object.assign
   ? Object.assign.bind()
   : function (t) {
      for (var e = 1; e < arguments.length; e++) {
       var n = arguments[e];
       for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
      }
      return t;
     }),
  Xp.apply(this, arguments)
 );
}
function RM(t, e) {
 if (t == null) return {};
 var n = {},
  r = Object.keys(t),
  i,
  o;
 for (o = 0; o < r.length; o++) (i = r[o]), !(e.indexOf(i) >= 0) && (n[i] = t[i]);
 return n;
}
function PM(t) {
 return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
}
function kM(t, e) {
 return t.button === 0 && (!e || e === "_self") && !PM(t);
}
const bM = [
  "onClick",
  "relative",
  "reloadDocument",
  "replace",
  "state",
  "target",
  "to",
  "preventScrollReset",
  "viewTransition",
 ],
 NM = "6";
try {
 window.__reactRouterVersion = NM;
} catch {}
const xM = "startTransition",
 Fw = _N[xM];
function MM(t) {
 let { basename: e, children: n, future: r, window: i } = t,
  o = W.useRef();
 o.current == null && (o.current = M2({ window: i, v5Compat: !0 }));
 let s = o.current,
  [a, l] = W.useState({ action: s.action, location: s.location }),
  { v7_startTransition: u } = r || {},
  h = W.useCallback(
   (p) => {
    u && Fw ? Fw(() => l(p)) : l(p);
   },
   [l, u]
  );
 return (
  W.useLayoutEffect(() => s.listen(h), [s, h]),
  W.useEffect(() => SM(r), [r]),
  W.createElement(AM, {
   basename: e,
   children: n,
   location: a.location,
   navigationType: a.action,
   navigator: s,
   future: r,
  })
 );
}
const DM = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
 LM = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
 rt = W.forwardRef(function (e, n) {
  let {
    onClick: r,
    relative: i,
    reloadDocument: o,
    replace: s,
    state: a,
    target: l,
    to: u,
    preventScrollReset: h,
    viewTransition: p,
   } = e,
   m = RM(e, bM),
   { basename: v } = W.useContext(xi),
   w,
   C = !1;
  if (typeof u == "string" && LM.test(u) && ((w = u), DM))
   try {
    let E = new URL(window.location.href),
     N = u.startsWith("//") ? new URL(E.protocol + u) : new URL(u),
     M = Og(N.pathname, v);
    N.origin === E.origin && M != null ? (u = M + N.search + N.hash) : (C = !0);
   } catch {}
  let A = aM(u, { relative: i }),
   T = VM(u, { replace: s, state: a, target: l, preventScrollReset: h, relative: i, viewTransition: p });
  function _(E) {
   r && r(E), E.defaultPrevented || T(E);
  }
  return W.createElement("a", Xp({}, m, { href: w || A, onClick: C || o ? r : _, ref: n, target: l }));
 });
var Bw;
(function (t) {
 (t.UseScrollRestoration = "useScrollRestoration"),
  (t.UseSubmit = "useSubmit"),
  (t.UseSubmitFetcher = "useSubmitFetcher"),
  (t.UseFetcher = "useFetcher"),
  (t.useViewTransitionState = "useViewTransitionState");
})(Bw || (Bw = {}));
var $w;
(function (t) {
 (t.UseFetcher = "useFetcher"), (t.UseFetchers = "useFetchers"), (t.UseScrollRestoration = "useScrollRestoration");
})($w || ($w = {}));
function VM(t, e) {
 let { target: n, replace: r, state: i, preventScrollReset: o, relative: s, viewTransition: a } = e === void 0 ? {} : e,
  l = Xd(),
  u = Ao(),
  h = bA(t, { relative: s });
 return W.useCallback(
  (p) => {
   if (kM(p, n)) {
    p.preventDefault();
    let m = r !== void 0 ? r : ed(u) === ed(h);
    l(t, { replace: m, state: i, preventScrollReset: o, relative: s, viewTransition: a });
   }
  },
  [u, l, h, r, i, n, t, o, s, a]
 );
}
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var UM = {
 xmlns: "http://www.w3.org/2000/svg",
 width: 24,
 height: 24,
 viewBox: "0 0 24 24",
 fill: "none",
 stroke: "currentColor",
 strokeWidth: 2,
 strokeLinecap: "round",
 strokeLinejoin: "round",
};
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const OM = (t) =>
  t
   .replace(/([a-z0-9])([A-Z])/g, "$1-$2")
   .toLowerCase()
   .trim(),
 nt = (t, e) => {
  const n = W.forwardRef(
   (
    {
     color: r = "currentColor",
     size: i = 24,
     strokeWidth: o = 2,
     absoluteStrokeWidth: s,
     className: a = "",
     children: l,
     ...u
    },
    h
   ) =>
    W.createElement(
     "svg",
     {
      ref: h,
      ...UM,
      width: i,
      height: i,
      stroke: r,
      strokeWidth: s ? (Number(o) * 24) / Number(i) : o,
      className: ["lucide", `lucide-${OM(t)}`, a].join(" "),
      ...u,
     },
     [...e.map(([p, m]) => W.createElement(p, m)), ...(Array.isArray(l) ? l : [l])]
    )
  );
  return (n.displayName = `${t}`), n;
 };
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const FM = nt("BarChart2", [
 ["line", { x1: "18", x2: "18", y1: "20", y2: "10", key: "1xfpm4" }],
 ["line", { x1: "12", x2: "12", y1: "20", y2: "4", key: "be30l9" }],
 ["line", { x1: "6", x2: "6", y1: "20", y2: "14", key: "1r4le6" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const BM = nt("BookOpen", [
 ["path", { d: "M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z", key: "vv98re" }],
 ["path", { d: "M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z", key: "1cyq3y" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const $M = nt("Briefcase", [
 ["rect", { width: "20", height: "14", x: "2", y: "7", rx: "2", ry: "2", key: "eto64e" }],
 ["path", { d: "M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16", key: "zwj3tp" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const HM = nt("Calendar", [
 ["path", { d: "M8 2v4", key: "1cmpym" }],
 ["path", { d: "M16 2v4", key: "4m81vk" }],
 ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
 ["path", { d: "M3 10h18", key: "8toen8" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const qM = nt("ClipboardCheck", [
 ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1", key: "tgr4d6" }],
 ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2", key: "116196" }],
 ["path", { d: "m9 14 2 2 4-4", key: "df797q" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const GM = nt("ClipboardList", [
 ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1", key: "tgr4d6" }],
 ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2", key: "116196" }],
 ["path", { d: "M12 11h4", key: "1jrz19" }],
 ["path", { d: "M12 16h4", key: "n85exb" }],
 ["path", { d: "M8 11h.01", key: "1dfujw" }],
 ["path", { d: "M8 16h.01", key: "18s6g9" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const zM = nt("Clock", [
 ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
 ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const WM = nt("FileSpreadsheet", [
 ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
 ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
 ["path", { d: "M8 13h2", key: "yr2amv" }],
 ["path", { d: "M14 13h2", key: "un5t4a" }],
 ["path", { d: "M8 17h2", key: "2yhykz" }],
 ["path", { d: "M14 17h2", key: "10kma7" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const KM = nt("FileText", [
 ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
 ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
 ["path", { d: "M10 9H8", key: "b1mrlr" }],
 ["path", { d: "M16 13H8", key: "t4e002" }],
 ["path", { d: "M16 17H8", key: "z1uh3a" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const JM = nt("GraduationCap", [
 [
  "path",
  {
   d: "M21.42 10.922a1 1 0 0 0-.019-1.838L12.83 5.18a2 2 0 0 0-1.66 0L2.6 9.08a1 1 0 0 0 0 1.832l8.57 3.908a2 2 0 0 0 1.66 0z",
   key: "j76jl0",
  },
 ],
 ["path", { d: "M22 10v6", key: "1lu8f3" }],
 ["path", { d: "M6 12.5V16a6 3 0 0 0 12 0v-3.5", key: "1r8lef" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const YM = nt("Home", [
 ["path", { d: "m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z", key: "y5dka4" }],
 ["polyline", { points: "9 22 9 12 15 12 15 22", key: "e2us08" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const QM = nt("LayoutDashboard", [
 ["rect", { width: "7", height: "9", x: "3", y: "3", rx: "1", key: "10lvy0" }],
 ["rect", { width: "7", height: "5", x: "14", y: "3", rx: "1", key: "16une8" }],
 ["rect", { width: "7", height: "9", x: "14", y: "12", rx: "1", key: "1hutg5" }],
 ["rect", { width: "7", height: "5", x: "3", y: "16", rx: "1", key: "ldoo1y" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const XM = nt("Library", [
 ["path", { d: "m16 6 4 14", key: "ji33uf" }],
 ["path", { d: "M12 6v14", key: "1n7gus" }],
 ["path", { d: "M8 8v12", key: "1gg7y9" }],
 ["path", { d: "M4 4v16", key: "6qkkli" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const jp = nt("LogOut", [
 ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }],
 ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }],
 ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const jM = nt("Monitor", [
 ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2", key: "48i651" }],
 ["line", { x1: "8", x2: "16", y1: "21", y2: "21", key: "1svkeh" }],
 ["line", { x1: "12", x2: "12", y1: "17", y2: "21", key: "vw1qmm" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ZM = nt("ScrollText", [
 ["path", { d: "M8 21h12a2 2 0 0 0 2-2v-2H10v2a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v3h4", key: "13a6an" }],
 ["path", { d: "M19 17V5a2 2 0 0 0-2-2H4", key: "zz82l3" }],
 ["path", { d: "M15 8h-5", key: "1khuty" }],
 ["path", { d: "M15 12h-5", key: "r7krc0" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const e1 = nt("Settings", [
 [
  "path",
  {
   d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
   key: "1qme2f",
  },
 ],
 ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const t1 = nt("UserCheck", [
 ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
 ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
 ["polyline", { points: "16 11 18 13 22 9", key: "1pwet4" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const n1 = nt("User", [
 ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
 ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const r1 = nt("Users", [
 ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
 ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
 ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
 ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }],
]);
/*!
 * sweetalert2 v11.26.17
 * Released under the MIT License.
 */ function LA(t, e, n) {
 if (typeof t == "function" ? t === e : t.has(e)) return arguments.length < 3 ? e : n;
 throw new TypeError("Private element is not present on this object");
}
function i1(t, e) {
 if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Hw(t, e) {
 return t.get(LA(t, e));
}
function o1(t, e, n) {
 i1(t, e), e.set(t, n);
}
function s1(t, e, n) {
 return t.set(LA(t, e), n), n;
}
const a1 = 100,
 X = {},
 l1 = () => {
  X.previousActiveElement instanceof HTMLElement
   ? (X.previousActiveElement.focus(), (X.previousActiveElement = null))
   : document.body && document.body.focus();
 },
 u1 = (t) =>
  new Promise((e) => {
   if (!t) return e();
   const n = window.scrollX,
    r = window.scrollY;
   (X.restoreFocusTimeout = setTimeout(() => {
    l1(), e();
   }, a1)),
    window.scrollTo(n, r);
  }),
 VA = "swal2-",
 c1 = [
  "container",
  "shown",
  "height-auto",
  "iosfix",
  "popup",
  "modal",
  "no-backdrop",
  "no-transition",
  "toast",
  "toast-shown",
  "show",
  "hide",
  "close",
  "title",
  "html-container",
  "actions",
  "confirm",
  "deny",
  "cancel",
  "footer",
  "icon",
  "icon-content",
  "image",
  "input",
  "file",
  "range",
  "select",
  "radio",
  "checkbox",
  "label",
  "textarea",
  "inputerror",
  "input-label",
  "validation-message",
  "progress-steps",
  "active-progress-step",
  "progress-step",
  "progress-step-line",
  "loader",
  "loading",
  "styled",
  "top",
  "top-start",
  "top-end",
  "top-left",
  "top-right",
  "center",
  "center-start",
  "center-end",
  "center-left",
  "center-right",
  "bottom",
  "bottom-start",
  "bottom-end",
  "bottom-left",
  "bottom-right",
  "grow-row",
  "grow-column",
  "grow-fullscreen",
  "rtl",
  "timer-progress-bar",
  "timer-progress-bar-container",
  "scrollbar-measure",
  "icon-success",
  "icon-warning",
  "icon-info",
  "icon-question",
  "icon-error",
  "draggable",
  "dragging",
 ],
 O = c1.reduce((t, e) => ((t[e] = VA + e), t), {}),
 d1 = ["success", "warning", "info", "question", "error"],
 td = d1.reduce((t, e) => ((t[e] = VA + e), t), {}),
 UA = "SweetAlert2:",
 Hg = (t) => t.charAt(0).toUpperCase() + t.slice(1),
 qt = (t) => {
  console.warn(`${UA} ${typeof t == "object" ? t.join(" ") : t}`);
 },
 Co = (t) => {
  console.error(`${UA} ${t}`);
 },
 qw = [],
 f1 = (t) => {
  qw.includes(t) || (qw.push(t), qt(t));
 },
 OA = (t, e = null) => {
  f1(`"${t}" is deprecated and will be removed in the next major release.${e ? ` Use "${e}" instead.` : ""}`);
 },
 jd = (t) => (typeof t == "function" ? t() : t),
 qg = (t) => t && typeof t.toPromise == "function",
 Ul = (t) => (qg(t) ? t.toPromise() : Promise.resolve(t)),
 Gg = (t) => t && Promise.resolve(t) === t,
 Kt = () => document.body.querySelector(`.${O.container}`),
 Ol = (t) => {
  const e = Kt();
  return e ? e.querySelector(t) : null;
 },
 yn = (t) => Ol(`.${t}`),
 _e = () => yn(O.popup),
 Bs = () => yn(O.icon),
 h1 = () => yn(O["icon-content"]),
 FA = () => yn(O.title),
 zg = () => yn(O["html-container"]),
 BA = () => yn(O.image),
 Wg = () => yn(O["progress-steps"]),
 Zd = () => yn(O["validation-message"]),
 lr = () => Ol(`.${O.actions} .${O.confirm}`),
 $s = () => Ol(`.${O.actions} .${O.cancel}`),
 Ro = () => Ol(`.${O.actions} .${O.deny}`),
 p1 = () => yn(O["input-label"]),
 Hs = () => Ol(`.${O.loader}`),
 Fl = () => yn(O.actions),
 $A = () => yn(O.footer),
 ef = () => yn(O["timer-progress-bar"]),
 Kg = () => yn(O.close),
 m1 = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`,
 Jg = () => {
  const t = _e();
  if (!t) return [];
  const e = t.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])'),
   n = Array.from(e).sort((o, s) => {
    const a = parseInt(o.getAttribute("tabindex") || "0"),
     l = parseInt(s.getAttribute("tabindex") || "0");
    return a > l ? 1 : a < l ? -1 : 0;
   }),
   r = t.querySelectorAll(m1),
   i = Array.from(r).filter((o) => o.getAttribute("tabindex") !== "-1");
  return [...new Set(n.concat(i))].filter((o) => nn(o));
 },
 Yg = () => Sr(document.body, O.shown) && !Sr(document.body, O["toast-shown"]) && !Sr(document.body, O["no-backdrop"]),
 tf = () => {
  const t = _e();
  return t ? Sr(t, O.toast) : !1;
 },
 g1 = () => {
  const t = _e();
  return t ? t.hasAttribute("data-loading") : !1;
 },
 vn = (t, e) => {
  if (((t.textContent = ""), e)) {
   const r = new DOMParser().parseFromString(e, "text/html"),
    i = r.querySelector("head");
   i &&
    Array.from(i.childNodes).forEach((s) => {
     t.appendChild(s);
    });
   const o = r.querySelector("body");
   o &&
    Array.from(o.childNodes).forEach((s) => {
     s instanceof HTMLVideoElement || s instanceof HTMLAudioElement ? t.appendChild(s.cloneNode(!0)) : t.appendChild(s);
    });
  }
 },
 Sr = (t, e) => {
  if (!e) return !1;
  const n = e.split(/\s+/);
  for (let r = 0; r < n.length; r++) if (!t.classList.contains(n[r])) return !1;
  return !0;
 },
 y1 = (t, e) => {
  Array.from(t.classList).forEach((n) => {
   !Object.values(O).includes(n) &&
    !Object.values(td).includes(n) &&
    !Object.values(e.showClass || {}).includes(n) &&
    t.classList.remove(n);
  });
 },
 pn = (t, e, n) => {
  if ((y1(t, e), !e.customClass)) return;
  const r = e.customClass[n];
  if (r) {
   if (typeof r != "string" && !r.forEach) {
    qt(`Invalid type of customClass.${n}! Expected string or iterable object, got "${typeof r}"`);
    return;
   }
   ve(t, r);
  }
 },
 nf = (t, e) => {
  if (!e) return null;
  switch (e) {
   case "select":
   case "textarea":
   case "file":
    return t.querySelector(`.${O.popup} > .${O[e]}`);
   case "checkbox":
    return t.querySelector(`.${O.popup} > .${O.checkbox} input`);
   case "radio":
    return (
     t.querySelector(`.${O.popup} > .${O.radio} input:checked`) ||
     t.querySelector(`.${O.popup} > .${O.radio} input:first-child`)
    );
   case "range":
    return t.querySelector(`.${O.popup} > .${O.range} input`);
   default:
    return t.querySelector(`.${O.popup} > .${O.input}`);
  }
 },
 HA = (t) => {
  if ((t.focus(), t.type !== "file")) {
   const e = t.value;
   (t.value = ""), (t.value = e);
  }
 },
 qA = (t, e, n) => {
  !t ||
   !e ||
   (typeof e == "string" && (e = e.split(/\s+/).filter(Boolean)),
   e.forEach((r) => {
    Array.isArray(t)
     ? t.forEach((i) => {
        n ? i.classList.add(r) : i.classList.remove(r);
       })
     : n
       ? t.classList.add(r)
       : t.classList.remove(r);
   }));
 },
 ve = (t, e) => {
  qA(t, e, !0);
 },
 Rn = (t, e) => {
  qA(t, e, !1);
 },
 li = (t, e) => {
  const n = Array.from(t.children);
  for (let r = 0; r < n.length; r++) {
   const i = n[r];
   if (i instanceof HTMLElement && Sr(i, e)) return i;
  }
 },
 io = (t, e, n) => {
  n === `${parseInt(`${n}`)}` && (n = parseInt(n)),
   n || parseInt(`${n}`) === 0
    ? t.style.setProperty(e, typeof n == "number" ? `${n}px` : n)
    : t.style.removeProperty(e);
 },
 ct = (t, e = "flex") => {
  t && (t.style.display = e);
 },
 Dt = (t) => {
  t && (t.style.display = "none");
 },
 Qg = (t, e = "block") => {
  t &&
   new MutationObserver(() => {
    Bl(t, t.innerHTML, e);
   }).observe(t, { childList: !0, subtree: !0 });
 },
 Gw = (t, e, n, r) => {
  const i = t.querySelector(e);
  i && i.style.setProperty(n, r);
 },
 Bl = (t, e, n = "flex") => {
  e ? ct(t, n) : Dt(t);
 },
 nn = (t) => !!(t && (t.offsetWidth || t.offsetHeight || t.getClientRects().length)),
 v1 = () => !nn(lr()) && !nn(Ro()) && !nn($s()),
 Zp = (t) => t.scrollHeight > t.clientHeight,
 _1 = (t, e) => {
  let n = t;
  for (; n && n !== e; ) {
   if (Zp(n)) return !0;
   n = n.parentElement;
  }
  return !1;
 },
 GA = (t) => {
  const e = window.getComputedStyle(t),
   n = parseFloat(e.getPropertyValue("animation-duration") || "0"),
   r = parseFloat(e.getPropertyValue("transition-duration") || "0");
  return n > 0 || r > 0;
 },
 Xg = (t, e = !1) => {
  const n = ef();
  n &&
   nn(n) &&
   (e && ((n.style.transition = "none"), (n.style.width = "100%")),
   setTimeout(() => {
    (n.style.transition = `width ${t / 1e3}s linear`), (n.style.width = "0%");
   }, 10));
 },
 w1 = () => {
  const t = ef();
  if (!t) return;
  const e = parseInt(window.getComputedStyle(t).width);
  t.style.removeProperty("transition"), (t.style.width = "100%");
  const n = parseInt(window.getComputedStyle(t).width),
   r = (e / n) * 100;
  t.style.width = `${r}%`;
 },
 E1 = () => typeof window > "u" || typeof document > "u",
 T1 = `
 <div aria-labelledby="${O.title}" aria-describedby="${O["html-container"]}" class="${O.popup}" tabindex="-1">
   <button type="button" class="${O.close}"></button>
   <ul class="${O["progress-steps"]}"></ul>
   <div class="${O.icon}"></div>
   <img class="${O.image}" />
   <h2 class="${O.title}" id="${O.title}"></h2>
   <div class="${O["html-container"]}" id="${O["html-container"]}"></div>
   <input class="${O.input}" id="${O.input}" />
   <input type="file" class="${O.file}" />
   <div class="${O.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${O.select}" id="${O.select}"></select>
   <div class="${O.radio}"></div>
   <label class="${O.checkbox}">
     <input type="checkbox" id="${O.checkbox}" />
     <span class="${O.label}"></span>
   </label>
   <textarea class="${O.textarea}" id="${O.textarea}"></textarea>
   <div class="${O["validation-message"]}" id="${O["validation-message"]}"></div>
   <div class="${O.actions}">
     <div class="${O.loader}"></div>
     <button type="button" class="${O.confirm}"></button>
     <button type="button" class="${O.deny}"></button>
     <button type="button" class="${O.cancel}"></button>
   </div>
   <div class="${O.footer}"></div>
   <div class="${O["timer-progress-bar-container"]}">
     <div class="${O["timer-progress-bar"]}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, ""),
 I1 = () => {
  const t = Kt();
  return t
   ? (t.remove(),
     Rn([document.documentElement, document.body], [O["no-backdrop"], O["toast-shown"], O["has-column"]]),
     !0)
   : !1;
 },
 $i = () => {
  X.currentInstance && X.currentInstance.resetValidationMessage();
 },
 S1 = () => {
  const t = _e();
  if (!t) return;
  const e = li(t, O.input),
   n = li(t, O.file),
   r = t.querySelector(`.${O.range} input`),
   i = t.querySelector(`.${O.range} output`),
   o = li(t, O.select),
   s = t.querySelector(`.${O.checkbox} input`),
   a = li(t, O.textarea);
  e && (e.oninput = $i),
   n && (n.onchange = $i),
   o && (o.onchange = $i),
   s && (s.onchange = $i),
   a && (a.oninput = $i),
   r &&
    i &&
    ((r.oninput = () => {
     $i(), (i.value = r.value);
    }),
    (r.onchange = () => {
     $i(), (i.value = r.value);
    }));
 },
 A1 = (t) => {
  if (typeof t == "string") {
   const e = document.querySelector(t);
   if (!e) throw new Error(`Target element "${t}" not found`);
   return e;
  }
  return t;
 },
 C1 = (t) => {
  const e = _e();
  e &&
   (e.setAttribute("role", t.toast ? "alert" : "dialog"),
   e.setAttribute("aria-live", t.toast ? "polite" : "assertive"),
   t.toast || e.setAttribute("aria-modal", "true"));
 },
 R1 = (t) => {
  window.getComputedStyle(t).direction === "rtl" && (ve(Kt(), O.rtl), (X.isRTL = !0));
 },
 P1 = (t) => {
  const e = I1();
  if (E1()) {
   Co("SweetAlert2 requires document to initialize");
   return;
  }
  const n = document.createElement("div");
  (n.className = O.container), e && ve(n, O["no-transition"]), vn(n, T1), (n.dataset.swal2Theme = t.theme);
  const r = A1(t.target || "body");
  r.appendChild(n), t.topLayer && (n.setAttribute("popover", ""), n.showPopover()), C1(t), R1(r), S1();
 },
 jg = (t, e) => {
  t instanceof HTMLElement ? e.appendChild(t) : typeof t == "object" ? k1(t, e) : t && vn(e, t);
 },
 k1 = (t, e) => {
  "jquery" in t ? b1(e, t) : vn(e, t.toString());
 },
 b1 = (t, e) => {
  if (((t.textContent = ""), 0 in e)) for (let n = 0; n in e; n++) t.appendChild(e[n].cloneNode(!0));
  else t.appendChild(e.cloneNode(!0));
 },
 N1 = (t, e) => {
  const n = Fl(),
   r = Hs();
  !n ||
   !r ||
   (!e.showConfirmButton && !e.showDenyButton && !e.showCancelButton ? Dt(n) : ct(n),
   pn(n, e, "actions"),
   x1(n, r, e),
   vn(r, e.loaderHtml || ""),
   pn(r, e, "loader"));
 };
function x1(t, e, n) {
 const r = lr(),
  i = Ro(),
  o = $s();
 !r ||
  !i ||
  !o ||
  (Nh(r, "confirm", n),
  Nh(i, "deny", n),
  Nh(o, "cancel", n),
  M1(r, i, o, n),
  n.reverseButtons &&
   (n.toast
    ? (t.insertBefore(o, r), t.insertBefore(i, r))
    : (t.insertBefore(o, e), t.insertBefore(i, e), t.insertBefore(r, e))));
}
function M1(t, e, n, r) {
 if (!r.buttonsStyling) {
  Rn([t, e, n], O.styled);
  return;
 }
 ve([t, e, n], O.styled),
  r.confirmButtonColor && t.style.setProperty("--swal2-confirm-button-background-color", r.confirmButtonColor),
  r.denyButtonColor && e.style.setProperty("--swal2-deny-button-background-color", r.denyButtonColor),
  r.cancelButtonColor && n.style.setProperty("--swal2-cancel-button-background-color", r.cancelButtonColor),
  bh(t),
  bh(e),
  bh(n);
}
function bh(t) {
 const e = window.getComputedStyle(t);
 if (e.getPropertyValue("--swal2-action-button-focus-box-shadow")) return;
 const n = e.backgroundColor.replace(/rgba?\((\d+), (\d+), (\d+).*/, "rgba($1, $2, $3, 0.5)");
 t.style.setProperty(
  "--swal2-action-button-focus-box-shadow",
  e.getPropertyValue("--swal2-outline").replace(/ rgba\(.*/, ` ${n}`)
 );
}
function Nh(t, e, n) {
 const r = Hg(e);
 Bl(t, n[`show${r}Button`], "inline-block"),
  vn(t, n[`${e}ButtonText`] || ""),
  t.setAttribute("aria-label", n[`${e}ButtonAriaLabel`] || ""),
  (t.className = O[e]),
  pn(t, n, `${e}Button`);
}
const D1 = (t, e) => {
  const n = Kg();
  n &&
   (vn(n, e.closeButtonHtml || ""),
   pn(n, e, "closeButton"),
   Bl(n, e.showCloseButton),
   n.setAttribute("aria-label", e.closeButtonAriaLabel || ""));
 },
 L1 = (t, e) => {
  const n = Kt();
  n && (V1(n, e.backdrop), U1(n, e.position), O1(n, e.grow), pn(n, e, "container"));
 };
function V1(t, e) {
 typeof e == "string" ? (t.style.background = e) : e || ve([document.documentElement, document.body], O["no-backdrop"]);
}
function U1(t, e) {
 e && (e in O ? ve(t, O[e]) : (qt('The "position" parameter is not valid, defaulting to "center"'), ve(t, O.center)));
}
function O1(t, e) {
 e && ve(t, O[`grow-${e}`]);
}
var Pe = { innerParams: new WeakMap(), domCache: new WeakMap() };
const F1 = ["input", "file", "range", "select", "radio", "checkbox", "textarea"],
 B1 = (t, e) => {
  const n = _e();
  if (!n) return;
  const r = Pe.innerParams.get(t),
   i = !r || e.input !== r.input;
  F1.forEach((o) => {
   const s = li(n, O[o]);
   s && (q1(o, e.inputAttributes), (s.className = O[o]), i && Dt(s));
  }),
   e.input && (i && $1(e), G1(e));
 },
 $1 = (t) => {
  if (!t.input) return;
  if (!Ke[t.input]) {
   Co(`Unexpected type of input! Expected ${Object.keys(Ke).join(" | ")}, got "${t.input}"`);
   return;
  }
  const e = zA(t.input);
  if (!e) return;
  const n = Ke[t.input](e, t);
  ct(e),
   t.inputAutoFocus &&
    setTimeout(() => {
     HA(n);
    });
 },
 H1 = (t) => {
  for (let e = 0; e < t.attributes.length; e++) {
   const n = t.attributes[e].name;
   ["id", "type", "value", "style"].includes(n) || t.removeAttribute(n);
  }
 },
 q1 = (t, e) => {
  const n = _e();
  if (!n) return;
  const r = nf(n, t);
  if (r) {
   H1(r);
   for (const i in e) r.setAttribute(i, e[i]);
  }
 },
 G1 = (t) => {
  if (!t.input) return;
  const e = zA(t.input);
  e && pn(e, t, "input");
 },
 Zg = (t, e) => {
  !t.placeholder && e.inputPlaceholder && (t.placeholder = e.inputPlaceholder);
 },
 $l = (t, e, n) => {
  if (n.inputLabel) {
   const r = document.createElement("label"),
    i = O["input-label"];
   r.setAttribute("for", t.id),
    (r.className = i),
    typeof n.customClass == "object" && ve(r, n.customClass.inputLabel),
    (r.innerText = n.inputLabel),
    e.insertAdjacentElement("beforebegin", r);
  }
 },
 zA = (t) => {
  const e = _e();
  if (e) return li(e, O[t] || O.input);
 },
 nd = (t, e) => {
  ["string", "number"].includes(typeof e)
   ? (t.value = `${e}`)
   : Gg(e) || qt(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof e}"`);
 },
 Ke = {};
Ke.text =
 Ke.email =
 Ke.password =
 Ke.number =
 Ke.tel =
 Ke.url =
 Ke.search =
 Ke.date =
 Ke["datetime-local"] =
 Ke.time =
 Ke.week =
 Ke.month =
  (t, e) => {
   const n = t;
   return nd(n, e.inputValue), $l(n, n, e), Zg(n, e), (n.type = e.input), n;
  };
Ke.file = (t, e) => {
 const n = t;
 return $l(n, n, e), Zg(n, e), n;
};
Ke.range = (t, e) => {
 const n = t,
  r = n.querySelector("input"),
  i = n.querySelector("output");
 return r && (nd(r, e.inputValue), (r.type = e.input), $l(r, t, e)), i && nd(i, e.inputValue), t;
};
Ke.select = (t, e) => {
 const n = t;
 if (((n.textContent = ""), e.inputPlaceholder)) {
  const r = document.createElement("option");
  vn(r, e.inputPlaceholder), (r.value = ""), (r.disabled = !0), (r.selected = !0), n.appendChild(r);
 }
 return $l(n, n, e), n;
};
Ke.radio = (t) => {
 const e = t;
 return (e.textContent = ""), t;
};
Ke.checkbox = (t, e) => {
 const n = _e();
 if (!n) throw new Error("Popup not found");
 const r = nf(n, "checkbox");
 if (!r) throw new Error("Checkbox input not found");
 (r.value = "1"), (r.checked = !!e.inputValue);
 const o = t.querySelector("span");
 if (o) {
  const s = e.inputPlaceholder || e.inputLabel;
  s && vn(o, s);
 }
 return r;
};
Ke.textarea = (t, e) => {
 const n = t;
 nd(n, e.inputValue), Zg(n, e), $l(n, n, e);
 const r = (i) => parseInt(window.getComputedStyle(i).marginLeft) + parseInt(window.getComputedStyle(i).marginRight);
 return (
  setTimeout(() => {
   if ("MutationObserver" in window) {
    const i = _e();
    if (!i) return;
    const o = parseInt(window.getComputedStyle(i).width),
     s = () => {
      if (!document.body.contains(n)) return;
      const a = n.offsetWidth + r(n),
       l = _e();
      l && (a > o ? (l.style.width = `${a}px`) : io(l, "width", e.width));
     };
    new MutationObserver(s).observe(n, { attributes: !0, attributeFilter: ["style"] });
   }
  }),
  n
 );
};
const z1 = (t, e) => {
  const n = zg();
  n &&
   (Qg(n),
   pn(n, e, "htmlContainer"),
   e.html ? (jg(e.html, n), ct(n, "block")) : e.text ? ((n.textContent = e.text), ct(n, "block")) : Dt(n),
   B1(t, e));
 },
 W1 = (t, e) => {
  const n = $A();
  n && (Qg(n), Bl(n, !!e.footer, "block"), e.footer && jg(e.footer, n), pn(n, e, "footer"));
 },
 K1 = (t, e) => {
  const n = Pe.innerParams.get(t),
   r = Bs();
  if (!r) return;
  if (n && e.icon === n.icon) {
   Ww(r, e), zw(r, e);
   return;
  }
  if (!e.icon && !e.iconHtml) {
   Dt(r);
   return;
  }
  if (e.icon && Object.keys(td).indexOf(e.icon) === -1) {
   Co(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${e.icon}"`), Dt(r);
   return;
  }
  ct(r),
   Ww(r, e),
   zw(r, e),
   ve(r, e.showClass && e.showClass.icon),
   window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", WA);
 },
 zw = (t, e) => {
  for (const [n, r] of Object.entries(td)) e.icon !== n && Rn(t, r);
  ve(t, e.icon && td[e.icon]), Q1(t, e), WA(), pn(t, e, "icon");
 },
 WA = () => {
  const t = _e();
  if (!t) return;
  const e = window.getComputedStyle(t).getPropertyValue("background-color"),
   n = t.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
  for (let r = 0; r < n.length; r++) n[r].style.backgroundColor = e;
 },
 J1 = (t) => `
  ${t.animation ? '<div class="swal2-success-circular-line-left"></div>' : ""}
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div>
  ${t.animation ? '<div class="swal2-success-fix"></div>' : ""}
  ${t.animation ? '<div class="swal2-success-circular-line-right"></div>' : ""}
`,
 Y1 = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`,
 Ww = (t, e) => {
  if (!e.icon && !e.iconHtml) return;
  let n = t.innerHTML,
   r = "";
  e.iconHtml
   ? (r = Kw(e.iconHtml))
   : e.icon === "success"
     ? ((r = J1(e)), (n = n.replace(/ style=".*?"/g, "")))
     : e.icon === "error"
       ? (r = Y1)
       : e.icon && (r = Kw({ question: "?", warning: "!", info: "i" }[e.icon])),
   n.trim() !== r.trim() && vn(t, r);
 },
 Q1 = (t, e) => {
  if (e.iconColor) {
   (t.style.color = e.iconColor), (t.style.borderColor = e.iconColor);
   for (const n of [
    ".swal2-success-line-tip",
    ".swal2-success-line-long",
    ".swal2-x-mark-line-left",
    ".swal2-x-mark-line-right",
   ])
    Gw(t, n, "background-color", e.iconColor);
   Gw(t, ".swal2-success-ring", "border-color", e.iconColor);
  }
 },
 Kw = (t) => `<div class="${O["icon-content"]}">${t}</div>`,
 X1 = (t, e) => {
  const n = BA();
  if (n) {
   if (!e.imageUrl) {
    Dt(n);
    return;
   }
   ct(n, ""),
    n.setAttribute("src", e.imageUrl),
    n.setAttribute("alt", e.imageAlt || ""),
    io(n, "width", e.imageWidth),
    io(n, "height", e.imageHeight),
    (n.className = O.image),
    pn(n, e, "image");
  }
 };
let ey = !1,
 KA = 0,
 JA = 0,
 YA = 0,
 QA = 0;
const j1 = (t) => {
  t.addEventListener("mousedown", rd),
   document.body.addEventListener("mousemove", id),
   t.addEventListener("mouseup", od),
   t.addEventListener("touchstart", rd),
   document.body.addEventListener("touchmove", id),
   t.addEventListener("touchend", od);
 },
 Z1 = (t) => {
  t.removeEventListener("mousedown", rd),
   document.body.removeEventListener("mousemove", id),
   t.removeEventListener("mouseup", od),
   t.removeEventListener("touchstart", rd),
   document.body.removeEventListener("touchmove", id),
   t.removeEventListener("touchend", od);
 },
 rd = (t) => {
  const e = _e();
  if (!e) return;
  const n = Bs();
  if (t.target === e || (n && n.contains(t.target))) {
   ey = !0;
   const r = XA(t);
   (KA = r.clientX),
    (JA = r.clientY),
    (YA = parseInt(e.style.insetInlineStart) || 0),
    (QA = parseInt(e.style.insetBlockStart) || 0),
    ve(e, "swal2-dragging");
  }
 },
 id = (t) => {
  const e = _e();
  if (e && ey) {
   let { clientX: n, clientY: r } = XA(t);
   const i = n - KA;
   (e.style.insetInlineStart = `${YA + (X.isRTL ? -i : i)}px`), (e.style.insetBlockStart = `${QA + (r - JA)}px`);
  }
 },
 od = () => {
  const t = _e();
  (ey = !1), Rn(t, "swal2-dragging");
 },
 XA = (t) => {
  let e = 0,
   n = 0;
  return (
   t.type.startsWith("mouse")
    ? ((e = t.clientX), (n = t.clientY))
    : t.type.startsWith("touch") && ((e = t.touches[0].clientX), (n = t.touches[0].clientY)),
   { clientX: e, clientY: n }
  );
 },
 eD = (t, e) => {
  const n = Kt(),
   r = _e();
  if (!(!n || !r)) {
   if (e.toast) {
    io(n, "width", e.width), (r.style.width = "100%");
    const i = Hs();
    i && r.insertBefore(i, Bs());
   } else io(r, "width", e.width);
   io(r, "padding", e.padding),
    e.color && (r.style.color = e.color),
    e.background && (r.style.background = e.background),
    Dt(Zd()),
    tD(r, e),
    e.draggable && !e.toast ? (ve(r, O.draggable), j1(r)) : (Rn(r, O.draggable), Z1(r));
  }
 },
 tD = (t, e) => {
  const n = e.showClass || {};
  (t.className = `${O.popup} ${nn(t) ? n.popup : ""}`),
   e.toast ? (ve([document.documentElement, document.body], O["toast-shown"]), ve(t, O.toast)) : ve(t, O.modal),
   pn(t, e, "popup"),
   typeof e.customClass == "string" && ve(t, e.customClass),
   e.icon && ve(t, O[`icon-${e.icon}`]);
 },
 nD = (t, e) => {
  const n = Wg();
  if (!n) return;
  const { progressSteps: r, currentProgressStep: i } = e;
  if (!r || r.length === 0 || i === void 0) {
   Dt(n);
   return;
  }
  ct(n),
   (n.textContent = ""),
   i >= r.length &&
    qt(
     "Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"
    ),
   r.forEach((o, s) => {
    const a = rD(o);
    if ((n.appendChild(a), s === i && ve(a, O["active-progress-step"]), s !== r.length - 1)) {
     const l = iD(e);
     n.appendChild(l);
    }
   });
 },
 rD = (t) => {
  const e = document.createElement("li");
  return ve(e, O["progress-step"]), vn(e, t), e;
 },
 iD = (t) => {
  const e = document.createElement("li");
  return ve(e, O["progress-step-line"]), t.progressStepsDistance && io(e, "width", t.progressStepsDistance), e;
 },
 oD = (t, e) => {
  const n = FA();
  n &&
   (Qg(n),
   Bl(n, !!(e.title || e.titleText), "block"),
   e.title && jg(e.title, n),
   e.titleText && (n.innerText = e.titleText),
   pn(n, e, "title"));
 },
 jA = (t, e) => {
  var n;
  eD(t, e), L1(t, e), nD(t, e), K1(t, e), X1(t, e), oD(t, e), D1(t, e), z1(t, e), N1(t, e), W1(t, e);
  const r = _e();
  typeof e.didRender == "function" && r && e.didRender(r),
   (n = X.eventEmitter) === null || n === void 0 || n.emit("didRender", r);
 },
 sD = () => nn(_e()),
 ZA = () => {
  var t;
  return (t = lr()) === null || t === void 0 ? void 0 : t.click();
 },
 aD = () => {
  var t;
  return (t = Ro()) === null || t === void 0 ? void 0 : t.click();
 },
 lD = () => {
  var t;
  return (t = $s()) === null || t === void 0 ? void 0 : t.click();
 },
 qs = Object.freeze({ cancel: "cancel", backdrop: "backdrop", close: "close", esc: "esc", timer: "timer" }),
 eC = (t) => {
  if (t.keydownTarget && t.keydownHandlerAdded && t.keydownHandler) {
   const e = t.keydownHandler;
   t.keydownTarget.removeEventListener("keydown", e, { capture: t.keydownListenerCapture }),
    (t.keydownHandlerAdded = !1);
  }
 },
 uD = (t, e, n) => {
  if ((eC(t), !e.toast)) {
   const r = (o) => dD(e, o, n);
   t.keydownHandler = r;
   const i = e.keydownListenerCapture ? window : _e();
   if (i) {
    (t.keydownTarget = i), (t.keydownListenerCapture = e.keydownListenerCapture);
    const o = r;
    t.keydownTarget.addEventListener("keydown", o, { capture: t.keydownListenerCapture }), (t.keydownHandlerAdded = !0);
   }
  }
 },
 em = (t, e) => {
  var n;
  const r = Jg();
  if (r.length) {
   (t = t + e), t === -2 && (t = r.length - 1), t === r.length ? (t = 0) : t === -1 && (t = r.length - 1), r[t].focus();
   return;
  }
  (n = _e()) === null || n === void 0 || n.focus();
 },
 tC = ["ArrowRight", "ArrowDown"],
 cD = ["ArrowLeft", "ArrowUp"],
 dD = (t, e, n) => {
  t &&
   (e.isComposing ||
    e.keyCode === 229 ||
    (t.stopKeydownPropagation && e.stopPropagation(),
    e.key === "Enter"
     ? fD(e, t)
     : e.key === "Tab"
       ? hD(e)
       : [...tC, ...cD].includes(e.key)
         ? pD(e.key)
         : e.key === "Escape" && mD(e, t, n)));
 },
 fD = (t, e) => {
  if (!jd(e.allowEnterKey)) return;
  const n = _e();
  if (!n || !e.input) return;
  const r = nf(n, e.input);
  if (t.target && r && t.target instanceof HTMLElement && t.target.outerHTML === r.outerHTML) {
   if (["textarea", "file"].includes(e.input)) return;
   ZA(), t.preventDefault();
  }
 },
 hD = (t) => {
  const e = t.target,
   n = Jg();
  let r = -1;
  for (let i = 0; i < n.length; i++)
   if (e === n[i]) {
    r = i;
    break;
   }
  t.shiftKey ? em(r, -1) : em(r, 1), t.stopPropagation(), t.preventDefault();
 },
 pD = (t) => {
  const e = Fl(),
   n = lr(),
   r = Ro(),
   i = $s();
  if (!e || !n || !r || !i) return;
  const o = [n, r, i];
  if (document.activeElement instanceof HTMLElement && !o.includes(document.activeElement)) return;
  const s = tC.includes(t) ? "nextElementSibling" : "previousElementSibling";
  let a = document.activeElement;
  if (a) {
   for (let l = 0; l < e.children.length; l++) {
    if (((a = a[s]), !a)) return;
    if (a instanceof HTMLButtonElement && nn(a)) break;
   }
   a instanceof HTMLButtonElement && a.focus();
  }
 },
 mD = (t, e, n) => {
  t.preventDefault(), jd(e.allowEscapeKey) && n(qs.esc);
 };
var Cs = { swalPromiseResolve: new WeakMap(), swalPromiseReject: new WeakMap() };
const gD = () => {
  const t = Kt();
  Array.from(document.body.children).forEach((n) => {
   n.contains(t) ||
    (n.hasAttribute("aria-hidden") && n.setAttribute("data-previous-aria-hidden", n.getAttribute("aria-hidden") || ""),
    n.setAttribute("aria-hidden", "true"));
  });
 },
 nC = () => {
  Array.from(document.body.children).forEach((e) => {
   e.hasAttribute("data-previous-aria-hidden")
    ? (e.setAttribute("aria-hidden", e.getAttribute("data-previous-aria-hidden") || ""),
      e.removeAttribute("data-previous-aria-hidden"))
    : e.removeAttribute("aria-hidden");
  });
 },
 rC = typeof window < "u" && !!window.GestureEvent,
 yD = () => {
  if (rC && !Sr(document.body, O.iosfix)) {
   const t = document.body.scrollTop;
   (document.body.style.top = `${t * -1}px`), ve(document.body, O.iosfix), vD();
  }
 },
 vD = () => {
  const t = Kt();
  if (!t) return;
  let e;
  (t.ontouchstart = (n) => {
   e = _D(n);
  }),
   (t.ontouchmove = (n) => {
    e && (n.preventDefault(), n.stopPropagation());
   });
 },
 _D = (t) => {
  const e = t.target,
   n = Kt(),
   r = zg();
  return !n || !r || wD(t) || ED(t)
   ? !1
   : e === n ||
      (!Zp(n) &&
       e instanceof HTMLElement &&
       !_1(e, r) &&
       e.tagName !== "INPUT" &&
       e.tagName !== "TEXTAREA" &&
       !(Zp(r) && r.contains(e)));
 },
 wD = (t) => !!(t.touches && t.touches.length && t.touches[0].touchType === "stylus"),
 ED = (t) => t.touches && t.touches.length > 1,
 TD = () => {
  if (Sr(document.body, O.iosfix)) {
   const t = parseInt(document.body.style.top, 10);
   Rn(document.body, O.iosfix), (document.body.style.top = ""), (document.body.scrollTop = t * -1);
  }
 },
 ID = () => {
  const t = document.createElement("div");
  (t.className = O["scrollbar-measure"]), document.body.appendChild(t);
  const e = t.getBoundingClientRect().width - t.clientWidth;
  return document.body.removeChild(t), e;
 };
let fs = null;
const SD = (t) => {
  fs === null &&
   (document.body.scrollHeight > window.innerHeight || t === "scroll") &&
   ((fs = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"))),
   (document.body.style.paddingRight = `${fs + ID()}px`));
 },
 AD = () => {
  fs !== null && ((document.body.style.paddingRight = `${fs}px`), (fs = null));
 };
function iC(t, e, n, r) {
 tf() ? Jw(t, r) : (u1(n).then(() => Jw(t, r)), eC(X)),
  rC
   ? (e.setAttribute("style", "display:none !important"), e.removeAttribute("class"), (e.innerHTML = ""))
   : e.remove(),
  Yg() && (AD(), TD(), nC()),
  CD();
}
function CD() {
 Rn([document.documentElement, document.body], [O.shown, O["height-auto"], O["no-backdrop"], O["toast-shown"]]);
}
function ui(t) {
 t = PD(t);
 const e = Cs.swalPromiseResolve.get(this),
  n = RD(this);
 this.isAwaitingPromise ? t.isDismissed || (Hl(this), e(t)) : n && e(t);
}
const RD = (t) => {
 const e = _e();
 if (!e) return !1;
 const n = Pe.innerParams.get(t);
 if (!n || Sr(e, n.hideClass.popup)) return !1;
 Rn(e, n.showClass.popup), ve(e, n.hideClass.popup);
 const r = Kt();
 return Rn(r, n.showClass.backdrop), ve(r, n.hideClass.backdrop), kD(t, e, n), !0;
};
function oC(t) {
 const e = Cs.swalPromiseReject.get(this);
 Hl(this), e && e(t);
}
const Hl = (t) => {
  t.isAwaitingPromise && (delete t.isAwaitingPromise, Pe.innerParams.get(t) || t._destroy());
 },
 PD = (t) =>
  typeof t > "u"
   ? { isConfirmed: !1, isDenied: !1, isDismissed: !0 }
   : Object.assign({ isConfirmed: !1, isDenied: !1, isDismissed: !1 }, t),
 kD = (t, e, n) => {
  var r;
  const i = Kt(),
   o = GA(e);
  typeof n.willClose == "function" && n.willClose(e),
   (r = X.eventEmitter) === null || r === void 0 || r.emit("willClose", e),
   o && i ? bD(t, e, i, !!n.returnFocus, n.didClose) : i && iC(t, i, !!n.returnFocus, n.didClose);
 },
 bD = (t, e, n, r, i) => {
  X.swalCloseEventFinishedCallback = iC.bind(null, t, n, r, i);
  const o = function (s) {
   if (s.target === e) {
    var a;
    (a = X.swalCloseEventFinishedCallback) === null || a === void 0 || a.call(X),
     delete X.swalCloseEventFinishedCallback,
     e.removeEventListener("animationend", o),
     e.removeEventListener("transitionend", o);
   }
  };
  e.addEventListener("animationend", o), e.addEventListener("transitionend", o);
 },
 Jw = (t, e) => {
  setTimeout(() => {
   var n;
   typeof e == "function" && e.bind(t.params)(),
    (n = X.eventEmitter) === null || n === void 0 || n.emit("didClose"),
    t._destroy && t._destroy();
  });
 },
 Rs = (t) => {
  let e = _e();
  if ((e || new vl(), (e = _e()), !e)) return;
  const n = Hs();
  tf() ? Dt(Bs()) : ND(e, t),
   ct(n),
   e.setAttribute("data-loading", "true"),
   e.setAttribute("aria-busy", "true"),
   e.focus();
 },
 ND = (t, e) => {
  const n = Fl(),
   r = Hs();
  !n ||
   !r ||
   (!e && nn(lr()) && (e = lr()),
   ct(n),
   e && (Dt(e), r.setAttribute("data-button-to-replace", e.className), n.insertBefore(r, e)),
   ve([t, n], O.loading));
 },
 xD = (t, e) => {
  e.input === "select" || e.input === "radio"
   ? UD(t, e)
   : ["text", "email", "number", "tel", "textarea"].some((n) => n === e.input) &&
     (qg(e.inputValue) || Gg(e.inputValue)) &&
     (Rs(lr()), OD(t, e));
 },
 MD = (t, e) => {
  const n = t.getInput();
  if (!n) return null;
  switch (e.input) {
   case "checkbox":
    return DD(n);
   case "radio":
    return LD(n);
   case "file":
    return VD(n);
   default:
    return e.inputAutoTrim ? n.value.trim() : n.value;
  }
 },
 DD = (t) => (t.checked ? 1 : 0),
 LD = (t) => (t.checked ? t.value : null),
 VD = (t) => (t.files && t.files.length ? (t.getAttribute("multiple") !== null ? t.files : t.files[0]) : null),
 UD = (t, e) => {
  const n = _e();
  if (!n) return;
  const r = (i) => {
   e.input === "select" ? FD(n, sd(i), e) : e.input === "radio" && BD(n, sd(i), e);
  };
  qg(e.inputOptions) || Gg(e.inputOptions)
   ? (Rs(lr()),
     Ul(e.inputOptions).then((i) => {
      t.hideLoading(), r(i);
     }))
   : typeof e.inputOptions == "object"
     ? r(e.inputOptions)
     : Co(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof e.inputOptions}`);
 },
 OD = (t, e) => {
  const n = t.getInput();
  n &&
   (Dt(n),
   Ul(e.inputValue)
    .then((r) => {
     (n.value = e.input === "number" ? `${parseFloat(r) || 0}` : `${r}`), ct(n), n.focus(), t.hideLoading();
    })
    .catch((r) => {
     Co(`Error in inputValue promise: ${r}`), (n.value = ""), ct(n), n.focus(), t.hideLoading();
    }));
 };
function FD(t, e, n) {
 const r = li(t, O.select);
 if (!r) return;
 const i = (o, s, a) => {
  const l = document.createElement("option");
  (l.value = a), vn(l, s), (l.selected = sC(a, n.inputValue)), o.appendChild(l);
 };
 e.forEach((o) => {
  const s = o[0],
   a = o[1];
  if (Array.isArray(a)) {
   const l = document.createElement("optgroup");
   (l.label = s), (l.disabled = !1), r.appendChild(l), a.forEach((u) => i(l, u[1], u[0]));
  } else i(r, a, s);
 }),
  r.focus();
}
function BD(t, e, n) {
 const r = li(t, O.radio);
 if (!r) return;
 e.forEach((o) => {
  const s = o[0],
   a = o[1],
   l = document.createElement("input"),
   u = document.createElement("label");
  (l.type = "radio"), (l.name = O.radio), (l.value = s), sC(s, n.inputValue) && (l.checked = !0);
  const h = document.createElement("span");
  vn(h, a), (h.className = O.label), u.appendChild(l), u.appendChild(h), r.appendChild(u);
 });
 const i = r.querySelectorAll("input");
 i.length && i[0].focus();
}
const sd = (t) => {
  const e = [];
  return (
   t instanceof Map
    ? t.forEach((n, r) => {
       let i = n;
       typeof i == "object" && (i = sd(i)), e.push([r, i]);
      })
    : Object.keys(t).forEach((n) => {
       let r = t[n];
       typeof r == "object" && (r = sd(r)), e.push([n, r]);
      }),
   e
  );
 },
 sC = (t, e) => !!e && e !== null && e !== void 0 && e.toString() === t.toString(),
 $D = (t) => {
  const e = Pe.innerParams.get(t);
  t.disableButtons(), e.input ? aC(t, "confirm") : ny(t, !0);
 },
 HD = (t) => {
  const e = Pe.innerParams.get(t);
  t.disableButtons(), e.returnInputValueOnDeny ? aC(t, "deny") : ty(t, !1);
 },
 qD = (t, e) => {
  t.disableButtons(), e(qs.cancel);
 },
 aC = (t, e) => {
  const n = Pe.innerParams.get(t);
  if (!n.input) {
   Co(`The "input" parameter is needed to be set when using returnInputValueOn${Hg(e)}`);
   return;
  }
  const r = t.getInput(),
   i = MD(t, n);
  n.inputValidator
   ? GD(t, i, e)
   : r && !r.checkValidity()
     ? (t.enableButtons(), t.showValidationMessage(n.validationMessage || r.validationMessage))
     : e === "deny"
       ? ty(t, i)
       : ny(t, i);
 },
 GD = (t, e, n) => {
  const r = Pe.innerParams.get(t);
  t.disableInput(),
   Promise.resolve()
    .then(() => Ul(r.inputValidator(e, r.validationMessage)))
    .then((o) => {
     t.enableButtons(), t.enableInput(), o ? t.showValidationMessage(o) : n === "deny" ? ty(t, e) : ny(t, e);
    });
 },
 ty = (t, e) => {
  const n = Pe.innerParams.get(t);
  n.showLoaderOnDeny && Rs(Ro()),
   n.preDeny
    ? ((t.isAwaitingPromise = !0),
      Promise.resolve()
       .then(() => Ul(n.preDeny(e, n.validationMessage)))
       .then((i) => {
        i === !1 ? (t.hideLoading(), Hl(t)) : t.close({ isDenied: !0, value: typeof i > "u" ? e : i });
       })
       .catch((i) => lC(t, i)))
    : t.close({ isDenied: !0, value: e });
 },
 Yw = (t, e) => {
  t.close({ isConfirmed: !0, value: e });
 },
 lC = (t, e) => {
  t.rejectPromise(e);
 },
 ny = (t, e) => {
  const n = Pe.innerParams.get(t);
  n.showLoaderOnConfirm && Rs(),
   n.preConfirm
    ? (t.resetValidationMessage(),
      (t.isAwaitingPromise = !0),
      Promise.resolve()
       .then(() => Ul(n.preConfirm(e, n.validationMessage)))
       .then((i) => {
        nn(Zd()) || i === !1 ? (t.hideLoading(), Hl(t)) : Yw(t, typeof i > "u" ? e : i);
       })
       .catch((i) => lC(t, i)))
    : Yw(t, e);
 };
function ad() {
 const t = Pe.innerParams.get(this);
 if (!t) return;
 const e = Pe.domCache.get(this);
 Dt(e.loader),
  tf() ? t.icon && ct(Bs()) : zD(e),
  Rn([e.popup, e.actions], O.loading),
  e.popup.removeAttribute("aria-busy"),
  e.popup.removeAttribute("data-loading"),
  (e.confirmButton.disabled = !1),
  (e.denyButton.disabled = !1),
  (e.cancelButton.disabled = !1);
}
const zD = (t) => {
 const e = t.loader.getAttribute("data-button-to-replace"),
  n = e ? t.popup.getElementsByClassName(e) : [];
 n.length ? ct(n[0], "inline-block") : v1() && Dt(t.actions);
};
function uC() {
 const t = Pe.innerParams.get(this),
  e = Pe.domCache.get(this);
 return e ? nf(e.popup, t.input) : null;
}
function cC(t, e, n) {
 const r = Pe.domCache.get(t);
 e.forEach((i) => {
  r[i].disabled = n;
 });
}
function dC(t, e) {
 const n = _e();
 if (!(!n || !t))
  if (t.type === "radio") {
   const r = n.querySelectorAll(`[name="${O.radio}"]`);
   for (let i = 0; i < r.length; i++) r[i].disabled = e;
  } else t.disabled = e;
}
function fC() {
 cC(this, ["confirmButton", "denyButton", "cancelButton"], !1);
}
function hC() {
 cC(this, ["confirmButton", "denyButton", "cancelButton"], !0);
}
function pC() {
 dC(this.getInput(), !1);
}
function mC() {
 dC(this.getInput(), !0);
}
function gC(t) {
 const e = Pe.domCache.get(this),
  n = Pe.innerParams.get(this);
 vn(e.validationMessage, t),
  (e.validationMessage.className = O["validation-message"]),
  n.customClass && n.customClass.validationMessage && ve(e.validationMessage, n.customClass.validationMessage),
  ct(e.validationMessage);
 const r = this.getInput();
 r &&
  (r.setAttribute("aria-invalid", "true"),
  r.setAttribute("aria-describedby", O["validation-message"]),
  HA(r),
  ve(r, O.inputerror));
}
function yC() {
 const t = Pe.domCache.get(this);
 t.validationMessage && Dt(t.validationMessage);
 const e = this.getInput();
 e && (e.removeAttribute("aria-invalid"), e.removeAttribute("aria-describedby"), Rn(e, O.inputerror));
}
const ci = {
  title: "",
  titleText: "",
  text: "",
  html: "",
  footer: "",
  icon: void 0,
  iconColor: void 0,
  iconHtml: void 0,
  template: void 0,
  toast: !1,
  draggable: !1,
  animation: !0,
  theme: "light",
  showClass: { popup: "swal2-show", backdrop: "swal2-backdrop-show", icon: "swal2-icon-show" },
  hideClass: { popup: "swal2-hide", backdrop: "swal2-backdrop-hide", icon: "swal2-icon-hide" },
  customClass: {},
  target: "body",
  color: void 0,
  backdrop: !0,
  heightAuto: !0,
  allowOutsideClick: !0,
  allowEscapeKey: !0,
  allowEnterKey: !0,
  stopKeydownPropagation: !0,
  keydownListenerCapture: !1,
  showConfirmButton: !0,
  showDenyButton: !1,
  showCancelButton: !1,
  preConfirm: void 0,
  preDeny: void 0,
  confirmButtonText: "OK",
  confirmButtonAriaLabel: "",
  confirmButtonColor: void 0,
  denyButtonText: "No",
  denyButtonAriaLabel: "",
  denyButtonColor: void 0,
  cancelButtonText: "Cancel",
  cancelButtonAriaLabel: "",
  cancelButtonColor: void 0,
  buttonsStyling: !0,
  reverseButtons: !1,
  focusConfirm: !0,
  focusDeny: !1,
  focusCancel: !1,
  returnFocus: !0,
  showCloseButton: !1,
  closeButtonHtml: "&times;",
  closeButtonAriaLabel: "Close this dialog",
  loaderHtml: "",
  showLoaderOnConfirm: !1,
  showLoaderOnDeny: !1,
  imageUrl: void 0,
  imageWidth: void 0,
  imageHeight: void 0,
  imageAlt: "",
  timer: void 0,
  timerProgressBar: !1,
  width: void 0,
  padding: void 0,
  background: void 0,
  input: void 0,
  inputPlaceholder: "",
  inputLabel: "",
  inputValue: "",
  inputOptions: {},
  inputAutoFocus: !0,
  inputAutoTrim: !0,
  inputAttributes: {},
  inputValidator: void 0,
  returnInputValueOnDeny: !1,
  validationMessage: void 0,
  grow: !1,
  position: "center",
  progressSteps: [],
  currentProgressStep: void 0,
  progressStepsDistance: void 0,
  willOpen: void 0,
  didOpen: void 0,
  didRender: void 0,
  willClose: void 0,
  didClose: void 0,
  didDestroy: void 0,
  scrollbarPadding: !0,
  topLayer: !1,
 },
 WD = [
  "allowEscapeKey",
  "allowOutsideClick",
  "background",
  "buttonsStyling",
  "cancelButtonAriaLabel",
  "cancelButtonColor",
  "cancelButtonText",
  "closeButtonAriaLabel",
  "closeButtonHtml",
  "color",
  "confirmButtonAriaLabel",
  "confirmButtonColor",
  "confirmButtonText",
  "currentProgressStep",
  "customClass",
  "denyButtonAriaLabel",
  "denyButtonColor",
  "denyButtonText",
  "didClose",
  "didDestroy",
  "draggable",
  "footer",
  "hideClass",
  "html",
  "icon",
  "iconColor",
  "iconHtml",
  "imageAlt",
  "imageHeight",
  "imageUrl",
  "imageWidth",
  "preConfirm",
  "preDeny",
  "progressSteps",
  "returnFocus",
  "reverseButtons",
  "showCancelButton",
  "showCloseButton",
  "showConfirmButton",
  "showDenyButton",
  "text",
  "title",
  "titleText",
  "theme",
  "willClose",
 ],
 KD = { allowEnterKey: void 0 },
 JD = [
  "allowOutsideClick",
  "allowEnterKey",
  "backdrop",
  "draggable",
  "focusConfirm",
  "focusDeny",
  "focusCancel",
  "returnFocus",
  "heightAuto",
  "keydownListenerCapture",
 ],
 vC = (t) => Object.prototype.hasOwnProperty.call(ci, t),
 _C = (t) => WD.indexOf(t) !== -1,
 wC = (t) => KD[t],
 YD = (t) => {
  vC(t) || qt(`Unknown parameter "${t}"`);
 },
 QD = (t) => {
  JD.includes(t) && qt(`The parameter "${t}" is incompatible with toasts`);
 },
 XD = (t) => {
  const e = wC(t);
  e && OA(t, e);
 },
 EC = (t) => {
  t.backdrop === !1 &&
   t.allowOutsideClick &&
   qt('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`'),
   t.theme &&
    ![
     "light",
     "dark",
     "auto",
     "minimal",
     "borderless",
     "bootstrap-4",
     "bootstrap-4-light",
     "bootstrap-4-dark",
     "bootstrap-5",
     "bootstrap-5-light",
     "bootstrap-5-dark",
     "material-ui",
     "material-ui-light",
     "material-ui-dark",
     "embed-iframe",
     "bulma",
     "bulma-light",
     "bulma-dark",
    ].includes(t.theme) &&
    qt(`Invalid theme "${t.theme}"`);
  for (const e in t) YD(e), t.toast && QD(e), XD(e);
 };
function TC(t) {
 const e = Kt(),
  n = _e(),
  r = Pe.innerParams.get(this);
 if (!n || Sr(n, r.hideClass.popup)) {
  qt(
   "You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup."
  );
  return;
 }
 const i = jD(t),
  o = Object.assign({}, r, i);
 EC(o),
  e && (e.dataset.swal2Theme = o.theme),
  jA(this, o),
  Pe.innerParams.set(this, o),
  Object.defineProperties(this, { params: { value: Object.assign({}, this.params, t), writable: !1, enumerable: !0 } });
}
const jD = (t) => {
 const e = {};
 return (
  Object.keys(t).forEach((n) => {
   if (_C(n)) {
    const r = t;
    e[n] = r[n];
   } else qt(`Invalid parameter to update: ${n}`);
  }),
  e
 );
};
function IC() {
 var t;
 const e = Pe.domCache.get(this),
  n = Pe.innerParams.get(this);
 if (!n) {
  SC(this);
  return;
 }
 e.popup &&
  X.swalCloseEventFinishedCallback &&
  (X.swalCloseEventFinishedCallback(), delete X.swalCloseEventFinishedCallback),
  typeof n.didDestroy == "function" && n.didDestroy(),
  (t = X.eventEmitter) === null || t === void 0 || t.emit("didDestroy"),
  ZD(this);
}
const ZD = (t) => {
  SC(t), delete t.params, delete X.keydownHandler, delete X.keydownTarget, delete X.currentInstance;
 },
 SC = (t) => {
  t.isAwaitingPromise
   ? (xh(Pe, t), (t.isAwaitingPromise = !0))
   : (xh(Cs, t),
     xh(Pe, t),
     delete t.isAwaitingPromise,
     delete t.disableButtons,
     delete t.enableButtons,
     delete t.getInput,
     delete t.disableInput,
     delete t.enableInput,
     delete t.hideLoading,
     delete t.disableLoading,
     delete t.showValidationMessage,
     delete t.resetValidationMessage,
     delete t.close,
     delete t.closePopup,
     delete t.closeModal,
     delete t.closeToast,
     delete t.rejectPromise,
     delete t.update,
     delete t._destroy);
 },
 xh = (t, e) => {
  for (const n in t) t[n].delete(e);
 };
var eL = Object.freeze({
 __proto__: null,
 _destroy: IC,
 close: ui,
 closeModal: ui,
 closePopup: ui,
 closeToast: ui,
 disableButtons: hC,
 disableInput: mC,
 disableLoading: ad,
 enableButtons: fC,
 enableInput: pC,
 getInput: uC,
 handleAwaitingPromise: Hl,
 hideLoading: ad,
 rejectPromise: oC,
 resetValidationMessage: yC,
 showValidationMessage: gC,
 update: TC,
});
const tL = (t, e, n) => {
  t.toast ? nL(t, e, n) : (iL(e), oL(e), sL(t, e, n));
 },
 nL = (t, e, n) => {
  e.popup.onclick = () => {
   (t && (rL(t) || t.timer || t.input)) || n(qs.close);
  };
 },
 rL = (t) => !!(t.showConfirmButton || t.showDenyButton || t.showCancelButton || t.showCloseButton);
let ld = !1;
const iL = (t) => {
  t.popup.onmousedown = () => {
   t.container.onmouseup = function (e) {
    (t.container.onmouseup = () => {}), e.target === t.container && (ld = !0);
   };
  };
 },
 oL = (t) => {
  t.container.onmousedown = (e) => {
   e.target === t.container && e.preventDefault(),
    (t.popup.onmouseup = function (n) {
     (t.popup.onmouseup = () => {}),
      (n.target === t.popup || (n.target instanceof HTMLElement && t.popup.contains(n.target))) && (ld = !0);
    });
  };
 },
 sL = (t, e, n) => {
  e.container.onclick = (r) => {
   if (ld) {
    ld = !1;
    return;
   }
   r.target === e.container && jd(t.allowOutsideClick) && n(qs.backdrop);
  };
 },
 aL = (t) => typeof t == "object" && t.jquery,
 Qw = (t) => t instanceof Element || aL(t),
 lL = (t) => {
  const e = {};
  return (
   typeof t[0] == "object" && !Qw(t[0])
    ? Object.assign(e, t[0])
    : ["title", "html", "icon"].forEach((n, r) => {
       const i = t[r];
       typeof i == "string" || Qw(i)
        ? (e[n] = i)
        : i !== void 0 && Co(`Unexpected type of ${n}! Expected "string" or "Element", got ${typeof i}`);
      }),
   e
  );
 };
function uL(...t) {
 return new this(...t);
}
function cL(t) {
 class e extends this {
  _main(r, i) {
   return super._main(r, Object.assign({}, t, i));
  }
 }
 return e;
}
const dL = () => X.timeout && X.timeout.getTimerLeft(),
 AC = () => {
  if (X.timeout) return w1(), X.timeout.stop();
 },
 CC = () => {
  if (X.timeout) {
   const t = X.timeout.start();
   return Xg(t), t;
  }
 },
 fL = () => {
  const t = X.timeout;
  return t && (t.running ? AC() : CC());
 },
 hL = (t) => {
  if (X.timeout) {
   const e = X.timeout.increase(t);
   return Xg(e, !0), e;
  }
 },
 pL = () => !!(X.timeout && X.timeout.isRunning());
let Xw = !1;
const tm = {};
function mL(t = "data-swal-template") {
 (tm[t] = this), Xw || (document.body.addEventListener("click", gL), (Xw = !0));
}
const gL = (t) => {
 for (let e = t.target; e && e !== document; e = e.parentNode)
  for (const n in tm) {
   const r = e.getAttribute && e.getAttribute(n);
   if (r) {
    tm[n].fire({ template: r });
    return;
   }
  }
};
class yL {
 constructor() {
  this.events = {};
 }
 _getHandlersByEventName(e) {
  return typeof this.events[e] > "u" && (this.events[e] = []), this.events[e];
 }
 on(e, n) {
  const r = this._getHandlersByEventName(e);
  r.includes(n) || r.push(n);
 }
 once(e, n) {
  const r = (...i) => {
   this.removeListener(e, r), n.apply(this, i);
  };
  this.on(e, r);
 }
 emit(e, ...n) {
  this._getHandlersByEventName(e).forEach((r) => {
   try {
    r.apply(this, n);
   } catch (i) {
    console.error(i);
   }
  });
 }
 removeListener(e, n) {
  const r = this._getHandlersByEventName(e),
   i = r.indexOf(n);
  i > -1 && r.splice(i, 1);
 }
 removeAllListeners(e) {
  this.events[e] !== void 0 && (this.events[e].length = 0);
 }
 reset() {
  this.events = {};
 }
}
X.eventEmitter = new yL();
const vL = (t, e) => {
  X.eventEmitter && X.eventEmitter.on(t, e);
 },
 _L = (t, e) => {
  X.eventEmitter && X.eventEmitter.once(t, e);
 },
 wL = (t, e) => {
  if (X.eventEmitter) {
   if (!t) {
    X.eventEmitter.reset();
    return;
   }
   e ? X.eventEmitter.removeListener(t, e) : X.eventEmitter.removeAllListeners(t);
  }
 };
var EL = Object.freeze({
 __proto__: null,
 argsToParams: lL,
 bindClickHandler: mL,
 clickCancel: lD,
 clickConfirm: ZA,
 clickDeny: aD,
 enableLoading: Rs,
 fire: uL,
 getActions: Fl,
 getCancelButton: $s,
 getCloseButton: Kg,
 getConfirmButton: lr,
 getContainer: Kt,
 getDenyButton: Ro,
 getFocusableElements: Jg,
 getFooter: $A,
 getHtmlContainer: zg,
 getIcon: Bs,
 getIconContent: h1,
 getImage: BA,
 getInputLabel: p1,
 getLoader: Hs,
 getPopup: _e,
 getProgressSteps: Wg,
 getTimerLeft: dL,
 getTimerProgressBar: ef,
 getTitle: FA,
 getValidationMessage: Zd,
 increaseTimer: hL,
 isDeprecatedParameter: wC,
 isLoading: g1,
 isTimerRunning: pL,
 isUpdatableParameter: _C,
 isValidParameter: vC,
 isVisible: sD,
 mixin: cL,
 off: wL,
 on: vL,
 once: _L,
 resumeTimer: CC,
 showLoading: Rs,
 stopTimer: AC,
 toggleTimer: fL,
});
class TL {
 constructor(e, n) {
  (this.callback = e), (this.remaining = n), (this.running = !1), this.start();
 }
 start() {
  return (
   this.running ||
    ((this.running = !0), (this.started = new Date()), (this.id = setTimeout(this.callback, this.remaining))),
   this.remaining
  );
 }
 stop() {
  return (
   this.started &&
    this.running &&
    ((this.running = !1), clearTimeout(this.id), (this.remaining -= new Date().getTime() - this.started.getTime())),
   this.remaining
  );
 }
 increase(e) {
  const n = this.running;
  return n && this.stop(), (this.remaining += e), n && this.start(), this.remaining;
 }
 getTimerLeft() {
  return this.running && (this.stop(), this.start()), this.remaining;
 }
 isRunning() {
  return this.running;
 }
}
const RC = ["swal-title", "swal-html", "swal-footer"],
 IL = (t) => {
  const e = typeof t.template == "string" ? document.querySelector(t.template) : t.template;
  if (!e) return {};
  const n = e.content;
  return NL(n), Object.assign(SL(n), AL(n), CL(n), RL(n), PL(n), kL(n), bL(n, RC));
 },
 SL = (t) => {
  const e = {};
  return (
   Array.from(t.querySelectorAll("swal-param")).forEach((r) => {
    ho(r, ["name", "value"]);
    const i = r.getAttribute("name"),
     o = r.getAttribute("value");
    !i ||
     !o ||
     (i in ci && typeof ci[i] == "boolean"
      ? (e[i] = o !== "false")
      : i in ci && typeof ci[i] == "object"
        ? (e[i] = JSON.parse(o))
        : (e[i] = o));
   }),
   e
  );
 },
 AL = (t) => {
  const e = {};
  return (
   Array.from(t.querySelectorAll("swal-function-param")).forEach((r) => {
    const i = r.getAttribute("name"),
     o = r.getAttribute("value");
    !i || !o || (e[i] = new Function(`return ${o}`)());
   }),
   e
  );
 },
 CL = (t) => {
  const e = {};
  return (
   Array.from(t.querySelectorAll("swal-button")).forEach((r) => {
    ho(r, ["type", "color", "aria-label"]);
    const i = r.getAttribute("type");
    if (!(!i || !["confirm", "cancel", "deny"].includes(i))) {
     if (((e[`${i}ButtonText`] = r.innerHTML), (e[`show${Hg(i)}Button`] = !0), r.hasAttribute("color"))) {
      const o = r.getAttribute("color");
      o !== null && (e[`${i}ButtonColor`] = o);
     }
     if (r.hasAttribute("aria-label")) {
      const o = r.getAttribute("aria-label");
      o !== null && (e[`${i}ButtonAriaLabel`] = o);
     }
    }
   }),
   e
  );
 },
 RL = (t) => {
  const e = {},
   n = t.querySelector("swal-image");
  return (
   n &&
    (ho(n, ["src", "width", "height", "alt"]),
    n.hasAttribute("src") && (e.imageUrl = n.getAttribute("src") || void 0),
    n.hasAttribute("width") && (e.imageWidth = n.getAttribute("width") || void 0),
    n.hasAttribute("height") && (e.imageHeight = n.getAttribute("height") || void 0),
    n.hasAttribute("alt") && (e.imageAlt = n.getAttribute("alt") || void 0)),
   e
  );
 },
 PL = (t) => {
  const e = {},
   n = t.querySelector("swal-icon");
  return (
   n &&
    (ho(n, ["type", "color"]),
    n.hasAttribute("type") && (e.icon = n.getAttribute("type")),
    n.hasAttribute("color") && (e.iconColor = n.getAttribute("color")),
    (e.iconHtml = n.innerHTML)),
   e
  );
 },
 kL = (t) => {
  const e = {},
   n = t.querySelector("swal-input");
  n &&
   (ho(n, ["type", "label", "placeholder", "value"]),
   (e.input = n.getAttribute("type") || "text"),
   n.hasAttribute("label") && (e.inputLabel = n.getAttribute("label")),
   n.hasAttribute("placeholder") && (e.inputPlaceholder = n.getAttribute("placeholder")),
   n.hasAttribute("value") && (e.inputValue = n.getAttribute("value")));
  const r = Array.from(t.querySelectorAll("swal-input-option"));
  return (
   r.length &&
    ((e.inputOptions = {}),
    r.forEach((i) => {
     ho(i, ["value"]);
     const o = i.getAttribute("value");
     if (!o) return;
     const s = i.innerHTML;
     e.inputOptions[o] = s;
    })),
   e
  );
 },
 bL = (t, e) => {
  const n = {};
  for (const r in e) {
   const i = e[r],
    o = t.querySelector(i);
   o && (ho(o, []), (n[i.replace(/^swal-/, "")] = o.innerHTML.trim()));
  }
  return n;
 },
 NL = (t) => {
  const e = RC.concat([
   "swal-param",
   "swal-function-param",
   "swal-button",
   "swal-image",
   "swal-icon",
   "swal-input",
   "swal-input-option",
  ]);
  Array.from(t.children).forEach((n) => {
   const r = n.tagName.toLowerCase();
   e.includes(r) || qt(`Unrecognized element <${r}>`);
  });
 },
 ho = (t, e) => {
  Array.from(t.attributes).forEach((n) => {
   e.indexOf(n.name) === -1 &&
    qt([
     `Unrecognized attribute "${n.name}" on <${t.tagName.toLowerCase()}>.`,
     `${e.length ? `Allowed attributes are: ${e.join(", ")}` : "To set the value, use HTML within the element."}`,
    ]);
  });
 },
 PC = 10,
 xL = (t) => {
  var e, n;
  const r = Kt(),
   i = _e();
  if (!r || !i) return;
  typeof t.willOpen == "function" && t.willOpen(i),
   (e = X.eventEmitter) === null || e === void 0 || e.emit("willOpen", i);
  const s = window.getComputedStyle(document.body).overflowY;
  if (
   (LL(r, i, t),
   setTimeout(() => {
    ML(r, i);
   }, PC),
   Yg() && (DL(r, t.scrollbarPadding !== void 0 ? t.scrollbarPadding : !1, s), gD()),
   !tf() && !X.previousActiveElement && (X.previousActiveElement = document.activeElement),
   typeof t.didOpen == "function")
  ) {
   const a = t.didOpen;
   setTimeout(() => a(i));
  }
  (n = X.eventEmitter) === null || n === void 0 || n.emit("didOpen", i);
 },
 ud = (t) => {
  const e = _e();
  if (!e || t.target !== e) return;
  const n = Kt();
  n &&
   (e.removeEventListener("animationend", ud),
   e.removeEventListener("transitionend", ud),
   (n.style.overflowY = "auto"),
   Rn(n, O["no-transition"]));
 },
 ML = (t, e) => {
  GA(e)
   ? ((t.style.overflowY = "hidden"), e.addEventListener("animationend", ud), e.addEventListener("transitionend", ud))
   : (t.style.overflowY = "auto");
 },
 DL = (t, e, n) => {
  yD(),
   e && n !== "hidden" && SD(n),
   setTimeout(() => {
    t.scrollTop = 0;
   });
 },
 LL = (t, e, n) => {
  var r;
  (r = n.showClass) !== null && r !== void 0 && r.backdrop && ve(t, n.showClass.backdrop),
   n.animation
    ? (e.style.setProperty("opacity", "0", "important"),
      ct(e, "grid"),
      setTimeout(() => {
       var i;
       (i = n.showClass) !== null && i !== void 0 && i.popup && ve(e, n.showClass.popup),
        e.style.removeProperty("opacity");
      }, PC))
    : ct(e, "grid"),
   ve([document.documentElement, document.body], O.shown),
   n.heightAuto && n.backdrop && !n.toast && ve([document.documentElement, document.body], O["height-auto"]);
 };
var jw = {
 email: (t, e) =>
  /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(t)
   ? Promise.resolve()
   : Promise.resolve(e || "Invalid email address"),
 url: (t, e) =>
  /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(t)
   ? Promise.resolve()
   : Promise.resolve(e || "Invalid URL"),
};
function VL(t) {
 t.inputValidator ||
  (t.input === "email" && (t.inputValidator = jw.email), t.input === "url" && (t.inputValidator = jw.url));
}
function UL(t) {
 (!t.target ||
  (typeof t.target == "string" && !document.querySelector(t.target)) ||
  (typeof t.target != "string" && !t.target.appendChild)) &&
  (qt('Target parameter is not valid, defaulting to "body"'), (t.target = "body"));
}
function OL(t) {
 VL(t),
  t.showLoaderOnConfirm &&
   !t.preConfirm &&
   qt(`showLoaderOnConfirm is set to true, but preConfirm is not defined.
showLoaderOnConfirm should be used together with preConfirm, see usage example:
https://sweetalert2.github.io/#ajax-request`),
  UL(t),
  typeof t.title == "string" &&
   (t.title = t.title
    .split(
     `
`
    )
    .join("<br />")),
  P1(t);
}
let Xn;
var Hu = new WeakMap();
class Xe {
 constructor(...e) {
  if ((o1(this, Hu, Promise.resolve({ isConfirmed: !1, isDenied: !1, isDismissed: !0 })), typeof window > "u")) return;
  Xn = this;
  const n = Object.freeze(this.constructor.argsToParams(e));
  (this.params = n), (this.isAwaitingPromise = !1), s1(Hu, this, this._main(Xn.params));
 }
 _main(e, n = {}) {
  if ((EC(Object.assign({}, n, e)), X.currentInstance)) {
   const o = Cs.swalPromiseResolve.get(X.currentInstance),
    { isAwaitingPromise: s } = X.currentInstance;
   X.currentInstance._destroy(), s || o({ isDismissed: !0 }), Yg() && nC();
  }
  X.currentInstance = Xn;
  const r = BL(e, n);
  OL(r), Object.freeze(r), X.timeout && (X.timeout.stop(), delete X.timeout), clearTimeout(X.restoreFocusTimeout);
  const i = $L(Xn);
  return jA(Xn, r), Pe.innerParams.set(Xn, r), FL(Xn, i, r);
 }
 then(e) {
  return Hw(Hu, this).then(e);
 }
 finally(e) {
  return Hw(Hu, this).finally(e);
 }
}
const FL = (t, e, n) =>
  new Promise((r, i) => {
   const o = (s) => {
    t.close({ isDismissed: !0, dismiss: s, isConfirmed: !1, isDenied: !1 });
   };
   Cs.swalPromiseResolve.set(t, r),
    Cs.swalPromiseReject.set(t, i),
    (e.confirmButton.onclick = () => {
     $D(t);
    }),
    (e.denyButton.onclick = () => {
     HD(t);
    }),
    (e.cancelButton.onclick = () => {
     qD(t, o);
    }),
    (e.closeButton.onclick = () => {
     o(qs.close);
    }),
    tL(n, e, o),
    uD(X, n, o),
    xD(t, n),
    xL(n),
    HL(X, n, o),
    qL(e, n),
    setTimeout(() => {
     e.container.scrollTop = 0;
    });
  }),
 BL = (t, e) => {
  const n = IL(t),
   r = Object.assign({}, ci, e, n, t);
  return (
   (r.showClass = Object.assign({}, ci.showClass, r.showClass)),
   (r.hideClass = Object.assign({}, ci.hideClass, r.hideClass)),
   r.animation === !1 && ((r.showClass = { backdrop: "swal2-noanimation" }), (r.hideClass = {})),
   r
  );
 },
 $L = (t) => {
  const e = {
   popup: _e(),
   container: Kt(),
   actions: Fl(),
   confirmButton: lr(),
   denyButton: Ro(),
   cancelButton: $s(),
   loader: Hs(),
   closeButton: Kg(),
   validationMessage: Zd(),
   progressSteps: Wg(),
  };
  return Pe.domCache.set(t, e), e;
 },
 HL = (t, e, n) => {
  const r = ef();
  Dt(r),
   e.timer &&
    ((t.timeout = new TL(() => {
     n("timer"), delete t.timeout;
    }, e.timer)),
    e.timerProgressBar &&
     r &&
     (ct(r),
     pn(r, e, "timerProgressBar"),
     setTimeout(() => {
      t.timeout && t.timeout.running && Xg(e.timer);
     })));
 },
 qL = (t, e) => {
  if (!e.toast) {
   if (!jd(e.allowEnterKey)) {
    OA("allowEnterKey"), WL();
    return;
   }
   GL(t) || zL(t, e) || em(-1, 1);
  }
 },
 GL = (t) => {
  const e = Array.from(t.popup.querySelectorAll("[autofocus]"));
  for (const n of e) if (n instanceof HTMLElement && nn(n)) return n.focus(), !0;
  return !1;
 },
 zL = (t, e) =>
  e.focusDeny && nn(t.denyButton)
   ? (t.denyButton.focus(), !0)
   : e.focusCancel && nn(t.cancelButton)
     ? (t.cancelButton.focus(), !0)
     : e.focusConfirm && nn(t.confirmButton)
       ? (t.confirmButton.focus(), !0)
       : !1,
 WL = () => {
  document.activeElement instanceof HTMLElement &&
   typeof document.activeElement.blur == "function" &&
   document.activeElement.blur();
 };
Xe.prototype.disableButtons = hC;
Xe.prototype.enableButtons = fC;
Xe.prototype.getInput = uC;
Xe.prototype.disableInput = mC;
Xe.prototype.enableInput = pC;
Xe.prototype.hideLoading = ad;
Xe.prototype.disableLoading = ad;
Xe.prototype.showValidationMessage = gC;
Xe.prototype.resetValidationMessage = yC;
Xe.prototype.close = ui;
Xe.prototype.closePopup = ui;
Xe.prototype.closeModal = ui;
Xe.prototype.closeToast = ui;
Xe.prototype.rejectPromise = oC;
Xe.prototype.update = TC;
Xe.prototype._destroy = IC;
Object.assign(Xe, EL);
Object.keys(eL).forEach((t) => {
 Xe[t] = function (...e) {
  if (Xn && Xn[t]) return Xn[t](...e);
 };
});
Xe.DismissReason = qs;
Xe.version = "11.26.17";
const vl = Xe;
vl.default = vl;
typeof document < "u" &&
 (function (t, e) {
  var n = t.createElement("style");
  if ((t.getElementsByTagName("head")[0].appendChild(n), n.styleSheet))
   n.styleSheet.disabled || (n.styleSheet.cssText = e);
  else
   try {
    n.innerHTML = e;
   } catch {
    n.innerText = e;
   }
 })(
  document,
  ':root{--swal2-outline: 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-backdrop-transition: background-color 0.15s;--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-icon-zoom: 1;--swal2-icon-animations: true;--swal2-title-padding: 0.8em 1em 0;--swal2-html-container-padding: 1em 1.6em 0.3em;--swal2-input-border: 1px solid #d9d9d9;--swal2-input-border-radius: 0.1875em;--swal2-input-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-background: transparent;--swal2-input-transition: border-color 0.2s, box-shadow 0.2s;--swal2-input-hover-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-focus-border: 1px solid #b4dbed;--swal2-input-focus-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-footer-border-color: #eee;--swal2-footer-background: transparent;--swal2-footer-color: inherit;--swal2-timer-progress-bar-background: rgba(0, 0, 0, 0.3);--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc;--swal2-close-button-transition: color 0.2s, box-shadow 0.2s;--swal2-close-button-outline: initial;--swal2-close-button-box-shadow: inset 0 0 0 3px transparent;--swal2-close-button-focus-box-shadow: inset var(--swal2-outline);--swal2-close-button-hover-transform: none;--swal2-actions-justify-content: center;--swal2-actions-width: auto;--swal2-actions-margin: 1.25em auto 0;--swal2-actions-padding: 0;--swal2-actions-border-radius: 0;--swal2-actions-background: transparent;--swal2-action-button-transition: background-color 0.2s, box-shadow 0.2s;--swal2-action-button-hover: black 10%;--swal2-action-button-active: black 10%;--swal2-confirm-button-box-shadow: none;--swal2-confirm-button-border-radius: 0.25em;--swal2-confirm-button-background-color: #7066e0;--swal2-confirm-button-color: #fff;--swal2-deny-button-box-shadow: none;--swal2-deny-button-border-radius: 0.25em;--swal2-deny-button-background-color: #dc3741;--swal2-deny-button-color: #fff;--swal2-cancel-button-box-shadow: none;--swal2-cancel-button-border-radius: 0.25em;--swal2-cancel-button-background-color: #6e7881;--swal2-cancel-button-color: #fff;--swal2-toast-show-animation: swal2-toast-show 0.5s;--swal2-toast-hide-animation: swal2-toast-hide 0.1s forwards;--swal2-toast-border: none;--swal2-toast-box-shadow: 0 0 1px hsl(0deg 0% 0% / 0.075), 0 1px 2px hsl(0deg 0% 0% / 0.075), 1px 2px 4px hsl(0deg 0% 0% / 0.075), 1px 3px 8px hsl(0deg 0% 0% / 0.075), 2px 4px 16px hsl(0deg 0% 0% / 0.075)}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:var(--swal2-backdrop-transition);-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container)[popover]{width:auto;border:0}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem;container-name:swal2-popup}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:var(--swal2-title-padding);color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;overflow-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:var(--swal2-actions-justify-content);width:var(--swal2-actions-width);margin:var(--swal2-actions-margin);padding:var(--swal2-actions-padding);border-radius:var(--swal2-actions-border-radius);background:var(--swal2-actions-background)}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:var(--swal2-action-button-transition);border:none;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border-radius:var(--swal2-confirm-button-border-radius);background:initial;background-color:var(--swal2-confirm-button-background-color);box-shadow:var(--swal2-confirm-button-box-shadow);color:var(--swal2-confirm-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):hover{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):active{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border-radius:var(--swal2-deny-button-border-radius);background:initial;background-color:var(--swal2-deny-button-background-color);box-shadow:var(--swal2-deny-button-box-shadow);color:var(--swal2-deny-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):hover{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):active{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border-radius:var(--swal2-cancel-button-border-radius);background:initial;background-color:var(--swal2-cancel-button-background-color);box-shadow:var(--swal2-cancel-button-box-shadow);color:var(--swal2-cancel-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):hover{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):active{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none;box-shadow:var(--swal2-action-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-styled)[disabled]:not(.swal2-loading){opacity:.4}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);background:var(--swal2-footer-background);color:var(--swal2-footer-color);font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:var(--swal2-timer-progress-bar-background)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:var(--swal2-close-button-transition);border:none;border-radius:var(--swal2-border-radius);outline:var(--swal2-close-button-outline);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:var(--swal2-close-button-hover-transform);background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:var(--swal2-close-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:var(--swal2-html-container-padding);overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;overflow-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:var(--swal2-input-transition);border:var(--swal2-input-border);border-radius:var(--swal2-input-border-radius);background:var(--swal2-input-background);box-shadow:var(--swal2-input-box-shadow);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):hover,div:where(.swal2-container) input:where(.swal2-file):hover,div:where(.swal2-container) textarea:where(.swal2-textarea):hover{box-shadow:var(--swal2-input-hover-box-shadow)}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:var(--swal2-input-focus-border);outline:none;box-shadow:var(--swal2-input-focus-box-shadow)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;zoom:var(--swal2-icon-zoom);border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;border:var(--swal2-toast-border);background:var(--swal2-background);box-shadow:var(--swal2-toast-box-shadow);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}@container swal2-popup style(--swal2-icon-animations:true){.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}}.swal2-toast.swal2-show{animation:var(--swal2-toast-show-animation)}.swal2-toast.swal2-hide{animation:var(--swal2-toast-hide-animation)}@keyframes swal2-show{0%{transform:translate3d(0, -50px, 0) scale(0.9);opacity:0}100%{transform:translate3d(0, 0, 0) scale(1);opacity:1}}@keyframes swal2-hide{0%{transform:translate3d(0, 0, 0) scale(1);opacity:1}100%{transform:translate3d(0, -50px, 0) scale(0.9);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}'
 );
var Zw = {};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const kC = function (t) {
  const e = [];
  let n = 0;
  for (let r = 0; r < t.length; r++) {
   let i = t.charCodeAt(r);
   i < 128
    ? (e[n++] = i)
    : i < 2048
      ? ((e[n++] = (i >> 6) | 192), (e[n++] = (i & 63) | 128))
      : (i & 64512) === 55296 && r + 1 < t.length && (t.charCodeAt(r + 1) & 64512) === 56320
        ? ((i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++r) & 1023)),
          (e[n++] = (i >> 18) | 240),
          (e[n++] = ((i >> 12) & 63) | 128),
          (e[n++] = ((i >> 6) & 63) | 128),
          (e[n++] = (i & 63) | 128))
        : ((e[n++] = (i >> 12) | 224), (e[n++] = ((i >> 6) & 63) | 128), (e[n++] = (i & 63) | 128));
  }
  return e;
 },
 KL = function (t) {
  const e = [];
  let n = 0,
   r = 0;
  for (; n < t.length; ) {
   const i = t[n++];
   if (i < 128) e[r++] = String.fromCharCode(i);
   else if (i > 191 && i < 224) {
    const o = t[n++];
    e[r++] = String.fromCharCode(((i & 31) << 6) | (o & 63));
   } else if (i > 239 && i < 365) {
    const o = t[n++],
     s = t[n++],
     a = t[n++],
     l = (((i & 7) << 18) | ((o & 63) << 12) | ((s & 63) << 6) | (a & 63)) - 65536;
    (e[r++] = String.fromCharCode(55296 + (l >> 10))), (e[r++] = String.fromCharCode(56320 + (l & 1023)));
   } else {
    const o = t[n++],
     s = t[n++];
    e[r++] = String.fromCharCode(((i & 15) << 12) | ((o & 63) << 6) | (s & 63));
   }
  }
  return e.join("");
 },
 bC = {
  byteToCharMap_: null,
  charToByteMap_: null,
  byteToCharMapWebSafe_: null,
  charToByteMapWebSafe_: null,
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  get ENCODED_VALS() {
   return this.ENCODED_VALS_BASE + "+/=";
  },
  get ENCODED_VALS_WEBSAFE() {
   return this.ENCODED_VALS_BASE + "-_.";
  },
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  encodeByteArray(t, e) {
   if (!Array.isArray(t)) throw Error("encodeByteArray takes an array as a parameter");
   this.init_();
   const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
    r = [];
   for (let i = 0; i < t.length; i += 3) {
    const o = t[i],
     s = i + 1 < t.length,
     a = s ? t[i + 1] : 0,
     l = i + 2 < t.length,
     u = l ? t[i + 2] : 0,
     h = o >> 2,
     p = ((o & 3) << 4) | (a >> 4);
    let m = ((a & 15) << 2) | (u >> 6),
     v = u & 63;
    l || ((v = 64), s || (m = 64)), r.push(n[h], n[p], n[m], n[v]);
   }
   return r.join("");
  },
  encodeString(t, e) {
   return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(kC(t), e);
  },
  decodeString(t, e) {
   return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : KL(this.decodeStringToByteArray(t, e));
  },
  decodeStringToByteArray(t, e) {
   this.init_();
   const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
    r = [];
   for (let i = 0; i < t.length; ) {
    const o = n[t.charAt(i++)],
     a = i < t.length ? n[t.charAt(i)] : 0;
    ++i;
    const u = i < t.length ? n[t.charAt(i)] : 64;
    ++i;
    const p = i < t.length ? n[t.charAt(i)] : 64;
    if ((++i, o == null || a == null || u == null || p == null)) throw new JL();
    const m = (o << 2) | (a >> 4);
    if ((r.push(m), u !== 64)) {
     const v = ((a << 4) & 240) | (u >> 2);
     if ((r.push(v), p !== 64)) {
      const w = ((u << 6) & 192) | p;
      r.push(w);
     }
    }
   }
   return r;
  },
  init_() {
   if (!this.byteToCharMap_) {
    (this.byteToCharMap_ = {}),
     (this.charToByteMap_ = {}),
     (this.byteToCharMapWebSafe_ = {}),
     (this.charToByteMapWebSafe_ = {});
    for (let t = 0; t < this.ENCODED_VALS.length; t++)
     (this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t)),
      (this.charToByteMap_[this.byteToCharMap_[t]] = t),
      (this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t)),
      (this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t),
      t >= this.ENCODED_VALS_BASE.length &&
       ((this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t),
       (this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t));
   }
  },
 };
class JL extends Error {
 constructor() {
  super(...arguments), (this.name = "DecodeBase64StringError");
 }
}
const YL = function (t) {
  const e = kC(t);
  return bC.encodeByteArray(e, !0);
 },
 cd = function (t) {
  return YL(t).replace(/\./g, "");
 },
 NC = function (t) {
  try {
   return bC.decodeString(t, !0);
  } catch (e) {
   console.error("base64Decode failed: ", e);
  }
  return null;
 };
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function QL() {
 if (typeof self < "u") return self;
 if (typeof window < "u") return window;
 if (typeof global < "u") return global;
 throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const XL = () => QL().__FIREBASE_DEFAULTS__,
 jL = () => {
  if (typeof process > "u" || typeof Zw > "u") return;
  const t = Zw.__FIREBASE_DEFAULTS__;
  if (t) return JSON.parse(t);
 },
 ZL = () => {
  if (typeof document > "u") return;
  let t;
  try {
   t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
   return;
  }
  const e = t && NC(t[1]);
  return e && JSON.parse(e);
 },
 rf = () => {
  try {
   return XL() || jL() || ZL();
  } catch (t) {
   console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
   return;
  }
 },
 xC = (t) => {
  var e, n;
  return (n = (e = rf()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || n === void 0 ? void 0 : n[t];
 },
 MC = (t) => {
  const e = xC(t);
  if (!e) return;
  const n = e.lastIndexOf(":");
  if (n <= 0 || n + 1 === e.length) throw new Error(`Invalid host ${e} with no separate hostname and port!`);
  const r = parseInt(e.substring(n + 1), 10);
  return e[0] === "[" ? [e.substring(1, n - 1), r] : [e.substring(0, n), r];
 },
 DC = () => {
  var t;
  return (t = rf()) === null || t === void 0 ? void 0 : t.config;
 },
 LC = (t) => {
  var e;
  return (e = rf()) === null || e === void 0 ? void 0 : e[`_${t}`];
 };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class eV {
 constructor() {
  (this.reject = () => {}),
   (this.resolve = () => {}),
   (this.promise = new Promise((e, n) => {
    (this.resolve = e), (this.reject = n);
   }));
 }
 wrapCallback(e) {
  return (n, r) => {
   n ? this.reject(n) : this.resolve(r),
    typeof e == "function" && (this.promise.catch(() => {}), e.length === 1 ? e(n) : e(n, r));
  };
 }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function VC(t, e) {
 if (t.uid)
  throw new Error(
   'The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'
  );
 const n = { alg: "none", type: "JWT" },
  r = e || "demo-project",
  i = t.iat || 0,
  o = t.sub || t.user_id;
 if (!o) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
 const s = Object.assign(
  {
   iss: `https://securetoken.google.com/${r}`,
   aud: r,
   iat: i,
   exp: i + 3600,
   auth_time: i,
   sub: o,
   user_id: o,
   firebase: { sign_in_provider: "custom", identities: {} },
  },
  t
 );
 return [cd(JSON.stringify(n)), cd(JSON.stringify(s)), ""].join(".");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Lt() {
 return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : "";
}
function tV() {
 return (
  typeof window < "u" &&
  !!(window.cordova || window.phonegap || window.PhoneGap) &&
  /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Lt())
 );
}
function nV() {
 var t;
 const e = (t = rf()) === null || t === void 0 ? void 0 : t.forceEnvironment;
 if (e === "node") return !0;
 if (e === "browser") return !1;
 try {
  return Object.prototype.toString.call(global.process) === "[object process]";
 } catch {
  return !1;
 }
}
function rV() {
 return typeof navigator < "u" && navigator.userAgent === "Cloudflare-Workers";
}
function ry() {
 const t = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
 return typeof t == "object" && t.id !== void 0;
}
function iV() {
 return typeof navigator == "object" && navigator.product === "ReactNative";
}
function oV() {
 const t = Lt();
 return t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0;
}
function sV() {
 return (
  !nV() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome")
 );
}
function iy() {
 try {
  return typeof indexedDB == "object";
 } catch {
  return !1;
 }
}
function oy() {
 return new Promise((t, e) => {
  try {
   let n = !0;
   const r = "validate-browser-context-for-indexeddb-analytics-module",
    i = self.indexedDB.open(r);
   (i.onsuccess = () => {
    i.result.close(), n || self.indexedDB.deleteDatabase(r), t(!0);
   }),
    (i.onupgradeneeded = () => {
     n = !1;
    }),
    (i.onerror = () => {
     var o;
     e(((o = i.error) === null || o === void 0 ? void 0 : o.message) || "");
    });
  } catch (n) {
   e(n);
  }
 });
}
function UC() {
 return !(typeof navigator > "u" || !navigator.cookieEnabled);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const aV = "FirebaseError";
class bn extends Error {
 constructor(e, n, r) {
  super(n),
   (this.code = e),
   (this.customData = r),
   (this.name = aV),
   Object.setPrototypeOf(this, bn.prototype),
   Error.captureStackTrace && Error.captureStackTrace(this, Po.prototype.create);
 }
}
class Po {
 constructor(e, n, r) {
  (this.service = e), (this.serviceName = n), (this.errors = r);
 }
 create(e, ...n) {
  const r = n[0] || {},
   i = `${this.service}/${e}`,
   o = this.errors[e],
   s = o ? lV(o, r) : "Error",
   a = `${this.serviceName}: ${s} (${i}).`;
  return new bn(i, a, r);
 }
}
function lV(t, e) {
 return t.replace(uV, (n, r) => {
  const i = e[r];
  return i != null ? String(i) : `<${r}?>`;
 });
}
const uV = /\{\$([^}]+)}/g;
function cV(t) {
 for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;
 return !0;
}
function _l(t, e) {
 if (t === e) return !0;
 const n = Object.keys(t),
  r = Object.keys(e);
 for (const i of n) {
  if (!r.includes(i)) return !1;
  const o = t[i],
   s = e[i];
  if (e0(o) && e0(s)) {
   if (!_l(o, s)) return !1;
  } else if (o !== s) return !1;
 }
 for (const i of r) if (!n.includes(i)) return !1;
 return !0;
}
function e0(t) {
 return t !== null && typeof t == "object";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function ql(t) {
 const e = [];
 for (const [n, r] of Object.entries(t))
  Array.isArray(r)
   ? r.forEach((i) => {
      e.push(encodeURIComponent(n) + "=" + encodeURIComponent(i));
     })
   : e.push(encodeURIComponent(n) + "=" + encodeURIComponent(r));
 return e.length ? "&" + e.join("&") : "";
}
function ba(t) {
 const e = {};
 return (
  t
   .replace(/^\?/, "")
   .split("&")
   .forEach((r) => {
    if (r) {
     const [i, o] = r.split("=");
     e[decodeURIComponent(i)] = decodeURIComponent(o);
    }
   }),
  e
 );
}
function Na(t) {
 const e = t.indexOf("?");
 if (!e) return "";
 const n = t.indexOf("#", e);
 return t.substring(e, n > 0 ? n : void 0);
}
function dV(t, e) {
 const n = new fV(t, e);
 return n.subscribe.bind(n);
}
class fV {
 constructor(e, n) {
  (this.observers = []),
   (this.unsubscribes = []),
   (this.observerCount = 0),
   (this.task = Promise.resolve()),
   (this.finalized = !1),
   (this.onNoObservers = n),
   this.task
    .then(() => {
     e(this);
    })
    .catch((r) => {
     this.error(r);
    });
 }
 next(e) {
  this.forEachObserver((n) => {
   n.next(e);
  });
 }
 error(e) {
  this.forEachObserver((n) => {
   n.error(e);
  }),
   this.close(e);
 }
 complete() {
  this.forEachObserver((e) => {
   e.complete();
  }),
   this.close();
 }
 subscribe(e, n, r) {
  let i;
  if (e === void 0 && n === void 0 && r === void 0) throw new Error("Missing Observer.");
  hV(e, ["next", "error", "complete"]) ? (i = e) : (i = { next: e, error: n, complete: r }),
   i.next === void 0 && (i.next = Mh),
   i.error === void 0 && (i.error = Mh),
   i.complete === void 0 && (i.complete = Mh);
  const o = this.unsubscribeOne.bind(this, this.observers.length);
  return (
   this.finalized &&
    this.task.then(() => {
     try {
      this.finalError ? i.error(this.finalError) : i.complete();
     } catch {}
    }),
   this.observers.push(i),
   o
  );
 }
 unsubscribeOne(e) {
  this.observers === void 0 ||
   this.observers[e] === void 0 ||
   (delete this.observers[e],
   (this.observerCount -= 1),
   this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this));
 }
 forEachObserver(e) {
  if (!this.finalized) for (let n = 0; n < this.observers.length; n++) this.sendOne(n, e);
 }
 sendOne(e, n) {
  this.task.then(() => {
   if (this.observers !== void 0 && this.observers[e] !== void 0)
    try {
     n(this.observers[e]);
    } catch (r) {
     typeof console < "u" && console.error && console.error(r);
    }
  });
 }
 close(e) {
  this.finalized ||
   ((this.finalized = !0),
   e !== void 0 && (this.finalError = e),
   this.task.then(() => {
    (this.observers = void 0), (this.onNoObservers = void 0);
   }));
 }
}
function hV(t, e) {
 if (typeof t != "object" || t === null) return !1;
 for (const n of e) if (n in t && typeof t[n] == "function") return !0;
 return !1;
}
function Mh() {}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const pV = 1e3,
 mV = 2,
 gV = 4 * 60 * 60 * 1e3,
 yV = 0.5;
function t0(t, e = pV, n = mV) {
 const r = e * Math.pow(n, t),
  i = Math.round(yV * r * (Math.random() - 0.5) * 2);
 return Math.min(gV, r + i);
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Se(t) {
 return t && t._delegate ? t._delegate : t;
}
class Pn {
 constructor(e, n, r) {
  (this.name = e),
   (this.instanceFactory = n),
   (this.type = r),
   (this.multipleInstances = !1),
   (this.serviceProps = {}),
   (this.instantiationMode = "LAZY"),
   (this.onInstanceCreated = null);
 }
 setInstantiationMode(e) {
  return (this.instantiationMode = e), this;
 }
 setMultipleInstances(e) {
  return (this.multipleInstances = e), this;
 }
 setServiceProps(e) {
  return (this.serviceProps = e), this;
 }
 setInstanceCreatedCallback(e) {
  return (this.onInstanceCreated = e), this;
 }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Ji = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class vV {
 constructor(e, n) {
  (this.name = e),
   (this.container = n),
   (this.component = null),
   (this.instances = new Map()),
   (this.instancesDeferred = new Map()),
   (this.instancesOptions = new Map()),
   (this.onInitCallbacks = new Map());
 }
 get(e) {
  const n = this.normalizeInstanceIdentifier(e);
  if (!this.instancesDeferred.has(n)) {
   const r = new eV();
   if ((this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize()))
    try {
     const i = this.getOrInitializeService({ instanceIdentifier: n });
     i && r.resolve(i);
    } catch {}
  }
  return this.instancesDeferred.get(n).promise;
 }
 getImmediate(e) {
  var n;
  const r = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier),
   i = (n = e == null ? void 0 : e.optional) !== null && n !== void 0 ? n : !1;
  if (this.isInitialized(r) || this.shouldAutoInitialize())
   try {
    return this.getOrInitializeService({ instanceIdentifier: r });
   } catch (o) {
    if (i) return null;
    throw o;
   }
  else {
   if (i) return null;
   throw Error(`Service ${this.name} is not available`);
  }
 }
 getComponent() {
  return this.component;
 }
 setComponent(e) {
  if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
  if (this.component) throw Error(`Component for ${this.name} has already been provided`);
  if (((this.component = e), !!this.shouldAutoInitialize())) {
   if (wV(e))
    try {
     this.getOrInitializeService({ instanceIdentifier: Ji });
    } catch {}
   for (const [n, r] of this.instancesDeferred.entries()) {
    const i = this.normalizeInstanceIdentifier(n);
    try {
     const o = this.getOrInitializeService({ instanceIdentifier: i });
     r.resolve(o);
    } catch {}
   }
  }
 }
 clearInstance(e = Ji) {
  this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
 }
 async delete() {
  const e = Array.from(this.instances.values());
  await Promise.all([
   ...e.filter((n) => "INTERNAL" in n).map((n) => n.INTERNAL.delete()),
   ...e.filter((n) => "_delete" in n).map((n) => n._delete()),
  ]);
 }
 isComponentSet() {
  return this.component != null;
 }
 isInitialized(e = Ji) {
  return this.instances.has(e);
 }
 getOptions(e = Ji) {
  return this.instancesOptions.get(e) || {};
 }
 initialize(e = {}) {
  const { options: n = {} } = e,
   r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
  if (this.isInitialized(r)) throw Error(`${this.name}(${r}) has already been initialized`);
  if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
  const i = this.getOrInitializeService({ instanceIdentifier: r, options: n });
  for (const [o, s] of this.instancesDeferred.entries()) {
   const a = this.normalizeInstanceIdentifier(o);
   r === a && s.resolve(i);
  }
  return i;
 }
 onInit(e, n) {
  var r;
  const i = this.normalizeInstanceIdentifier(n),
   o = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : new Set();
  o.add(e), this.onInitCallbacks.set(i, o);
  const s = this.instances.get(i);
  return (
   s && e(s, i),
   () => {
    o.delete(e);
   }
  );
 }
 invokeOnInitCallbacks(e, n) {
  const r = this.onInitCallbacks.get(n);
  if (r)
   for (const i of r)
    try {
     i(e, n);
    } catch {}
 }
 getOrInitializeService({ instanceIdentifier: e, options: n = {} }) {
  let r = this.instances.get(e);
  if (
   !r &&
   this.component &&
   ((r = this.component.instanceFactory(this.container, { instanceIdentifier: _V(e), options: n })),
   this.instances.set(e, r),
   this.instancesOptions.set(e, n),
   this.invokeOnInitCallbacks(r, e),
   this.component.onInstanceCreated)
  )
   try {
    this.component.onInstanceCreated(this.container, e, r);
   } catch {}
  return r || null;
 }
 normalizeInstanceIdentifier(e = Ji) {
  return this.component ? (this.component.multipleInstances ? e : Ji) : e;
 }
 shouldAutoInitialize() {
  return !!this.component && this.component.instantiationMode !== "EXPLICIT";
 }
}
function _V(t) {
 return t === Ji ? void 0 : t;
}
function wV(t) {
 return t.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class EV {
 constructor(e) {
  (this.name = e), (this.providers = new Map());
 }
 addComponent(e) {
  const n = this.getProvider(e.name);
  if (n.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
  n.setComponent(e);
 }
 addOrOverwriteComponent(e) {
  this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
 }
 getProvider(e) {
  if (this.providers.has(e)) return this.providers.get(e);
  const n = new vV(e, this);
  return this.providers.set(e, n), n;
 }
 getProviders() {
  return Array.from(this.providers.values());
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var de;
(function (t) {
 (t[(t.DEBUG = 0)] = "DEBUG"),
  (t[(t.VERBOSE = 1)] = "VERBOSE"),
  (t[(t.INFO = 2)] = "INFO"),
  (t[(t.WARN = 3)] = "WARN"),
  (t[(t.ERROR = 4)] = "ERROR"),
  (t[(t.SILENT = 5)] = "SILENT");
})(de || (de = {}));
const TV = { debug: de.DEBUG, verbose: de.VERBOSE, info: de.INFO, warn: de.WARN, error: de.ERROR, silent: de.SILENT },
 IV = de.INFO,
 SV = { [de.DEBUG]: "log", [de.VERBOSE]: "log", [de.INFO]: "info", [de.WARN]: "warn", [de.ERROR]: "error" },
 AV = (t, e, ...n) => {
  if (e < t.logLevel) return;
  const r = new Date().toISOString(),
   i = SV[e];
  if (i) console[i](`[${r}]  ${t.name}:`, ...n);
  else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
 };
class of {
 constructor(e) {
  (this.name = e), (this._logLevel = IV), (this._logHandler = AV), (this._userLogHandler = null);
 }
 get logLevel() {
  return this._logLevel;
 }
 set logLevel(e) {
  if (!(e in de)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
  this._logLevel = e;
 }
 setLogLevel(e) {
  this._logLevel = typeof e == "string" ? TV[e] : e;
 }
 get logHandler() {
  return this._logHandler;
 }
 set logHandler(e) {
  if (typeof e != "function") throw new TypeError("Value assigned to `logHandler` must be a function");
  this._logHandler = e;
 }
 get userLogHandler() {
  return this._userLogHandler;
 }
 set userLogHandler(e) {
  this._userLogHandler = e;
 }
 debug(...e) {
  this._userLogHandler && this._userLogHandler(this, de.DEBUG, ...e), this._logHandler(this, de.DEBUG, ...e);
 }
 log(...e) {
  this._userLogHandler && this._userLogHandler(this, de.VERBOSE, ...e), this._logHandler(this, de.VERBOSE, ...e);
 }
 info(...e) {
  this._userLogHandler && this._userLogHandler(this, de.INFO, ...e), this._logHandler(this, de.INFO, ...e);
 }
 warn(...e) {
  this._userLogHandler && this._userLogHandler(this, de.WARN, ...e), this._logHandler(this, de.WARN, ...e);
 }
 error(...e) {
  this._userLogHandler && this._userLogHandler(this, de.ERROR, ...e), this._logHandler(this, de.ERROR, ...e);
 }
}
const CV = (t, e) => e.some((n) => t instanceof n);
let n0, r0;
function RV() {
 return n0 || (n0 = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
}
function PV() {
 return (
  r0 || (r0 = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
 );
}
const OC = new WeakMap(),
 nm = new WeakMap(),
 FC = new WeakMap(),
 Dh = new WeakMap(),
 sy = new WeakMap();
function kV(t) {
 const e = new Promise((n, r) => {
  const i = () => {
    t.removeEventListener("success", o), t.removeEventListener("error", s);
   },
   o = () => {
    n(Ei(t.result)), i();
   },
   s = () => {
    r(t.error), i();
   };
  t.addEventListener("success", o), t.addEventListener("error", s);
 });
 return (
  e
   .then((n) => {
    n instanceof IDBCursor && OC.set(n, t);
   })
   .catch(() => {}),
  sy.set(e, t),
  e
 );
}
function bV(t) {
 if (nm.has(t)) return;
 const e = new Promise((n, r) => {
  const i = () => {
    t.removeEventListener("complete", o), t.removeEventListener("error", s), t.removeEventListener("abort", s);
   },
   o = () => {
    n(), i();
   },
   s = () => {
    r(t.error || new DOMException("AbortError", "AbortError")), i();
   };
  t.addEventListener("complete", o), t.addEventListener("error", s), t.addEventListener("abort", s);
 });
 nm.set(t, e);
}
let rm = {
 get(t, e, n) {
  if (t instanceof IDBTransaction) {
   if (e === "done") return nm.get(t);
   if (e === "objectStoreNames") return t.objectStoreNames || FC.get(t);
   if (e === "store") return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
  }
  return Ei(t[e]);
 },
 set(t, e, n) {
  return (t[e] = n), !0;
 },
 has(t, e) {
  return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
 },
};
function NV(t) {
 rm = t(rm);
}
function xV(t) {
 return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)
  ? function (e, ...n) {
     const r = t.call(Lh(this), e, ...n);
     return FC.set(r, e.sort ? e.sort() : [e]), Ei(r);
    }
  : PV().includes(t)
    ? function (...e) {
       return t.apply(Lh(this), e), Ei(OC.get(this));
      }
    : function (...e) {
       return Ei(t.apply(Lh(this), e));
      };
}
function MV(t) {
 return typeof t == "function" ? xV(t) : (t instanceof IDBTransaction && bV(t), CV(t, RV()) ? new Proxy(t, rm) : t);
}
function Ei(t) {
 if (t instanceof IDBRequest) return kV(t);
 if (Dh.has(t)) return Dh.get(t);
 const e = MV(t);
 return e !== t && (Dh.set(t, e), sy.set(e, t)), e;
}
const Lh = (t) => sy.get(t);
function BC(t, e, { blocked: n, upgrade: r, blocking: i, terminated: o } = {}) {
 const s = indexedDB.open(t, e),
  a = Ei(s);
 return (
  r &&
   s.addEventListener("upgradeneeded", (l) => {
    r(Ei(s.result), l.oldVersion, l.newVersion, Ei(s.transaction), l);
   }),
  n && s.addEventListener("blocked", (l) => n(l.oldVersion, l.newVersion, l)),
  a
   .then((l) => {
    o && l.addEventListener("close", () => o()),
     i && l.addEventListener("versionchange", (u) => i(u.oldVersion, u.newVersion, u));
   })
   .catch(() => {}),
  a
 );
}
const DV = ["get", "getKey", "getAll", "getAllKeys", "count"],
 LV = ["put", "add", "delete", "clear"],
 Vh = new Map();
function i0(t, e) {
 if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string")) return;
 if (Vh.get(e)) return Vh.get(e);
 const n = e.replace(/FromIndex$/, ""),
  r = e !== n,
  i = LV.includes(n);
 if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || DV.includes(n))) return;
 const o = async function (s, ...a) {
  const l = this.transaction(s, i ? "readwrite" : "readonly");
  let u = l.store;
  return r && (u = u.index(a.shift())), (await Promise.all([u[n](...a), i && l.done]))[0];
 };
 return Vh.set(e, o), o;
}
NV((t) => ({ ...t, get: (e, n, r) => i0(e, n) || t.get(e, n, r), has: (e, n) => !!i0(e, n) || t.has(e, n) }));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class VV {
 constructor(e) {
  this.container = e;
 }
 getPlatformInfoString() {
  return this.container
   .getProviders()
   .map((n) => {
    if (UV(n)) {
     const r = n.getImmediate();
     return `${r.library}/${r.version}`;
    } else return null;
   })
   .filter((n) => n)
   .join(" ");
 }
}
function UV(t) {
 const e = t.getComponent();
 return (e == null ? void 0 : e.type) === "VERSION";
}
const im = "@firebase/app",
 o0 = "0.10.13";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const br = new of("@firebase/app"),
 OV = "@firebase/app-compat",
 FV = "@firebase/analytics-compat",
 BV = "@firebase/analytics",
 $V = "@firebase/app-check-compat",
 HV = "@firebase/app-check",
 qV = "@firebase/auth",
 GV = "@firebase/auth-compat",
 zV = "@firebase/database",
 WV = "@firebase/data-connect",
 KV = "@firebase/database-compat",
 JV = "@firebase/functions",
 YV = "@firebase/functions-compat",
 QV = "@firebase/installations",
 XV = "@firebase/installations-compat",
 jV = "@firebase/messaging",
 ZV = "@firebase/messaging-compat",
 eU = "@firebase/performance",
 tU = "@firebase/performance-compat",
 nU = "@firebase/remote-config",
 rU = "@firebase/remote-config-compat",
 iU = "@firebase/storage",
 oU = "@firebase/storage-compat",
 sU = "@firebase/firestore",
 aU = "@firebase/vertexai-preview",
 lU = "@firebase/firestore-compat",
 uU = "firebase",
 cU = "10.14.1";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const om = "[DEFAULT]",
 dU = {
  [im]: "fire-core",
  [OV]: "fire-core-compat",
  [BV]: "fire-analytics",
  [FV]: "fire-analytics-compat",
  [HV]: "fire-app-check",
  [$V]: "fire-app-check-compat",
  [qV]: "fire-auth",
  [GV]: "fire-auth-compat",
  [zV]: "fire-rtdb",
  [WV]: "fire-data-connect",
  [KV]: "fire-rtdb-compat",
  [JV]: "fire-fn",
  [YV]: "fire-fn-compat",
  [QV]: "fire-iid",
  [XV]: "fire-iid-compat",
  [jV]: "fire-fcm",
  [ZV]: "fire-fcm-compat",
  [eU]: "fire-perf",
  [tU]: "fire-perf-compat",
  [nU]: "fire-rc",
  [rU]: "fire-rc-compat",
  [iU]: "fire-gcs",
  [oU]: "fire-gcs-compat",
  [sU]: "fire-fst",
  [lU]: "fire-fst-compat",
  [aU]: "fire-vertex",
  "fire-js": "fire-js",
  [uU]: "fire-js-all",
 };
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const dd = new Map(),
 fU = new Map(),
 sm = new Map();
function s0(t, e) {
 try {
  t.container.addComponent(e);
 } catch (n) {
  br.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, n);
 }
}
function Hn(t) {
 const e = t.name;
 if (sm.has(e)) return br.debug(`There were multiple attempts to register component ${e}.`), !1;
 sm.set(e, t);
 for (const n of dd.values()) s0(n, t);
 for (const n of fU.values()) s0(n, t);
 return !0;
}
function Mi(t, e) {
 const n = t.container.getProvider("heartbeat").getImmediate({ optional: !0 });
 return n && n.triggerHeartbeat(), t.container.getProvider(e);
}
function Zn(t) {
 return t.settings !== void 0;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const hU = {
  "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
  "bad-app-name": "Illegal App name: '{$appName}'",
  "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "server-app-deleted": "Firebase Server App has been deleted",
  "no-options": "Need to provide options, when not being deployed to hosting via source.",
  "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument": "First argument to `onLog` must be null or a function.",
  "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  "finalization-registry-not-supported":
   "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments.",
 },
 Ti = new Po("app", "Firebase", hU);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class pU {
 constructor(e, n, r) {
  (this._isDeleted = !1),
   (this._options = Object.assign({}, e)),
   (this._config = Object.assign({}, n)),
   (this._name = n.name),
   (this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled),
   (this._container = r),
   this.container.addComponent(new Pn("app", () => this, "PUBLIC"));
 }
 get automaticDataCollectionEnabled() {
  return this.checkDestroyed(), this._automaticDataCollectionEnabled;
 }
 set automaticDataCollectionEnabled(e) {
  this.checkDestroyed(), (this._automaticDataCollectionEnabled = e);
 }
 get name() {
  return this.checkDestroyed(), this._name;
 }
 get options() {
  return this.checkDestroyed(), this._options;
 }
 get config() {
  return this.checkDestroyed(), this._config;
 }
 get container() {
  return this._container;
 }
 get isDeleted() {
  return this._isDeleted;
 }
 set isDeleted(e) {
  this._isDeleted = e;
 }
 checkDestroyed() {
  if (this.isDeleted) throw Ti.create("app-deleted", { appName: this._name });
 }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const ko = cU;
function ay(t, e = {}) {
 let n = t;
 typeof e != "object" && (e = { name: e });
 const r = Object.assign({ name: om, automaticDataCollectionEnabled: !1 }, e),
  i = r.name;
 if (typeof i != "string" || !i) throw Ti.create("bad-app-name", { appName: String(i) });
 if ((n || (n = DC()), !n)) throw Ti.create("no-options");
 const o = dd.get(i);
 if (o) {
  if (_l(n, o.options) && _l(r, o.config)) return o;
  throw Ti.create("duplicate-app", { appName: i });
 }
 const s = new EV(i);
 for (const l of sm.values()) s.addComponent(l);
 const a = new pU(n, r, s);
 return dd.set(i, a), a;
}
function Gl(t = om) {
 const e = dd.get(t);
 if (!e && t === om && DC()) return ay();
 if (!e) throw Ti.create("no-app", { appName: t });
 return e;
}
function rn(t, e, n) {
 var r;
 let i = (r = dU[t]) !== null && r !== void 0 ? r : t;
 n && (i += `-${n}`);
 const o = i.match(/\s|\//),
  s = e.match(/\s|\//);
 if (o || s) {
  const a = [`Unable to register library "${i}" with version "${e}":`];
  o && a.push(`library name "${i}" contains illegal characters (whitespace or "/")`),
   o && s && a.push("and"),
   s && a.push(`version name "${e}" contains illegal characters (whitespace or "/")`),
   br.warn(a.join(" "));
  return;
 }
 Hn(new Pn(`${i}-version`, () => ({ library: i, version: e }), "VERSION"));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const mU = "firebase-heartbeat-database",
 gU = 1,
 wl = "firebase-heartbeat-store";
let Uh = null;
function $C() {
 return (
  Uh ||
   (Uh = BC(mU, gU, {
    upgrade: (t, e) => {
     switch (e) {
      case 0:
       try {
        t.createObjectStore(wl);
       } catch (n) {
        console.warn(n);
       }
     }
    },
   }).catch((t) => {
    throw Ti.create("idb-open", { originalErrorMessage: t.message });
   })),
  Uh
 );
}
async function yU(t) {
 try {
  const n = (await $C()).transaction(wl),
   r = await n.objectStore(wl).get(HC(t));
  return await n.done, r;
 } catch (e) {
  if (e instanceof bn) br.warn(e.message);
  else {
   const n = Ti.create("idb-get", { originalErrorMessage: e == null ? void 0 : e.message });
   br.warn(n.message);
  }
 }
}
async function a0(t, e) {
 try {
  const r = (await $C()).transaction(wl, "readwrite");
  await r.objectStore(wl).put(e, HC(t)), await r.done;
 } catch (n) {
  if (n instanceof bn) br.warn(n.message);
  else {
   const r = Ti.create("idb-set", { originalErrorMessage: n == null ? void 0 : n.message });
   br.warn(r.message);
  }
 }
}
function HC(t) {
 return `${t.name}!${t.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const vU = 1024,
 _U = 30 * 24 * 60 * 60 * 1e3;
class wU {
 constructor(e) {
  (this.container = e), (this._heartbeatsCache = null);
  const n = this.container.getProvider("app").getImmediate();
  (this._storage = new TU(n)),
   (this._heartbeatsCachePromise = this._storage.read().then((r) => ((this._heartbeatsCache = r), r)));
 }
 async triggerHeartbeat() {
  var e, n;
  try {
   const i = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),
    o = l0();
   return (((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null &&
    ((this._heartbeatsCache = await this._heartbeatsCachePromise),
    ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null)) ||
    this._heartbeatsCache.lastSentHeartbeatDate === o ||
    this._heartbeatsCache.heartbeats.some((s) => s.date === o)
    ? void 0
    : (this._heartbeatsCache.heartbeats.push({ date: o, agent: i }),
      (this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((s) => {
       const a = new Date(s.date).valueOf();
       return Date.now() - a <= _U;
      })),
      this._storage.overwrite(this._heartbeatsCache));
  } catch (r) {
   br.warn(r);
  }
 }
 async getHeartbeatsHeader() {
  var e;
  try {
   if (
    (this._heartbeatsCache === null && (await this._heartbeatsCachePromise),
    ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null ||
     this._heartbeatsCache.heartbeats.length === 0)
   )
    return "";
   const n = l0(),
    { heartbeatsToSend: r, unsentEntries: i } = EU(this._heartbeatsCache.heartbeats),
    o = cd(JSON.stringify({ version: 2, heartbeats: r }));
   return (
    (this._heartbeatsCache.lastSentHeartbeatDate = n),
    i.length > 0
     ? ((this._heartbeatsCache.heartbeats = i), await this._storage.overwrite(this._heartbeatsCache))
     : ((this._heartbeatsCache.heartbeats = []), this._storage.overwrite(this._heartbeatsCache)),
    o
   );
  } catch (n) {
   return br.warn(n), "";
  }
 }
}
function l0() {
 return new Date().toISOString().substring(0, 10);
}
function EU(t, e = vU) {
 const n = [];
 let r = t.slice();
 for (const i of t) {
  const o = n.find((s) => s.agent === i.agent);
  if (o) {
   if ((o.dates.push(i.date), u0(n) > e)) {
    o.dates.pop();
    break;
   }
  } else if ((n.push({ agent: i.agent, dates: [i.date] }), u0(n) > e)) {
   n.pop();
   break;
  }
  r = r.slice(1);
 }
 return { heartbeatsToSend: n, unsentEntries: r };
}
class TU {
 constructor(e) {
  (this.app = e), (this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck());
 }
 async runIndexedDBEnvironmentCheck() {
  return iy()
   ? oy()
      .then(() => !0)
      .catch(() => !1)
   : !1;
 }
 async read() {
  if (await this._canUseIndexedDBPromise) {
   const n = await yU(this.app);
   return n != null && n.heartbeats ? n : { heartbeats: [] };
  } else return { heartbeats: [] };
 }
 async overwrite(e) {
  var n;
  if (await this._canUseIndexedDBPromise) {
   const i = await this.read();
   return a0(this.app, {
    lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
    heartbeats: e.heartbeats,
   });
  } else return;
 }
 async add(e) {
  var n;
  if (await this._canUseIndexedDBPromise) {
   const i = await this.read();
   return a0(this.app, {
    lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
    heartbeats: [...i.heartbeats, ...e.heartbeats],
   });
  } else return;
 }
}
function u0(t) {
 return cd(JSON.stringify({ version: 2, heartbeats: t })).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function IU(t) {
 Hn(new Pn("platform-logger", (e) => new VV(e), "PRIVATE")),
  Hn(new Pn("heartbeat", (e) => new wU(e), "PRIVATE")),
  rn(im, o0, t),
  rn(im, o0, "esm2017"),
  rn("fire-js", "");
}
IU("");
var SU = "firebase",
 AU = "10.14.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ rn(SU, AU, "app");
function ly(t, e) {
 var n = {};
 for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
 if (t != null && typeof Object.getOwnPropertySymbols == "function")
  for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
   e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
 return n;
}
function qC() {
 return {
  "dependent-sdk-initialized-before-auth":
   "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.",
 };
}
const CU = qC,
 GC = new Po("auth", "Firebase", qC());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const fd = new of("@firebase/auth");
function RU(t, ...e) {
 fd.logLevel <= de.WARN && fd.warn(`Auth (${ko}): ${t}`, ...e);
}
function _c(t, ...e) {
 fd.logLevel <= de.ERROR && fd.error(`Auth (${ko}): ${t}`, ...e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function qn(t, ...e) {
 throw uy(t, ...e);
}
function rr(t, ...e) {
 return uy(t, ...e);
}
function zC(t, e, n) {
 const r = Object.assign(Object.assign({}, CU()), { [e]: n });
 return new Po("auth", "Firebase", r).create(e, { appName: t.name });
}
function Ar(t) {
 return zC(
  t,
  "operation-not-supported-in-this-environment",
  "Operations that alter the current user are not supported in conjunction with FirebaseServerApp"
 );
}
function uy(t, ...e) {
 if (typeof t != "string") {
  const n = e[0],
   r = [...e.slice(1)];
  return r[0] && (r[0].appName = t.name), t._errorFactory.create(n, ...r);
 }
 return GC.create(t, ...e);
}
function te(t, e, ...n) {
 if (!t) throw uy(e, ...n);
}
function wr(t) {
 const e = "INTERNAL ASSERTION FAILED: " + t;
 throw (_c(e), new Error(e));
}
function Nr(t, e) {
 t || wr(e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function am() {
 var t;
 return (typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.href)) || "";
}
function PU() {
 return c0() === "http:" || c0() === "https:";
}
function c0() {
 var t;
 return (typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.protocol)) || null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function kU() {
 return typeof navigator < "u" &&
  navigator &&
  "onLine" in navigator &&
  typeof navigator.onLine == "boolean" &&
  (PU() || ry() || "connection" in navigator)
  ? navigator.onLine
  : !0;
}
function bU() {
 if (typeof navigator > "u") return null;
 const t = navigator;
 return (t.languages && t.languages[0]) || t.language || null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class zl {
 constructor(e, n) {
  (this.shortDelay = e),
   (this.longDelay = n),
   Nr(n > e, "Short delay should be less than long delay!"),
   (this.isMobile = tV() || iV());
 }
 get() {
  return kU() ? (this.isMobile ? this.longDelay : this.shortDelay) : Math.min(5e3, this.shortDelay);
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function cy(t, e) {
 Nr(t.emulator, "Emulator should always be set here");
 const { url: n } = t.emulator;
 return e ? `${n}${e.startsWith("/") ? e.slice(1) : e}` : n;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class WC {
 static initialize(e, n, r) {
  (this.fetchImpl = e), n && (this.headersImpl = n), r && (this.responseImpl = r);
 }
 static fetch() {
  if (this.fetchImpl) return this.fetchImpl;
  if (typeof self < "u" && "fetch" in self) return self.fetch;
  if (typeof globalThis < "u" && globalThis.fetch) return globalThis.fetch;
  if (typeof fetch < "u") return fetch;
  wr("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
 }
 static headers() {
  if (this.headersImpl) return this.headersImpl;
  if (typeof self < "u" && "Headers" in self) return self.Headers;
  if (typeof globalThis < "u" && globalThis.Headers) return globalThis.Headers;
  if (typeof Headers < "u") return Headers;
  wr(
   "Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill"
  );
 }
 static response() {
  if (this.responseImpl) return this.responseImpl;
  if (typeof self < "u" && "Response" in self) return self.Response;
  if (typeof globalThis < "u" && globalThis.Response) return globalThis.Response;
  if (typeof Response < "u") return Response;
  wr(
   "Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill"
  );
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const NU = {
 CREDENTIAL_MISMATCH: "custom-token-mismatch",
 MISSING_CUSTOM_TOKEN: "internal-error",
 INVALID_IDENTIFIER: "invalid-email",
 MISSING_CONTINUE_URI: "internal-error",
 INVALID_PASSWORD: "wrong-password",
 MISSING_PASSWORD: "missing-password",
 INVALID_LOGIN_CREDENTIALS: "invalid-credential",
 EMAIL_EXISTS: "email-already-in-use",
 PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
 INVALID_IDP_RESPONSE: "invalid-credential",
 INVALID_PENDING_TOKEN: "invalid-credential",
 FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
 MISSING_REQ_TYPE: "internal-error",
 EMAIL_NOT_FOUND: "user-not-found",
 RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
 EXPIRED_OOB_CODE: "expired-action-code",
 INVALID_OOB_CODE: "invalid-action-code",
 MISSING_OOB_CODE: "internal-error",
 CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
 INVALID_ID_TOKEN: "invalid-user-token",
 TOKEN_EXPIRED: "user-token-expired",
 USER_NOT_FOUND: "user-token-expired",
 TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
 PASSWORD_DOES_NOT_MEET_REQUIREMENTS: "password-does-not-meet-requirements",
 INVALID_CODE: "invalid-verification-code",
 INVALID_SESSION_INFO: "invalid-verification-id",
 INVALID_TEMPORARY_PROOF: "invalid-credential",
 MISSING_SESSION_INFO: "missing-verification-id",
 SESSION_EXPIRED: "code-expired",
 MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
 UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
 INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
 ADMIN_ONLY_OPERATION: "admin-restricted-operation",
 INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
 MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
 MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
 MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
 SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
 SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
 BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
 RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
 MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
 INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
 INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
 MISSING_CLIENT_TYPE: "missing-client-type",
 MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
 INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
 INVALID_REQ_TYPE: "invalid-req-type",
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const xU = new zl(3e4, 6e4);
function Di(t, e) {
 return t.tenantId && !e.tenantId ? Object.assign(Object.assign({}, e), { tenantId: t.tenantId }) : e;
}
async function Ur(t, e, n, r, i = {}) {
 return KC(t, i, async () => {
  let o = {},
   s = {};
  r && (e === "GET" ? (s = r) : (o = { body: JSON.stringify(r) }));
  const a = ql(Object.assign({ key: t.config.apiKey }, s)).slice(1),
   l = await t._getAdditionalHeaders();
  (l["Content-Type"] = "application/json"), t.languageCode && (l["X-Firebase-Locale"] = t.languageCode);
  const u = Object.assign({ method: e, headers: l }, o);
  return rV() || (u.referrerPolicy = "no-referrer"), WC.fetch()(JC(t, t.config.apiHost, n, a), u);
 });
}
async function KC(t, e, n) {
 t._canInitEmulator = !1;
 const r = Object.assign(Object.assign({}, NU), e);
 try {
  const i = new DU(t),
   o = await Promise.race([n(), i.promise]);
  i.clearNetworkTimeout();
  const s = await o.json();
  if ("needConfirmation" in s) throw qu(t, "account-exists-with-different-credential", s);
  if (o.ok && !("errorMessage" in s)) return s;
  {
   const a = o.ok ? s.errorMessage : s.error.message,
    [l, u] = a.split(" : ");
   if (l === "FEDERATED_USER_ID_ALREADY_LINKED") throw qu(t, "credential-already-in-use", s);
   if (l === "EMAIL_EXISTS") throw qu(t, "email-already-in-use", s);
   if (l === "USER_DISABLED") throw qu(t, "user-disabled", s);
   const h = r[l] || l.toLowerCase().replace(/[_\s]+/g, "-");
   if (u) throw zC(t, h, u);
   qn(t, h);
  }
 } catch (i) {
  if (i instanceof bn) throw i;
  qn(t, "network-request-failed", { message: String(i) });
 }
}
async function Wl(t, e, n, r, i = {}) {
 const o = await Ur(t, e, n, r, i);
 return "mfaPendingCredential" in o && qn(t, "multi-factor-auth-required", { _serverResponse: o }), o;
}
function JC(t, e, n, r) {
 const i = `${e}${n}?${r}`;
 return t.config.emulator ? cy(t.config, i) : `${t.config.apiScheme}://${i}`;
}
function MU(t) {
 switch (t) {
  case "ENFORCE":
   return "ENFORCE";
  case "AUDIT":
   return "AUDIT";
  case "OFF":
   return "OFF";
  default:
   return "ENFORCEMENT_STATE_UNSPECIFIED";
 }
}
class DU {
 constructor(e) {
  (this.auth = e),
   (this.timer = null),
   (this.promise = new Promise((n, r) => {
    this.timer = setTimeout(() => r(rr(this.auth, "network-request-failed")), xU.get());
   }));
 }
 clearNetworkTimeout() {
  clearTimeout(this.timer);
 }
}
function qu(t, e, n) {
 const r = { appName: t.name };
 n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber);
 const i = rr(t, e, r);
 return (i.customData._tokenResponse = n), i;
}
function d0(t) {
 return t !== void 0 && t.enterprise !== void 0;
}
class LU {
 constructor(e) {
  if (((this.siteKey = ""), (this.recaptchaEnforcementState = []), e.recaptchaKey === void 0))
   throw new Error("recaptchaKey undefined");
  (this.siteKey = e.recaptchaKey.split("/")[3]), (this.recaptchaEnforcementState = e.recaptchaEnforcementState);
 }
 getProviderEnforcementState(e) {
  if (!this.recaptchaEnforcementState || this.recaptchaEnforcementState.length === 0) return null;
  for (const n of this.recaptchaEnforcementState) if (n.provider && n.provider === e) return MU(n.enforcementState);
  return null;
 }
 isProviderEnabled(e) {
  return this.getProviderEnforcementState(e) === "ENFORCE" || this.getProviderEnforcementState(e) === "AUDIT";
 }
}
async function VU(t, e) {
 return Ur(t, "GET", "/v2/recaptchaConfig", Di(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function UU(t, e) {
 return Ur(t, "POST", "/v1/accounts:delete", e);
}
async function YC(t, e) {
 return Ur(t, "POST", "/v1/accounts:lookup", e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Wa(t) {
 if (t)
  try {
   const e = new Date(Number(t));
   if (!isNaN(e.getTime())) return e.toUTCString();
  } catch {}
}
async function OU(t, e = !1) {
 const n = Se(t),
  r = await n.getIdToken(e),
  i = dy(r);
 te(i && i.exp && i.auth_time && i.iat, n.auth, "internal-error");
 const o = typeof i.firebase == "object" ? i.firebase : void 0,
  s = o == null ? void 0 : o.sign_in_provider;
 return {
  claims: i,
  token: r,
  authTime: Wa(Oh(i.auth_time)),
  issuedAtTime: Wa(Oh(i.iat)),
  expirationTime: Wa(Oh(i.exp)),
  signInProvider: s || null,
  signInSecondFactor: (o == null ? void 0 : o.sign_in_second_factor) || null,
 };
}
function Oh(t) {
 return Number(t) * 1e3;
}
function dy(t) {
 const [e, n, r] = t.split(".");
 if (e === void 0 || n === void 0 || r === void 0) return _c("JWT malformed, contained fewer than 3 sections"), null;
 try {
  const i = NC(n);
  return i ? JSON.parse(i) : (_c("Failed to decode base64 JWT payload"), null);
 } catch (i) {
  return _c("Caught error parsing JWT payload as JSON", i == null ? void 0 : i.toString()), null;
 }
}
function f0(t) {
 const e = dy(t);
 return (
  te(e, "internal-error"),
  te(typeof e.exp < "u", "internal-error"),
  te(typeof e.iat < "u", "internal-error"),
  Number(e.exp) - Number(e.iat)
 );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Ps(t, e, n = !1) {
 if (n) return e;
 try {
  return await e;
 } catch (r) {
  throw (r instanceof bn && FU(r) && t.auth.currentUser === t && (await t.auth.signOut()), r);
 }
}
function FU({ code: t }) {
 return t === "auth/user-disabled" || t === "auth/user-token-expired";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class BU {
 constructor(e) {
  (this.user = e), (this.isRunning = !1), (this.timerId = null), (this.errorBackoff = 3e4);
 }
 _start() {
  this.isRunning || ((this.isRunning = !0), this.schedule());
 }
 _stop() {
  this.isRunning && ((this.isRunning = !1), this.timerId !== null && clearTimeout(this.timerId));
 }
 getInterval(e) {
  var n;
  if (e) {
   const r = this.errorBackoff;
   return (this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4)), r;
  } else {
   this.errorBackoff = 3e4;
   const i = ((n = this.user.stsTokenManager.expirationTime) !== null && n !== void 0 ? n : 0) - Date.now() - 3e5;
   return Math.max(0, i);
  }
 }
 schedule(e = !1) {
  if (!this.isRunning) return;
  const n = this.getInterval(e);
  this.timerId = setTimeout(async () => {
   await this.iteration();
  }, n);
 }
 async iteration() {
  try {
   await this.user.getIdToken(!0);
  } catch (e) {
   (e == null ? void 0 : e.code) === "auth/network-request-failed" && this.schedule(!0);
   return;
  }
  this.schedule();
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class lm {
 constructor(e, n) {
  (this.createdAt = e), (this.lastLoginAt = n), this._initializeTime();
 }
 _initializeTime() {
  (this.lastSignInTime = Wa(this.lastLoginAt)), (this.creationTime = Wa(this.createdAt));
 }
 _copy(e) {
  (this.createdAt = e.createdAt), (this.lastLoginAt = e.lastLoginAt), this._initializeTime();
 }
 toJSON() {
  return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt };
 }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function hd(t) {
 var e;
 const n = t.auth,
  r = await t.getIdToken(),
  i = await Ps(t, YC(n, { idToken: r }));
 te(i == null ? void 0 : i.users.length, n, "internal-error");
 const o = i.users[0];
 t._notifyReloadListener(o);
 const s = !((e = o.providerUserInfo) === null || e === void 0) && e.length ? QC(o.providerUserInfo) : [],
  a = HU(t.providerData, s),
  l = t.isAnonymous,
  u = !(t.email && o.passwordHash) && !(a != null && a.length),
  h = l ? u : !1,
  p = {
   uid: o.localId,
   displayName: o.displayName || null,
   photoURL: o.photoUrl || null,
   email: o.email || null,
   emailVerified: o.emailVerified || !1,
   phoneNumber: o.phoneNumber || null,
   tenantId: o.tenantId || null,
   providerData: a,
   metadata: new lm(o.createdAt, o.lastLoginAt),
   isAnonymous: h,
  };
 Object.assign(t, p);
}
async function $U(t) {
 const e = Se(t);
 await hd(e), await e.auth._persistUserIfCurrent(e), e.auth._notifyListenersIfCurrent(e);
}
function HU(t, e) {
 return [...t.filter((r) => !e.some((i) => i.providerId === r.providerId)), ...e];
}
function QC(t) {
 return t.map((e) => {
  var { providerId: n } = e,
   r = ly(e, ["providerId"]);
  return {
   providerId: n,
   uid: r.rawId || "",
   displayName: r.displayName || null,
   email: r.email || null,
   phoneNumber: r.phoneNumber || null,
   photoURL: r.photoUrl || null,
  };
 });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function qU(t, e) {
 const n = await KC(t, {}, async () => {
  const r = ql({ grant_type: "refresh_token", refresh_token: e }).slice(1),
   { tokenApiHost: i, apiKey: o } = t.config,
   s = JC(t, i, "/v1/token", `key=${o}`),
   a = await t._getAdditionalHeaders();
  return (
   (a["Content-Type"] = "application/x-www-form-urlencoded"), WC.fetch()(s, { method: "POST", headers: a, body: r })
  );
 });
 return { accessToken: n.access_token, expiresIn: n.expires_in, refreshToken: n.refresh_token };
}
async function GU(t, e) {
 return Ur(t, "POST", "/v2/accounts:revokeToken", Di(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hs {
 constructor() {
  (this.refreshToken = null), (this.accessToken = null), (this.expirationTime = null);
 }
 get isExpired() {
  return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
 }
 updateFromServerResponse(e) {
  te(e.idToken, "internal-error"),
   te(typeof e.idToken < "u", "internal-error"),
   te(typeof e.refreshToken < "u", "internal-error");
  const n = "expiresIn" in e && typeof e.expiresIn < "u" ? Number(e.expiresIn) : f0(e.idToken);
  this.updateTokensAndExpiration(e.idToken, e.refreshToken, n);
 }
 updateFromIdToken(e) {
  te(e.length !== 0, "internal-error");
  const n = f0(e);
  this.updateTokensAndExpiration(e, null, n);
 }
 async getToken(e, n = !1) {
  return !n && this.accessToken && !this.isExpired
   ? this.accessToken
   : (te(this.refreshToken, e, "user-token-expired"),
     this.refreshToken ? (await this.refresh(e, this.refreshToken), this.accessToken) : null);
 }
 clearRefreshToken() {
  this.refreshToken = null;
 }
 async refresh(e, n) {
  const { accessToken: r, refreshToken: i, expiresIn: o } = await qU(e, n);
  this.updateTokensAndExpiration(r, i, Number(o));
 }
 updateTokensAndExpiration(e, n, r) {
  (this.refreshToken = n || null), (this.accessToken = e || null), (this.expirationTime = Date.now() + r * 1e3);
 }
 static fromJSON(e, n) {
  const { refreshToken: r, accessToken: i, expirationTime: o } = n,
   s = new hs();
  return (
   r && (te(typeof r == "string", "internal-error", { appName: e }), (s.refreshToken = r)),
   i && (te(typeof i == "string", "internal-error", { appName: e }), (s.accessToken = i)),
   o && (te(typeof o == "number", "internal-error", { appName: e }), (s.expirationTime = o)),
   s
  );
 }
 toJSON() {
  return { refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime };
 }
 _assign(e) {
  (this.accessToken = e.accessToken), (this.refreshToken = e.refreshToken), (this.expirationTime = e.expirationTime);
 }
 _clone() {
  return Object.assign(new hs(), this.toJSON());
 }
 _performRefresh() {
  return wr("not implemented");
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Wr(t, e) {
 te(typeof t == "string" || typeof t > "u", "internal-error", { appName: e });
}
class Er {
 constructor(e) {
  var { uid: n, auth: r, stsTokenManager: i } = e,
   o = ly(e, ["uid", "auth", "stsTokenManager"]);
  (this.providerId = "firebase"),
   (this.proactiveRefresh = new BU(this)),
   (this.reloadUserInfo = null),
   (this.reloadListener = null),
   (this.uid = n),
   (this.auth = r),
   (this.stsTokenManager = i),
   (this.accessToken = i.accessToken),
   (this.displayName = o.displayName || null),
   (this.email = o.email || null),
   (this.emailVerified = o.emailVerified || !1),
   (this.phoneNumber = o.phoneNumber || null),
   (this.photoURL = o.photoURL || null),
   (this.isAnonymous = o.isAnonymous || !1),
   (this.tenantId = o.tenantId || null),
   (this.providerData = o.providerData ? [...o.providerData] : []),
   (this.metadata = new lm(o.createdAt || void 0, o.lastLoginAt || void 0));
 }
 async getIdToken(e) {
  const n = await Ps(this, this.stsTokenManager.getToken(this.auth, e));
  return (
   te(n, this.auth, "internal-error"),
   this.accessToken !== n &&
    ((this.accessToken = n), await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)),
   n
  );
 }
 getIdTokenResult(e) {
  return OU(this, e);
 }
 reload() {
  return $U(this);
 }
 _assign(e) {
  this !== e &&
   (te(this.uid === e.uid, this.auth, "internal-error"),
   (this.displayName = e.displayName),
   (this.photoURL = e.photoURL),
   (this.email = e.email),
   (this.emailVerified = e.emailVerified),
   (this.phoneNumber = e.phoneNumber),
   (this.isAnonymous = e.isAnonymous),
   (this.tenantId = e.tenantId),
   (this.providerData = e.providerData.map((n) => Object.assign({}, n))),
   this.metadata._copy(e.metadata),
   this.stsTokenManager._assign(e.stsTokenManager));
 }
 _clone(e) {
  const n = new Er(Object.assign(Object.assign({}, this), { auth: e, stsTokenManager: this.stsTokenManager._clone() }));
  return n.metadata._copy(this.metadata), n;
 }
 _onReload(e) {
  te(!this.reloadListener, this.auth, "internal-error"),
   (this.reloadListener = e),
   this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), (this.reloadUserInfo = null));
 }
 _notifyReloadListener(e) {
  this.reloadListener ? this.reloadListener(e) : (this.reloadUserInfo = e);
 }
 _startProactiveRefresh() {
  this.proactiveRefresh._start();
 }
 _stopProactiveRefresh() {
  this.proactiveRefresh._stop();
 }
 async _updateTokensIfNecessary(e, n = !1) {
  let r = !1;
  e.idToken &&
   e.idToken !== this.stsTokenManager.accessToken &&
   (this.stsTokenManager.updateFromServerResponse(e), (r = !0)),
   n && (await hd(this)),
   await this.auth._persistUserIfCurrent(this),
   r && this.auth._notifyListenersIfCurrent(this);
 }
 async delete() {
  if (Zn(this.auth.app)) return Promise.reject(Ar(this.auth));
  const e = await this.getIdToken();
  return await Ps(this, UU(this.auth, { idToken: e })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut();
 }
 toJSON() {
  return Object.assign(
   Object.assign(
    {
     uid: this.uid,
     email: this.email || void 0,
     emailVerified: this.emailVerified,
     displayName: this.displayName || void 0,
     isAnonymous: this.isAnonymous,
     photoURL: this.photoURL || void 0,
     phoneNumber: this.phoneNumber || void 0,
     tenantId: this.tenantId || void 0,
     providerData: this.providerData.map((e) => Object.assign({}, e)),
     stsTokenManager: this.stsTokenManager.toJSON(),
     _redirectEventId: this._redirectEventId,
    },
    this.metadata.toJSON()
   ),
   { apiKey: this.auth.config.apiKey, appName: this.auth.name }
  );
 }
 get refreshToken() {
  return this.stsTokenManager.refreshToken || "";
 }
 static _fromJSON(e, n) {
  var r, i, o, s, a, l, u, h;
  const p = (r = n.displayName) !== null && r !== void 0 ? r : void 0,
   m = (i = n.email) !== null && i !== void 0 ? i : void 0,
   v = (o = n.phoneNumber) !== null && o !== void 0 ? o : void 0,
   w = (s = n.photoURL) !== null && s !== void 0 ? s : void 0,
   C = (a = n.tenantId) !== null && a !== void 0 ? a : void 0,
   A = (l = n._redirectEventId) !== null && l !== void 0 ? l : void 0,
   T = (u = n.createdAt) !== null && u !== void 0 ? u : void 0,
   _ = (h = n.lastLoginAt) !== null && h !== void 0 ? h : void 0,
   { uid: E, emailVerified: N, isAnonymous: M, providerData: F, stsTokenManager: P } = n;
  te(E && P, e, "internal-error");
  const I = hs.fromJSON(this.name, P);
  te(typeof E == "string", e, "internal-error"),
   Wr(p, e.name),
   Wr(m, e.name),
   te(typeof N == "boolean", e, "internal-error"),
   te(typeof M == "boolean", e, "internal-error"),
   Wr(v, e.name),
   Wr(w, e.name),
   Wr(C, e.name),
   Wr(A, e.name),
   Wr(T, e.name),
   Wr(_, e.name);
  const R = new Er({
   uid: E,
   auth: e,
   email: m,
   emailVerified: N,
   displayName: p,
   isAnonymous: M,
   photoURL: w,
   phoneNumber: v,
   tenantId: C,
   stsTokenManager: I,
   createdAt: T,
   lastLoginAt: _,
  });
  return (
   F && Array.isArray(F) && (R.providerData = F.map((k) => Object.assign({}, k))), A && (R._redirectEventId = A), R
  );
 }
 static async _fromIdTokenResponse(e, n, r = !1) {
  const i = new hs();
  i.updateFromServerResponse(n);
  const o = new Er({ uid: n.localId, auth: e, stsTokenManager: i, isAnonymous: r });
  return await hd(o), o;
 }
 static async _fromGetAccountInfoResponse(e, n, r) {
  const i = n.users[0];
  te(i.localId !== void 0, "internal-error");
  const o = i.providerUserInfo !== void 0 ? QC(i.providerUserInfo) : [],
   s = !(i.email && i.passwordHash) && !(o != null && o.length),
   a = new hs();
  a.updateFromIdToken(r);
  const l = new Er({ uid: i.localId, auth: e, stsTokenManager: a, isAnonymous: s }),
   u = {
    uid: i.localId,
    displayName: i.displayName || null,
    photoURL: i.photoUrl || null,
    email: i.email || null,
    emailVerified: i.emailVerified || !1,
    phoneNumber: i.phoneNumber || null,
    tenantId: i.tenantId || null,
    providerData: o,
    metadata: new lm(i.createdAt, i.lastLoginAt),
    isAnonymous: !(i.email && i.passwordHash) && !(o != null && o.length),
   };
  return Object.assign(l, u), l;
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const h0 = new Map();
function Tr(t) {
 Nr(t instanceof Function, "Expected a class definition");
 let e = h0.get(t);
 return e
  ? (Nr(e instanceof t, "Instance stored in cache mismatched with class"), e)
  : ((e = new t()), h0.set(t, e), e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class XC {
 constructor() {
  (this.type = "NONE"), (this.storage = {});
 }
 async _isAvailable() {
  return !0;
 }
 async _set(e, n) {
  this.storage[e] = n;
 }
 async _get(e) {
  const n = this.storage[e];
  return n === void 0 ? null : n;
 }
 async _remove(e) {
  delete this.storage[e];
 }
 _addListener(e, n) {}
 _removeListener(e, n) {}
}
XC.type = "NONE";
const p0 = XC;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function wc(t, e, n) {
 return `firebase:${t}:${e}:${n}`;
}
class ps {
 constructor(e, n, r) {
  (this.persistence = e), (this.auth = n), (this.userKey = r);
  const { config: i, name: o } = this.auth;
  (this.fullUserKey = wc(this.userKey, i.apiKey, o)),
   (this.fullPersistenceKey = wc("persistence", i.apiKey, o)),
   (this.boundEventHandler = n._onStorageEvent.bind(n)),
   this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
 }
 setCurrentUser(e) {
  return this.persistence._set(this.fullUserKey, e.toJSON());
 }
 async getCurrentUser() {
  const e = await this.persistence._get(this.fullUserKey);
  return e ? Er._fromJSON(this.auth, e) : null;
 }
 removeCurrentUser() {
  return this.persistence._remove(this.fullUserKey);
 }
 savePersistenceForRedirect() {
  return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
 }
 async setPersistence(e) {
  if (this.persistence === e) return;
  const n = await this.getCurrentUser();
  if ((await this.removeCurrentUser(), (this.persistence = e), n)) return this.setCurrentUser(n);
 }
 delete() {
  this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
 }
 static async create(e, n, r = "authUser") {
  if (!n.length) return new ps(Tr(p0), e, r);
  const i = (
   await Promise.all(
    n.map(async (u) => {
     if (await u._isAvailable()) return u;
    })
   )
  ).filter((u) => u);
  let o = i[0] || Tr(p0);
  const s = wc(r, e.config.apiKey, e.name);
  let a = null;
  for (const u of n)
   try {
    const h = await u._get(s);
    if (h) {
     const p = Er._fromJSON(e, h);
     u !== o && (a = p), (o = u);
     break;
    }
   } catch {}
  const l = i.filter((u) => u._shouldAllowMigration);
  return !o._shouldAllowMigration || !l.length
   ? new ps(o, e, r)
   : ((o = l[0]),
     a && (await o._set(s, a.toJSON())),
     await Promise.all(
      n.map(async (u) => {
       if (u !== o)
        try {
         await u._remove(s);
        } catch {}
      })
     ),
     new ps(o, e, r));
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function m0(t) {
 const e = t.toLowerCase();
 if (e.includes("opera/") || e.includes("opr/") || e.includes("opios/")) return "Opera";
 if (tR(e)) return "IEMobile";
 if (e.includes("msie") || e.includes("trident/")) return "IE";
 if (e.includes("edge/")) return "Edge";
 if (jC(e)) return "Firefox";
 if (e.includes("silk/")) return "Silk";
 if (rR(e)) return "Blackberry";
 if (iR(e)) return "Webos";
 if (ZC(e)) return "Safari";
 if ((e.includes("chrome/") || eR(e)) && !e.includes("edge/")) return "Chrome";
 if (nR(e)) return "Android";
 {
  const n = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,
   r = t.match(n);
  if ((r == null ? void 0 : r.length) === 2) return r[1];
 }
 return "Other";
}
function jC(t = Lt()) {
 return /firefox\//i.test(t);
}
function ZC(t = Lt()) {
 const e = t.toLowerCase();
 return e.includes("safari/") && !e.includes("chrome/") && !e.includes("crios/") && !e.includes("android");
}
function eR(t = Lt()) {
 return /crios\//i.test(t);
}
function tR(t = Lt()) {
 return /iemobile/i.test(t);
}
function nR(t = Lt()) {
 return /android/i.test(t);
}
function rR(t = Lt()) {
 return /blackberry/i.test(t);
}
function iR(t = Lt()) {
 return /webos/i.test(t);
}
function fy(t = Lt()) {
 return /iphone|ipad|ipod/i.test(t) || (/macintosh/i.test(t) && /mobile/i.test(t));
}
function zU(t = Lt()) {
 var e;
 return fy(t) && !!(!((e = window.navigator) === null || e === void 0) && e.standalone);
}
function WU() {
 return oV() && document.documentMode === 10;
}
function oR(t = Lt()) {
 return fy(t) || nR(t) || iR(t) || rR(t) || /windows phone/i.test(t) || tR(t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function sR(t, e = []) {
 let n;
 switch (t) {
  case "Browser":
   n = m0(Lt());
   break;
  case "Worker":
   n = `${m0(Lt())}-${t}`;
   break;
  default:
   n = t;
 }
 const r = e.length ? e.join(",") : "FirebaseCore-web";
 return `${n}/JsCore/${ko}/${r}`;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class KU {
 constructor(e) {
  (this.auth = e), (this.queue = []);
 }
 pushCallback(e, n) {
  const r = (o) =>
   new Promise((s, a) => {
    try {
     const l = e(o);
     s(l);
    } catch (l) {
     a(l);
    }
   });
  (r.onAbort = n), this.queue.push(r);
  const i = this.queue.length - 1;
  return () => {
   this.queue[i] = () => Promise.resolve();
  };
 }
 async runMiddleware(e) {
  if (this.auth.currentUser === e) return;
  const n = [];
  try {
   for (const r of this.queue) await r(e), r.onAbort && n.push(r.onAbort);
  } catch (r) {
   n.reverse();
   for (const i of n)
    try {
     i();
    } catch {}
   throw this.auth._errorFactory.create("login-blocked", { originalMessage: r == null ? void 0 : r.message });
  }
 }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function JU(t, e = {}) {
 return Ur(t, "GET", "/v2/passwordPolicy", Di(t, e));
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const YU = 6;
class QU {
 constructor(e) {
  var n, r, i, o;
  const s = e.customStrengthOptions;
  (this.customStrengthOptions = {}),
   (this.customStrengthOptions.minPasswordLength = (n = s.minPasswordLength) !== null && n !== void 0 ? n : YU),
   s.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = s.maxPasswordLength),
   s.containsLowercaseCharacter !== void 0 &&
    (this.customStrengthOptions.containsLowercaseLetter = s.containsLowercaseCharacter),
   s.containsUppercaseCharacter !== void 0 &&
    (this.customStrengthOptions.containsUppercaseLetter = s.containsUppercaseCharacter),
   s.containsNumericCharacter !== void 0 &&
    (this.customStrengthOptions.containsNumericCharacter = s.containsNumericCharacter),
   s.containsNonAlphanumericCharacter !== void 0 &&
    (this.customStrengthOptions.containsNonAlphanumericCharacter = s.containsNonAlphanumericCharacter),
   (this.enforcementState = e.enforcementState),
   this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED" && (this.enforcementState = "OFF"),
   (this.allowedNonAlphanumericCharacters =
    (i = (r = e.allowedNonAlphanumericCharacters) === null || r === void 0 ? void 0 : r.join("")) !== null &&
    i !== void 0
     ? i
     : ""),
   (this.forceUpgradeOnSignin = (o = e.forceUpgradeOnSignin) !== null && o !== void 0 ? o : !1),
   (this.schemaVersion = e.schemaVersion);
 }
 validatePassword(e) {
  var n, r, i, o, s, a;
  const l = { isValid: !0, passwordPolicy: this };
  return (
   this.validatePasswordLengthOptions(e, l),
   this.validatePasswordCharacterOptions(e, l),
   l.isValid && (l.isValid = (n = l.meetsMinPasswordLength) !== null && n !== void 0 ? n : !0),
   l.isValid && (l.isValid = (r = l.meetsMaxPasswordLength) !== null && r !== void 0 ? r : !0),
   l.isValid && (l.isValid = (i = l.containsLowercaseLetter) !== null && i !== void 0 ? i : !0),
   l.isValid && (l.isValid = (o = l.containsUppercaseLetter) !== null && o !== void 0 ? o : !0),
   l.isValid && (l.isValid = (s = l.containsNumericCharacter) !== null && s !== void 0 ? s : !0),
   l.isValid && (l.isValid = (a = l.containsNonAlphanumericCharacter) !== null && a !== void 0 ? a : !0),
   l
  );
 }
 validatePasswordLengthOptions(e, n) {
  const r = this.customStrengthOptions.minPasswordLength,
   i = this.customStrengthOptions.maxPasswordLength;
  r && (n.meetsMinPasswordLength = e.length >= r), i && (n.meetsMaxPasswordLength = e.length <= i);
 }
 validatePasswordCharacterOptions(e, n) {
  this.updatePasswordCharacterOptionsStatuses(n, !1, !1, !1, !1);
  let r;
  for (let i = 0; i < e.length; i++)
   (r = e.charAt(i)),
    this.updatePasswordCharacterOptionsStatuses(
     n,
     r >= "a" && r <= "z",
     r >= "A" && r <= "Z",
     r >= "0" && r <= "9",
     this.allowedNonAlphanumericCharacters.includes(r)
    );
 }
 updatePasswordCharacterOptionsStatuses(e, n, r, i, o) {
  this.customStrengthOptions.containsLowercaseLetter && (e.containsLowercaseLetter || (e.containsLowercaseLetter = n)),
   this.customStrengthOptions.containsUppercaseLetter && (e.containsUppercaseLetter || (e.containsUppercaseLetter = r)),
   this.customStrengthOptions.containsNumericCharacter &&
    (e.containsNumericCharacter || (e.containsNumericCharacter = i)),
   this.customStrengthOptions.containsNonAlphanumericCharacter &&
    (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = o));
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class XU {
 constructor(e, n, r, i) {
  (this.app = e),
   (this.heartbeatServiceProvider = n),
   (this.appCheckServiceProvider = r),
   (this.config = i),
   (this.currentUser = null),
   (this.emulatorConfig = null),
   (this.operations = Promise.resolve()),
   (this.authStateSubscription = new g0(this)),
   (this.idTokenSubscription = new g0(this)),
   (this.beforeStateQueue = new KU(this)),
   (this.redirectUser = null),
   (this.isProactiveRefreshEnabled = !1),
   (this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1),
   (this._canInitEmulator = !0),
   (this._isInitialized = !1),
   (this._deleted = !1),
   (this._initializationPromise = null),
   (this._popupRedirectResolver = null),
   (this._errorFactory = GC),
   (this._agentRecaptchaConfig = null),
   (this._tenantRecaptchaConfigs = {}),
   (this._projectPasswordPolicy = null),
   (this._tenantPasswordPolicies = {}),
   (this.lastNotifiedUid = void 0),
   (this.languageCode = null),
   (this.tenantId = null),
   (this.settings = { appVerificationDisabledForTesting: !1 }),
   (this.frameworks = []),
   (this.name = e.name),
   (this.clientVersion = i.sdkClientVersion);
 }
 _initializeWithPersistence(e, n) {
  return (
   n && (this._popupRedirectResolver = Tr(n)),
   (this._initializationPromise = this.queue(async () => {
    var r, i;
    if (!this._deleted && ((this.persistenceManager = await ps.create(this, e)), !this._deleted)) {
     if (!((r = this._popupRedirectResolver) === null || r === void 0) && r._shouldInitProactively)
      try {
       await this._popupRedirectResolver._initialize(this);
      } catch {}
     await this.initializeCurrentUser(n),
      (this.lastNotifiedUid = ((i = this.currentUser) === null || i === void 0 ? void 0 : i.uid) || null),
      !this._deleted && (this._isInitialized = !0);
    }
   })),
   this._initializationPromise
  );
 }
 async _onStorageEvent() {
  if (this._deleted) return;
  const e = await this.assertedPersistence.getCurrentUser();
  if (!(!this.currentUser && !e)) {
   if (this.currentUser && e && this.currentUser.uid === e.uid) {
    this._currentUser._assign(e), await this.currentUser.getIdToken();
    return;
   }
   await this._updateCurrentUser(e, !0);
  }
 }
 async initializeCurrentUserFromIdToken(e) {
  try {
   const n = await YC(this, { idToken: e }),
    r = await Er._fromGetAccountInfoResponse(this, n, e);
   await this.directlySetCurrentUser(r);
  } catch (n) {
   console.warn("FirebaseServerApp could not login user with provided authIdToken: ", n),
    await this.directlySetCurrentUser(null);
  }
 }
 async initializeCurrentUser(e) {
  var n;
  if (Zn(this.app)) {
   const s = this.app.settings.authIdToken;
   return s
    ? new Promise((a) => {
       setTimeout(() => this.initializeCurrentUserFromIdToken(s).then(a, a));
      })
    : this.directlySetCurrentUser(null);
  }
  const r = await this.assertedPersistence.getCurrentUser();
  let i = r,
   o = !1;
  if (e && this.config.authDomain) {
   await this.getOrInitRedirectPersistenceManager();
   const s = (n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId,
    a = i == null ? void 0 : i._redirectEventId,
    l = await this.tryRedirectSignIn(e);
   (!s || s === a) && l != null && l.user && ((i = l.user), (o = !0));
  }
  if (!i) return this.directlySetCurrentUser(null);
  if (!i._redirectEventId) {
   if (o)
    try {
     await this.beforeStateQueue.runMiddleware(i);
    } catch (s) {
     (i = r), this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(s));
    }
   return i ? this.reloadAndSetCurrentUserOrClear(i) : this.directlySetCurrentUser(null);
  }
  return (
   te(this._popupRedirectResolver, this, "argument-error"),
   await this.getOrInitRedirectPersistenceManager(),
   this.redirectUser && this.redirectUser._redirectEventId === i._redirectEventId
    ? this.directlySetCurrentUser(i)
    : this.reloadAndSetCurrentUserOrClear(i)
  );
 }
 async tryRedirectSignIn(e) {
  let n = null;
  try {
   n = await this._popupRedirectResolver._completeRedirectFn(this, e, !0);
  } catch {
   await this._setRedirectUser(null);
  }
  return n;
 }
 async reloadAndSetCurrentUserOrClear(e) {
  try {
   await hd(e);
  } catch (n) {
   if ((n == null ? void 0 : n.code) !== "auth/network-request-failed") return this.directlySetCurrentUser(null);
  }
  return this.directlySetCurrentUser(e);
 }
 useDeviceLanguage() {
  this.languageCode = bU();
 }
 async _delete() {
  this._deleted = !0;
 }
 async updateCurrentUser(e) {
  if (Zn(this.app)) return Promise.reject(Ar(this));
  const n = e ? Se(e) : null;
  return (
   n && te(n.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"),
   this._updateCurrentUser(n && n._clone(this))
  );
 }
 async _updateCurrentUser(e, n = !1) {
  if (!this._deleted)
   return (
    e && te(this.tenantId === e.tenantId, this, "tenant-id-mismatch"),
    n || (await this.beforeStateQueue.runMiddleware(e)),
    this.queue(async () => {
     await this.directlySetCurrentUser(e), this.notifyAuthListeners();
    })
   );
 }
 async signOut() {
  return Zn(this.app)
   ? Promise.reject(Ar(this))
   : (await this.beforeStateQueue.runMiddleware(null),
     (this.redirectPersistenceManager || this._popupRedirectResolver) && (await this._setRedirectUser(null)),
     this._updateCurrentUser(null, !0));
 }
 setPersistence(e) {
  return Zn(this.app)
   ? Promise.reject(Ar(this))
   : this.queue(async () => {
      await this.assertedPersistence.setPersistence(Tr(e));
     });
 }
 _getRecaptchaConfig() {
  return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId];
 }
 async validatePassword(e) {
  this._getPasswordPolicyInternal() || (await this._updatePasswordPolicy());
  const n = this._getPasswordPolicyInternal();
  return n.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION
   ? Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {}))
   : n.validatePassword(e);
 }
 _getPasswordPolicyInternal() {
  return this.tenantId === null ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId];
 }
 async _updatePasswordPolicy() {
  const e = await JU(this),
   n = new QU(e);
  this.tenantId === null ? (this._projectPasswordPolicy = n) : (this._tenantPasswordPolicies[this.tenantId] = n);
 }
 _getPersistence() {
  return this.assertedPersistence.persistence.type;
 }
 _updateErrorMap(e) {
  this._errorFactory = new Po("auth", "Firebase", e());
 }
 onAuthStateChanged(e, n, r) {
  return this.registerStateListener(this.authStateSubscription, e, n, r);
 }
 beforeAuthStateChanged(e, n) {
  return this.beforeStateQueue.pushCallback(e, n);
 }
 onIdTokenChanged(e, n, r) {
  return this.registerStateListener(this.idTokenSubscription, e, n, r);
 }
 authStateReady() {
  return new Promise((e, n) => {
   if (this.currentUser) e();
   else {
    const r = this.onAuthStateChanged(() => {
     r(), e();
    }, n);
   }
  });
 }
 async revokeAccessToken(e) {
  if (this.currentUser) {
   const n = await this.currentUser.getIdToken(),
    r = { providerId: "apple.com", tokenType: "ACCESS_TOKEN", token: e, idToken: n };
   this.tenantId != null && (r.tenantId = this.tenantId), await GU(this, r);
  }
 }
 toJSON() {
  var e;
  return {
   apiKey: this.config.apiKey,
   authDomain: this.config.authDomain,
   appName: this.name,
   currentUser: (e = this._currentUser) === null || e === void 0 ? void 0 : e.toJSON(),
  };
 }
 async _setRedirectUser(e, n) {
  const r = await this.getOrInitRedirectPersistenceManager(n);
  return e === null ? r.removeCurrentUser() : r.setCurrentUser(e);
 }
 async getOrInitRedirectPersistenceManager(e) {
  if (!this.redirectPersistenceManager) {
   const n = (e && Tr(e)) || this._popupRedirectResolver;
   te(n, this, "argument-error"),
    (this.redirectPersistenceManager = await ps.create(this, [Tr(n._redirectPersistence)], "redirectUser")),
    (this.redirectUser = await this.redirectPersistenceManager.getCurrentUser());
  }
  return this.redirectPersistenceManager;
 }
 async _redirectUserForId(e) {
  var n, r;
  return (
   this._isInitialized && (await this.queue(async () => {})),
   ((n = this._currentUser) === null || n === void 0 ? void 0 : n._redirectEventId) === e
    ? this._currentUser
    : ((r = this.redirectUser) === null || r === void 0 ? void 0 : r._redirectEventId) === e
      ? this.redirectUser
      : null
  );
 }
 async _persistUserIfCurrent(e) {
  if (e === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(e));
 }
 _notifyListenersIfCurrent(e) {
  e === this.currentUser && this.notifyAuthListeners();
 }
 _key() {
  return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
 }
 _startProactiveRefresh() {
  (this.isProactiveRefreshEnabled = !0), this.currentUser && this._currentUser._startProactiveRefresh();
 }
 _stopProactiveRefresh() {
  (this.isProactiveRefreshEnabled = !1), this.currentUser && this._currentUser._stopProactiveRefresh();
 }
 get _currentUser() {
  return this.currentUser;
 }
 notifyAuthListeners() {
  var e, n;
  if (!this._isInitialized) return;
  this.idTokenSubscription.next(this.currentUser);
  const r = (n = (e = this.currentUser) === null || e === void 0 ? void 0 : e.uid) !== null && n !== void 0 ? n : null;
  this.lastNotifiedUid !== r && ((this.lastNotifiedUid = r), this.authStateSubscription.next(this.currentUser));
 }
 registerStateListener(e, n, r, i) {
  if (this._deleted) return () => {};
  const o = typeof n == "function" ? n : n.next.bind(n);
  let s = !1;
  const a = this._isInitialized ? Promise.resolve() : this._initializationPromise;
  if (
   (te(a, this, "internal-error"),
   a.then(() => {
    s || o(this.currentUser);
   }),
   typeof n == "function")
  ) {
   const l = e.addObserver(n, r, i);
   return () => {
    (s = !0), l();
   };
  } else {
   const l = e.addObserver(n);
   return () => {
    (s = !0), l();
   };
  }
 }
 async directlySetCurrentUser(e) {
  this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(),
   e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(),
   (this.currentUser = e),
   e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser();
 }
 queue(e) {
  return (this.operations = this.operations.then(e, e)), this.operations;
 }
 get assertedPersistence() {
  return te(this.persistenceManager, this, "internal-error"), this.persistenceManager;
 }
 _logFramework(e) {
  !e ||
   this.frameworks.includes(e) ||
   (this.frameworks.push(e),
   this.frameworks.sort(),
   (this.clientVersion = sR(this.config.clientPlatform, this._getFrameworks())));
 }
 _getFrameworks() {
  return this.frameworks;
 }
 async _getAdditionalHeaders() {
  var e;
  const n = { "X-Client-Version": this.clientVersion };
  this.app.options.appId && (n["X-Firebase-gmpid"] = this.app.options.appId);
  const r = await ((e = this.heartbeatServiceProvider.getImmediate({ optional: !0 })) === null || e === void 0
   ? void 0
   : e.getHeartbeatsHeader());
  r && (n["X-Firebase-Client"] = r);
  const i = await this._getAppCheckToken();
  return i && (n["X-Firebase-AppCheck"] = i), n;
 }
 async _getAppCheckToken() {
  var e;
  const n = await ((e = this.appCheckServiceProvider.getImmediate({ optional: !0 })) === null || e === void 0
   ? void 0
   : e.getToken());
  return n != null && n.error && RU(`Error while retrieving App Check token: ${n.error}`), n == null ? void 0 : n.token;
 }
}
function bo(t) {
 return Se(t);
}
class g0 {
 constructor(e) {
  (this.auth = e), (this.observer = null), (this.addObserver = dV((n) => (this.observer = n)));
 }
 get next() {
  return te(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer);
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let sf = {
 async loadJS() {
  throw new Error("Unable to load external scripts");
 },
 recaptchaV2Script: "",
 recaptchaEnterpriseScript: "",
 gapiScript: "",
};
function jU(t) {
 sf = t;
}
function aR(t) {
 return sf.loadJS(t);
}
function ZU() {
 return sf.recaptchaEnterpriseScript;
}
function eO() {
 return sf.gapiScript;
}
function tO(t) {
 return `__${t}${Math.floor(Math.random() * 1e6)}`;
}
const nO = "recaptcha-enterprise",
 rO = "NO_RECAPTCHA";
class iO {
 constructor(e) {
  (this.type = nO), (this.auth = bo(e));
 }
 async verify(e = "verify", n = !1) {
  async function r(o) {
   if (!n) {
    if (o.tenantId == null && o._agentRecaptchaConfig != null) return o._agentRecaptchaConfig.siteKey;
    if (o.tenantId != null && o._tenantRecaptchaConfigs[o.tenantId] !== void 0)
     return o._tenantRecaptchaConfigs[o.tenantId].siteKey;
   }
   return new Promise(async (s, a) => {
    VU(o, { clientType: "CLIENT_TYPE_WEB", version: "RECAPTCHA_ENTERPRISE" })
     .then((l) => {
      if (l.recaptchaKey === void 0) a(new Error("recaptcha Enterprise site key undefined"));
      else {
       const u = new LU(l);
       return (
        o.tenantId == null ? (o._agentRecaptchaConfig = u) : (o._tenantRecaptchaConfigs[o.tenantId] = u), s(u.siteKey)
       );
      }
     })
     .catch((l) => {
      a(l);
     });
   });
  }
  function i(o, s, a) {
   const l = window.grecaptcha;
   d0(l)
    ? l.enterprise.ready(() => {
       l.enterprise
        .execute(o, { action: e })
        .then((u) => {
         s(u);
        })
        .catch(() => {
         s(rO);
        });
      })
    : a(Error("No reCAPTCHA enterprise script loaded."));
  }
  return new Promise((o, s) => {
   r(this.auth)
    .then((a) => {
     if (!n && d0(window.grecaptcha)) i(a, o, s);
     else {
      if (typeof window > "u") {
       s(new Error("RecaptchaVerifier is only supported in browser"));
       return;
      }
      let l = ZU();
      l.length !== 0 && (l += a),
       aR(l)
        .then(() => {
         i(a, o, s);
        })
        .catch((u) => {
         s(u);
        });
     }
    })
    .catch((a) => {
     s(a);
    });
  });
 }
}
async function y0(t, e, n, r = !1) {
 const i = new iO(t);
 let o;
 try {
  o = await i.verify(n);
 } catch {
  o = await i.verify(n, !0);
 }
 const s = Object.assign({}, e);
 return (
  r ? Object.assign(s, { captchaResp: o }) : Object.assign(s, { captchaResponse: o }),
  Object.assign(s, { clientType: "CLIENT_TYPE_WEB" }),
  Object.assign(s, { recaptchaVersion: "RECAPTCHA_ENTERPRISE" }),
  s
 );
}
async function um(t, e, n, r) {
 var i;
 if (!((i = t._getRecaptchaConfig()) === null || i === void 0) && i.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")) {
  const o = await y0(t, e, n, n === "getOobCode");
  return r(t, o);
 } else
  return r(t, e).catch(async (o) => {
   if (o.code === "auth/missing-recaptcha-token") {
    console.log(
     `${n} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`
    );
    const s = await y0(t, e, n, n === "getOobCode");
    return r(t, s);
   } else return Promise.reject(o);
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function oO(t, e) {
 const n = Mi(t, "auth");
 if (n.isInitialized()) {
  const i = n.getImmediate(),
   o = n.getOptions();
  if (_l(o, e ?? {})) return i;
  qn(i, "already-initialized");
 }
 return n.initialize({ options: e });
}
function sO(t, e) {
 const n = (e == null ? void 0 : e.persistence) || [],
  r = (Array.isArray(n) ? n : [n]).map(Tr);
 e != null && e.errorMap && t._updateErrorMap(e.errorMap),
  t._initializeWithPersistence(r, e == null ? void 0 : e.popupRedirectResolver);
}
function aO(t, e, n) {
 const r = bo(t);
 te(r._canInitEmulator, r, "emulator-config-failed"), te(/^https?:\/\//.test(e), r, "invalid-emulator-scheme");
 const i = !1,
  o = lR(e),
  { host: s, port: a } = lO(e),
  l = a === null ? "" : `:${a}`;
 (r.config.emulator = { url: `${o}//${s}${l}/` }),
  (r.settings.appVerificationDisabledForTesting = !0),
  (r.emulatorConfig = Object.freeze({
   host: s,
   port: a,
   protocol: o.replace(":", ""),
   options: Object.freeze({ disableWarnings: i }),
  })),
  uO();
}
function lR(t) {
 const e = t.indexOf(":");
 return e < 0 ? "" : t.substr(0, e + 1);
}
function lO(t) {
 const e = lR(t),
  n = /(\/\/)?([^?#/]+)/.exec(t.substr(e.length));
 if (!n) return { host: "", port: null };
 const r = n[2].split("@").pop() || "",
  i = /^(\[[^\]]+\])(:|$)/.exec(r);
 if (i) {
  const o = i[1];
  return { host: o, port: v0(r.substr(o.length + 1)) };
 } else {
  const [o, s] = r.split(":");
  return { host: o, port: v0(s) };
 }
}
function v0(t) {
 if (!t) return null;
 const e = Number(t);
 return isNaN(e) ? null : e;
}
function uO() {
 function t() {
  const e = document.createElement("p"),
   n = e.style;
  (e.innerText = "Running in emulator mode. Do not use with production credentials."),
   (n.position = "fixed"),
   (n.width = "100%"),
   (n.backgroundColor = "#ffffff"),
   (n.border = ".1em solid #000000"),
   (n.color = "#b50000"),
   (n.bottom = "0px"),
   (n.left = "0px"),
   (n.margin = "0px"),
   (n.zIndex = "10000"),
   (n.textAlign = "center"),
   e.classList.add("firebase-emulator-warning"),
   document.body.appendChild(e);
 }
 typeof console < "u" &&
  typeof console.info == "function" &&
  console.info(
   "WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."
  ),
  typeof window < "u" &&
   typeof document < "u" &&
   (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", t) : t());
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hy {
 constructor(e, n) {
  (this.providerId = e), (this.signInMethod = n);
 }
 toJSON() {
  return wr("not implemented");
 }
 _getIdTokenResponse(e) {
  return wr("not implemented");
 }
 _linkToIdToken(e, n) {
  return wr("not implemented");
 }
 _getReauthenticationResolver(e) {
  return wr("not implemented");
 }
}
async function cO(t, e) {
 return Ur(t, "POST", "/v1/accounts:update", e);
}
async function dO(t, e) {
 return Ur(t, "POST", "/v1/accounts:signUp", e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function fO(t, e) {
 return Wl(t, "POST", "/v1/accounts:signInWithPassword", Di(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function hO(t, e) {
 return Wl(t, "POST", "/v1/accounts:signInWithEmailLink", Di(t, e));
}
async function pO(t, e) {
 return Wl(t, "POST", "/v1/accounts:signInWithEmailLink", Di(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class El extends hy {
 constructor(e, n, r, i = null) {
  super("password", r), (this._email = e), (this._password = n), (this._tenantId = i);
 }
 static _fromEmailAndPassword(e, n) {
  return new El(e, n, "password");
 }
 static _fromEmailAndCode(e, n, r = null) {
  return new El(e, n, "emailLink", r);
 }
 toJSON() {
  return { email: this._email, password: this._password, signInMethod: this.signInMethod, tenantId: this._tenantId };
 }
 static fromJSON(e) {
  const n = typeof e == "string" ? JSON.parse(e) : e;
  if (n != null && n.email && n != null && n.password) {
   if (n.signInMethod === "password") return this._fromEmailAndPassword(n.email, n.password);
   if (n.signInMethod === "emailLink") return this._fromEmailAndCode(n.email, n.password, n.tenantId);
  }
  return null;
 }
 async _getIdTokenResponse(e) {
  switch (this.signInMethod) {
   case "password":
    const n = { returnSecureToken: !0, email: this._email, password: this._password, clientType: "CLIENT_TYPE_WEB" };
    return um(e, n, "signInWithPassword", fO);
   case "emailLink":
    return hO(e, { email: this._email, oobCode: this._password });
   default:
    qn(e, "internal-error");
  }
 }
 async _linkToIdToken(e, n) {
  switch (this.signInMethod) {
   case "password":
    const r = {
     idToken: n,
     returnSecureToken: !0,
     email: this._email,
     password: this._password,
     clientType: "CLIENT_TYPE_WEB",
    };
    return um(e, r, "signUpPassword", dO);
   case "emailLink":
    return pO(e, { idToken: n, email: this._email, oobCode: this._password });
   default:
    qn(e, "internal-error");
  }
 }
 _getReauthenticationResolver(e) {
  return this._getIdTokenResponse(e);
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function ms(t, e) {
 return Wl(t, "POST", "/v1/accounts:signInWithIdp", Di(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const mO = "http://localhost";
class po extends hy {
 constructor() {
  super(...arguments), (this.pendingToken = null);
 }
 static _fromParams(e) {
  const n = new po(e.providerId, e.signInMethod);
  return (
   e.idToken || e.accessToken
    ? (e.idToken && (n.idToken = e.idToken),
      e.accessToken && (n.accessToken = e.accessToken),
      e.nonce && !e.pendingToken && (n.nonce = e.nonce),
      e.pendingToken && (n.pendingToken = e.pendingToken))
    : e.oauthToken && e.oauthTokenSecret
      ? ((n.accessToken = e.oauthToken), (n.secret = e.oauthTokenSecret))
      : qn("argument-error"),
   n
  );
 }
 toJSON() {
  return {
   idToken: this.idToken,
   accessToken: this.accessToken,
   secret: this.secret,
   nonce: this.nonce,
   pendingToken: this.pendingToken,
   providerId: this.providerId,
   signInMethod: this.signInMethod,
  };
 }
 static fromJSON(e) {
  const n = typeof e == "string" ? JSON.parse(e) : e,
   { providerId: r, signInMethod: i } = n,
   o = ly(n, ["providerId", "signInMethod"]);
  if (!r || !i) return null;
  const s = new po(r, i);
  return (
   (s.idToken = o.idToken || void 0),
   (s.accessToken = o.accessToken || void 0),
   (s.secret = o.secret),
   (s.nonce = o.nonce),
   (s.pendingToken = o.pendingToken || null),
   s
  );
 }
 _getIdTokenResponse(e) {
  const n = this.buildRequest();
  return ms(e, n);
 }
 _linkToIdToken(e, n) {
  const r = this.buildRequest();
  return (r.idToken = n), ms(e, r);
 }
 _getReauthenticationResolver(e) {
  const n = this.buildRequest();
  return (n.autoCreate = !1), ms(e, n);
 }
 buildRequest() {
  const e = { requestUri: mO, returnSecureToken: !0 };
  if (this.pendingToken) e.pendingToken = this.pendingToken;
  else {
   const n = {};
   this.idToken && (n.id_token = this.idToken),
    this.accessToken && (n.access_token = this.accessToken),
    this.secret && (n.oauth_token_secret = this.secret),
    (n.providerId = this.providerId),
    this.nonce && !this.pendingToken && (n.nonce = this.nonce),
    (e.postBody = ql(n));
  }
  return e;
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function gO(t) {
 switch (t) {
  case "recoverEmail":
   return "RECOVER_EMAIL";
  case "resetPassword":
   return "PASSWORD_RESET";
  case "signIn":
   return "EMAIL_SIGNIN";
  case "verifyEmail":
   return "VERIFY_EMAIL";
  case "verifyAndChangeEmail":
   return "VERIFY_AND_CHANGE_EMAIL";
  case "revertSecondFactorAddition":
   return "REVERT_SECOND_FACTOR_ADDITION";
  default:
   return null;
 }
}
function yO(t) {
 const e = ba(Na(t)).link,
  n = e ? ba(Na(e)).deep_link_id : null,
  r = ba(Na(t)).deep_link_id;
 return (r ? ba(Na(r)).link : null) || r || n || e || t;
}
class py {
 constructor(e) {
  var n, r, i, o, s, a;
  const l = ba(Na(e)),
   u = (n = l.apiKey) !== null && n !== void 0 ? n : null,
   h = (r = l.oobCode) !== null && r !== void 0 ? r : null,
   p = gO((i = l.mode) !== null && i !== void 0 ? i : null);
  te(u && h && p, "argument-error"),
   (this.apiKey = u),
   (this.operation = p),
   (this.code = h),
   (this.continueUrl = (o = l.continueUrl) !== null && o !== void 0 ? o : null),
   (this.languageCode = (s = l.languageCode) !== null && s !== void 0 ? s : null),
   (this.tenantId = (a = l.tenantId) !== null && a !== void 0 ? a : null);
 }
 static parseLink(e) {
  const n = yO(e);
  try {
   return new py(n);
  } catch {
   return null;
  }
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Gs {
 constructor() {
  this.providerId = Gs.PROVIDER_ID;
 }
 static credential(e, n) {
  return El._fromEmailAndPassword(e, n);
 }
 static credentialWithLink(e, n) {
  const r = py.parseLink(n);
  return te(r, "argument-error"), El._fromEmailAndCode(e, r.code, r.tenantId);
 }
}
Gs.PROVIDER_ID = "password";
Gs.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
Gs.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class uR {
 constructor(e) {
  (this.providerId = e), (this.defaultLanguageCode = null), (this.customParameters = {});
 }
 setDefaultLanguage(e) {
  this.defaultLanguageCode = e;
 }
 setCustomParameters(e) {
  return (this.customParameters = e), this;
 }
 getCustomParameters() {
  return this.customParameters;
 }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Kl extends uR {
 constructor() {
  super(...arguments), (this.scopes = []);
 }
 addScope(e) {
  return this.scopes.includes(e) || this.scopes.push(e), this;
 }
 getScopes() {
  return [...this.scopes];
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Zr extends Kl {
 constructor() {
  super("facebook.com");
 }
 static credential(e) {
  return po._fromParams({ providerId: Zr.PROVIDER_ID, signInMethod: Zr.FACEBOOK_SIGN_IN_METHOD, accessToken: e });
 }
 static credentialFromResult(e) {
  return Zr.credentialFromTaggedObject(e);
 }
 static credentialFromError(e) {
  return Zr.credentialFromTaggedObject(e.customData || {});
 }
 static credentialFromTaggedObject({ _tokenResponse: e }) {
  if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null;
  try {
   return Zr.credential(e.oauthAccessToken);
  } catch {
   return null;
  }
 }
}
Zr.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
Zr.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ei extends Kl {
 constructor() {
  super("google.com"), this.addScope("profile");
 }
 static credential(e, n) {
  return po._fromParams({
   providerId: ei.PROVIDER_ID,
   signInMethod: ei.GOOGLE_SIGN_IN_METHOD,
   idToken: e,
   accessToken: n,
  });
 }
 static credentialFromResult(e) {
  return ei.credentialFromTaggedObject(e);
 }
 static credentialFromError(e) {
  return ei.credentialFromTaggedObject(e.customData || {});
 }
 static credentialFromTaggedObject({ _tokenResponse: e }) {
  if (!e) return null;
  const { oauthIdToken: n, oauthAccessToken: r } = e;
  if (!n && !r) return null;
  try {
   return ei.credential(n, r);
  } catch {
   return null;
  }
 }
}
ei.GOOGLE_SIGN_IN_METHOD = "google.com";
ei.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ti extends Kl {
 constructor() {
  super("github.com");
 }
 static credential(e) {
  return po._fromParams({ providerId: ti.PROVIDER_ID, signInMethod: ti.GITHUB_SIGN_IN_METHOD, accessToken: e });
 }
 static credentialFromResult(e) {
  return ti.credentialFromTaggedObject(e);
 }
 static credentialFromError(e) {
  return ti.credentialFromTaggedObject(e.customData || {});
 }
 static credentialFromTaggedObject({ _tokenResponse: e }) {
  if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null;
  try {
   return ti.credential(e.oauthAccessToken);
  } catch {
   return null;
  }
 }
}
ti.GITHUB_SIGN_IN_METHOD = "github.com";
ti.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ni extends Kl {
 constructor() {
  super("twitter.com");
 }
 static credential(e, n) {
  return po._fromParams({
   providerId: ni.PROVIDER_ID,
   signInMethod: ni.TWITTER_SIGN_IN_METHOD,
   oauthToken: e,
   oauthTokenSecret: n,
  });
 }
 static credentialFromResult(e) {
  return ni.credentialFromTaggedObject(e);
 }
 static credentialFromError(e) {
  return ni.credentialFromTaggedObject(e.customData || {});
 }
 static credentialFromTaggedObject({ _tokenResponse: e }) {
  if (!e) return null;
  const { oauthAccessToken: n, oauthTokenSecret: r } = e;
  if (!n || !r) return null;
  try {
   return ni.credential(n, r);
  } catch {
   return null;
  }
 }
}
ni.TWITTER_SIGN_IN_METHOD = "twitter.com";
ni.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function vO(t, e) {
 return Wl(t, "POST", "/v1/accounts:signUp", Di(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class mo {
 constructor(e) {
  (this.user = e.user),
   (this.providerId = e.providerId),
   (this._tokenResponse = e._tokenResponse),
   (this.operationType = e.operationType);
 }
 static async _fromIdTokenResponse(e, n, r, i = !1) {
  const o = await Er._fromIdTokenResponse(e, r, i),
   s = _0(r);
  return new mo({ user: o, providerId: s, _tokenResponse: r, operationType: n });
 }
 static async _forOperation(e, n, r) {
  await e._updateTokensIfNecessary(r, !0);
  const i = _0(r);
  return new mo({ user: e, providerId: i, _tokenResponse: r, operationType: n });
 }
}
function _0(t) {
 return t.providerId ? t.providerId : "phoneNumber" in t ? "phone" : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class pd extends bn {
 constructor(e, n, r, i) {
  var o;
  super(n.code, n.message),
   (this.operationType = r),
   (this.user = i),
   Object.setPrototypeOf(this, pd.prototype),
   (this.customData = {
    appName: e.name,
    tenantId: (o = e.tenantId) !== null && o !== void 0 ? o : void 0,
    _serverResponse: n.customData._serverResponse,
    operationType: r,
   });
 }
 static _fromErrorAndOperation(e, n, r, i) {
  return new pd(e, n, r, i);
 }
}
function cR(t, e, n, r) {
 return (e === "reauthenticate" ? n._getReauthenticationResolver(t) : n._getIdTokenResponse(t)).catch((o) => {
  throw o.code === "auth/multi-factor-auth-required" ? pd._fromErrorAndOperation(t, o, e, r) : o;
 });
}
async function _O(t, e, n = !1) {
 const r = await Ps(t, e._linkToIdToken(t.auth, await t.getIdToken()), n);
 return mo._forOperation(t, "link", r);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function wO(t, e, n = !1) {
 const { auth: r } = t;
 if (Zn(r.app)) return Promise.reject(Ar(r));
 const i = "reauthenticate";
 try {
  const o = await Ps(t, cR(r, i, e, t), n);
  te(o.idToken, r, "internal-error");
  const s = dy(o.idToken);
  te(s, r, "internal-error");
  const { sub: a } = s;
  return te(t.uid === a, r, "user-mismatch"), mo._forOperation(t, i, o);
 } catch (o) {
  throw ((o == null ? void 0 : o.code) === "auth/user-not-found" && qn(r, "user-mismatch"), o);
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function dR(t, e, n = !1) {
 if (Zn(t.app)) return Promise.reject(Ar(t));
 const r = "signIn",
  i = await cR(t, r, e),
  o = await mo._fromIdTokenResponse(t, r, i);
 return n || (await t._updateCurrentUser(o.user)), o;
}
async function EO(t, e) {
 return dR(bo(t), e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function fR(t) {
 const e = bo(t);
 e._getPasswordPolicyInternal() && (await e._updatePasswordPolicy());
}
async function Gu(t, e, n) {
 if (Zn(t.app)) return Promise.reject(Ar(t));
 const r = bo(t),
  s = await um(
   r,
   { returnSecureToken: !0, email: e, password: n, clientType: "CLIENT_TYPE_WEB" },
   "signUpPassword",
   vO
  ).catch((l) => {
   throw (l.code === "auth/password-does-not-meet-requirements" && fR(t), l);
  }),
  a = await mo._fromIdTokenResponse(r, "signIn", s);
 return await r._updateCurrentUser(a.user), a;
}
function TO(t, e, n) {
 return Zn(t.app)
  ? Promise.reject(Ar(t))
  : EO(Se(t), Gs.credential(e, n)).catch(async (r) => {
     throw (r.code === "auth/password-does-not-meet-requirements" && fR(t), r);
    });
}
function IO(t, e) {
 return SO(Se(t), null, e);
}
async function SO(t, e, n) {
 const { auth: r } = t,
  o = { idToken: await t.getIdToken(), returnSecureToken: !0 };
 n && (o.password = n);
 const s = await Ps(t, cO(r, o));
 await t._updateTokensIfNecessary(s, !0);
}
function AO(t, e, n, r) {
 return Se(t).onIdTokenChanged(e, n, r);
}
function CO(t, e, n) {
 return Se(t).beforeAuthStateChanged(e, n);
}
function RO(t, e, n, r) {
 return Se(t).onAuthStateChanged(e, n, r);
}
function w0(t) {
 return Se(t).signOut();
}
const md = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hR {
 constructor(e, n) {
  (this.storageRetriever = e), (this.type = n);
 }
 _isAvailable() {
  try {
   return this.storage
    ? (this.storage.setItem(md, "1"), this.storage.removeItem(md), Promise.resolve(!0))
    : Promise.resolve(!1);
  } catch {
   return Promise.resolve(!1);
  }
 }
 _set(e, n) {
  return this.storage.setItem(e, JSON.stringify(n)), Promise.resolve();
 }
 _get(e) {
  const n = this.storage.getItem(e);
  return Promise.resolve(n ? JSON.parse(n) : null);
 }
 _remove(e) {
  return this.storage.removeItem(e), Promise.resolve();
 }
 get storage() {
  return this.storageRetriever();
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const PO = 1e3,
 kO = 10;
class pR extends hR {
 constructor() {
  super(() => window.localStorage, "LOCAL"),
   (this.boundEventHandler = (e, n) => this.onStorageEvent(e, n)),
   (this.listeners = {}),
   (this.localCache = {}),
   (this.pollTimer = null),
   (this.fallbackToPolling = oR()),
   (this._shouldAllowMigration = !0);
 }
 forAllChangedKeys(e) {
  for (const n of Object.keys(this.listeners)) {
   const r = this.storage.getItem(n),
    i = this.localCache[n];
   r !== i && e(n, i, r);
  }
 }
 onStorageEvent(e, n = !1) {
  if (!e.key) {
   this.forAllChangedKeys((s, a, l) => {
    this.notifyListeners(s, l);
   });
   return;
  }
  const r = e.key;
  n ? this.detachListener() : this.stopPolling();
  const i = () => {
    const s = this.storage.getItem(r);
    (!n && this.localCache[r] === s) || this.notifyListeners(r, s);
   },
   o = this.storage.getItem(r);
  WU() && o !== e.newValue && e.newValue !== e.oldValue ? setTimeout(i, kO) : i();
 }
 notifyListeners(e, n) {
  this.localCache[e] = n;
  const r = this.listeners[e];
  if (r) for (const i of Array.from(r)) i(n && JSON.parse(n));
 }
 startPolling() {
  this.stopPolling(),
   (this.pollTimer = setInterval(() => {
    this.forAllChangedKeys((e, n, r) => {
     this.onStorageEvent(new StorageEvent("storage", { key: e, oldValue: n, newValue: r }), !0);
    });
   }, PO));
 }
 stopPolling() {
  this.pollTimer && (clearInterval(this.pollTimer), (this.pollTimer = null));
 }
 attachListener() {
  window.addEventListener("storage", this.boundEventHandler);
 }
 detachListener() {
  window.removeEventListener("storage", this.boundEventHandler);
 }
 _addListener(e, n) {
  Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()),
   this.listeners[e] || ((this.listeners[e] = new Set()), (this.localCache[e] = this.storage.getItem(e))),
   this.listeners[e].add(n);
 }
 _removeListener(e, n) {
  this.listeners[e] && (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]),
   Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling());
 }
 async _set(e, n) {
  await super._set(e, n), (this.localCache[e] = JSON.stringify(n));
 }
 async _get(e) {
  const n = await super._get(e);
  return (this.localCache[e] = JSON.stringify(n)), n;
 }
 async _remove(e) {
  await super._remove(e), delete this.localCache[e];
 }
}
pR.type = "LOCAL";
const bO = pR;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class mR extends hR {
 constructor() {
  super(() => window.sessionStorage, "SESSION");
 }
 _addListener(e, n) {}
 _removeListener(e, n) {}
}
mR.type = "SESSION";
const gR = mR;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function NO(t) {
 return Promise.all(
  t.map(async (e) => {
   try {
    return { fulfilled: !0, value: await e };
   } catch (n) {
    return { fulfilled: !1, reason: n };
   }
  })
 );
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class af {
 constructor(e) {
  (this.eventTarget = e), (this.handlersMap = {}), (this.boundEventHandler = this.handleEvent.bind(this));
 }
 static _getInstance(e) {
  const n = this.receivers.find((i) => i.isListeningto(e));
  if (n) return n;
  const r = new af(e);
  return this.receivers.push(r), r;
 }
 isListeningto(e) {
  return this.eventTarget === e;
 }
 async handleEvent(e) {
  const n = e,
   { eventId: r, eventType: i, data: o } = n.data,
   s = this.handlersMap[i];
  if (!(s != null && s.size)) return;
  n.ports[0].postMessage({ status: "ack", eventId: r, eventType: i });
  const a = Array.from(s).map(async (u) => u(n.origin, o)),
   l = await NO(a);
  n.ports[0].postMessage({ status: "done", eventId: r, eventType: i, response: l });
 }
 _subscribe(e, n) {
  Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler),
   this.handlersMap[e] || (this.handlersMap[e] = new Set()),
   this.handlersMap[e].add(n);
 }
 _unsubscribe(e, n) {
  this.handlersMap[e] && n && this.handlersMap[e].delete(n),
   (!n || this.handlersMap[e].size === 0) && delete this.handlersMap[e],
   Object.keys(this.handlersMap).length === 0 &&
    this.eventTarget.removeEventListener("message", this.boundEventHandler);
 }
}
af.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function my(t = "", e = 10) {
 let n = "";
 for (let r = 0; r < e; r++) n += Math.floor(Math.random() * 10);
 return t + n;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class xO {
 constructor(e) {
  (this.target = e), (this.handlers = new Set());
 }
 removeMessageHandler(e) {
  e.messageChannel &&
   (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()),
   this.handlers.delete(e);
 }
 async _send(e, n, r = 50) {
  const i = typeof MessageChannel < "u" ? new MessageChannel() : null;
  if (!i) throw new Error("connection_unavailable");
  let o, s;
  return new Promise((a, l) => {
   const u = my("", 20);
   i.port1.start();
   const h = setTimeout(() => {
    l(new Error("unsupported_event"));
   }, r);
   (s = {
    messageChannel: i,
    onMessage(p) {
     const m = p;
     if (m.data.eventId === u)
      switch (m.data.status) {
       case "ack":
        clearTimeout(h),
         (o = setTimeout(() => {
          l(new Error("timeout"));
         }, 3e3));
        break;
       case "done":
        clearTimeout(o), a(m.data.response);
        break;
       default:
        clearTimeout(h), clearTimeout(o), l(new Error("invalid_response"));
        break;
      }
    },
   }),
    this.handlers.add(s),
    i.port1.addEventListener("message", s.onMessage),
    this.target.postMessage({ eventType: e, eventId: u, data: n }, [i.port2]);
  }).finally(() => {
   s && this.removeMessageHandler(s);
  });
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function ir() {
 return window;
}
function MO(t) {
 ir().location.href = t;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function yR() {
 return typeof ir().WorkerGlobalScope < "u" && typeof ir().importScripts == "function";
}
async function DO() {
 if (!(navigator != null && navigator.serviceWorker)) return null;
 try {
  return (await navigator.serviceWorker.ready).active;
 } catch {
  return null;
 }
}
function LO() {
 var t;
 return (
  ((t = navigator == null ? void 0 : navigator.serviceWorker) === null || t === void 0 ? void 0 : t.controller) || null
 );
}
function VO() {
 return yR() ? self : null;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const vR = "firebaseLocalStorageDb",
 UO = 1,
 gd = "firebaseLocalStorage",
 _R = "fbase_key";
class Jl {
 constructor(e) {
  this.request = e;
 }
 toPromise() {
  return new Promise((e, n) => {
   this.request.addEventListener("success", () => {
    e(this.request.result);
   }),
    this.request.addEventListener("error", () => {
     n(this.request.error);
    });
  });
 }
}
function lf(t, e) {
 return t.transaction([gd], e ? "readwrite" : "readonly").objectStore(gd);
}
function OO() {
 const t = indexedDB.deleteDatabase(vR);
 return new Jl(t).toPromise();
}
function cm() {
 const t = indexedDB.open(vR, UO);
 return new Promise((e, n) => {
  t.addEventListener("error", () => {
   n(t.error);
  }),
   t.addEventListener("upgradeneeded", () => {
    const r = t.result;
    try {
     r.createObjectStore(gd, { keyPath: _R });
    } catch (i) {
     n(i);
    }
   }),
   t.addEventListener("success", async () => {
    const r = t.result;
    r.objectStoreNames.contains(gd) ? e(r) : (r.close(), await OO(), e(await cm()));
   });
 });
}
async function E0(t, e, n) {
 const r = lf(t, !0).put({ [_R]: e, value: n });
 return new Jl(r).toPromise();
}
async function FO(t, e) {
 const n = lf(t, !1).get(e),
  r = await new Jl(n).toPromise();
 return r === void 0 ? null : r.value;
}
function T0(t, e) {
 const n = lf(t, !0).delete(e);
 return new Jl(n).toPromise();
}
const BO = 800,
 $O = 3;
class wR {
 constructor() {
  (this.type = "LOCAL"),
   (this._shouldAllowMigration = !0),
   (this.listeners = {}),
   (this.localCache = {}),
   (this.pollTimer = null),
   (this.pendingWrites = 0),
   (this.receiver = null),
   (this.sender = null),
   (this.serviceWorkerReceiverAvailable = !1),
   (this.activeServiceWorker = null),
   (this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(
    () => {},
    () => {}
   ));
 }
 async _openDb() {
  return this.db ? this.db : ((this.db = await cm()), this.db);
 }
 async _withRetries(e) {
  let n = 0;
  for (;;)
   try {
    const r = await this._openDb();
    return await e(r);
   } catch (r) {
    if (n++ > $O) throw r;
    this.db && (this.db.close(), (this.db = void 0));
   }
 }
 async initializeServiceWorkerMessaging() {
  return yR() ? this.initializeReceiver() : this.initializeSender();
 }
 async initializeReceiver() {
  (this.receiver = af._getInstance(VO())),
   this.receiver._subscribe("keyChanged", async (e, n) => ({ keyProcessed: (await this._poll()).includes(n.key) })),
   this.receiver._subscribe("ping", async (e, n) => ["keyChanged"]);
 }
 async initializeSender() {
  var e, n;
  if (((this.activeServiceWorker = await DO()), !this.activeServiceWorker)) return;
  this.sender = new xO(this.activeServiceWorker);
  const r = await this.sender._send("ping", {}, 800);
  r &&
   !((e = r[0]) === null || e === void 0) &&
   e.fulfilled &&
   !((n = r[0]) === null || n === void 0) &&
   n.value.includes("keyChanged") &&
   (this.serviceWorkerReceiverAvailable = !0);
 }
 async notifyServiceWorker(e) {
  if (!(!this.sender || !this.activeServiceWorker || LO() !== this.activeServiceWorker))
   try {
    await this.sender._send("keyChanged", { key: e }, this.serviceWorkerReceiverAvailable ? 800 : 50);
   } catch {}
 }
 async _isAvailable() {
  try {
   if (!indexedDB) return !1;
   const e = await cm();
   return await E0(e, md, "1"), await T0(e, md), !0;
  } catch {}
  return !1;
 }
 async _withPendingWrite(e) {
  this.pendingWrites++;
  try {
   await e();
  } finally {
   this.pendingWrites--;
  }
 }
 async _set(e, n) {
  return this._withPendingWrite(
   async () => (await this._withRetries((r) => E0(r, e, n)), (this.localCache[e] = n), this.notifyServiceWorker(e))
  );
 }
 async _get(e) {
  const n = await this._withRetries((r) => FO(r, e));
  return (this.localCache[e] = n), n;
 }
 async _remove(e) {
  return this._withPendingWrite(
   async () => (await this._withRetries((n) => T0(n, e)), delete this.localCache[e], this.notifyServiceWorker(e))
  );
 }
 async _poll() {
  const e = await this._withRetries((i) => {
   const o = lf(i, !1).getAll();
   return new Jl(o).toPromise();
  });
  if (!e) return [];
  if (this.pendingWrites !== 0) return [];
  const n = [],
   r = new Set();
  if (e.length !== 0)
   for (const { fbase_key: i, value: o } of e)
    r.add(i), JSON.stringify(this.localCache[i]) !== JSON.stringify(o) && (this.notifyListeners(i, o), n.push(i));
  for (const i of Object.keys(this.localCache))
   this.localCache[i] && !r.has(i) && (this.notifyListeners(i, null), n.push(i));
  return n;
 }
 notifyListeners(e, n) {
  this.localCache[e] = n;
  const r = this.listeners[e];
  if (r) for (const i of Array.from(r)) i(n);
 }
 startPolling() {
  this.stopPolling(), (this.pollTimer = setInterval(async () => this._poll(), BO));
 }
 stopPolling() {
  this.pollTimer && (clearInterval(this.pollTimer), (this.pollTimer = null));
 }
 _addListener(e, n) {
  Object.keys(this.listeners).length === 0 && this.startPolling(),
   this.listeners[e] || ((this.listeners[e] = new Set()), this._get(e)),
   this.listeners[e].add(n);
 }
 _removeListener(e, n) {
  this.listeners[e] && (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]),
   Object.keys(this.listeners).length === 0 && this.stopPolling();
 }
}
wR.type = "LOCAL";
const HO = wR;
new zl(3e4, 6e4);
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function qO(t, e) {
 return e ? Tr(e) : (te(t._popupRedirectResolver, t, "argument-error"), t._popupRedirectResolver);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class gy extends hy {
 constructor(e) {
  super("custom", "custom"), (this.params = e);
 }
 _getIdTokenResponse(e) {
  return ms(e, this._buildIdpRequest());
 }
 _linkToIdToken(e, n) {
  return ms(e, this._buildIdpRequest(n));
 }
 _getReauthenticationResolver(e) {
  return ms(e, this._buildIdpRequest());
 }
 _buildIdpRequest(e) {
  const n = {
   requestUri: this.params.requestUri,
   sessionId: this.params.sessionId,
   postBody: this.params.postBody,
   tenantId: this.params.tenantId,
   pendingToken: this.params.pendingToken,
   returnSecureToken: !0,
   returnIdpCredential: !0,
  };
  return e && (n.idToken = e), n;
 }
}
function GO(t) {
 return dR(t.auth, new gy(t), t.bypassAuthState);
}
function zO(t) {
 const { auth: e, user: n } = t;
 return te(n, e, "internal-error"), wO(n, new gy(t), t.bypassAuthState);
}
async function WO(t) {
 const { auth: e, user: n } = t;
 return te(n, e, "internal-error"), _O(n, new gy(t), t.bypassAuthState);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ER {
 constructor(e, n, r, i, o = !1) {
  (this.auth = e),
   (this.resolver = r),
   (this.user = i),
   (this.bypassAuthState = o),
   (this.pendingPromise = null),
   (this.eventManager = null),
   (this.filter = Array.isArray(n) ? n : [n]);
 }
 execute() {
  return new Promise(async (e, n) => {
   this.pendingPromise = { resolve: e, reject: n };
   try {
    (this.eventManager = await this.resolver._initialize(this.auth)),
     await this.onExecution(),
     this.eventManager.registerConsumer(this);
   } catch (r) {
    this.reject(r);
   }
  });
 }
 async onAuthEvent(e) {
  const { urlResponse: n, sessionId: r, postBody: i, tenantId: o, error: s, type: a } = e;
  if (s) {
   this.reject(s);
   return;
  }
  const l = {
   auth: this.auth,
   requestUri: n,
   sessionId: r,
   tenantId: o || void 0,
   postBody: i || void 0,
   user: this.user,
   bypassAuthState: this.bypassAuthState,
  };
  try {
   this.resolve(await this.getIdpTask(a)(l));
  } catch (u) {
   this.reject(u);
  }
 }
 onError(e) {
  this.reject(e);
 }
 getIdpTask(e) {
  switch (e) {
   case "signInViaPopup":
   case "signInViaRedirect":
    return GO;
   case "linkViaPopup":
   case "linkViaRedirect":
    return WO;
   case "reauthViaPopup":
   case "reauthViaRedirect":
    return zO;
   default:
    qn(this.auth, "internal-error");
  }
 }
 resolve(e) {
  Nr(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(e), this.unregisterAndCleanUp();
 }
 reject(e) {
  Nr(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(e), this.unregisterAndCleanUp();
 }
 unregisterAndCleanUp() {
  this.eventManager && this.eventManager.unregisterConsumer(this), (this.pendingPromise = null), this.cleanUp();
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const KO = new zl(2e3, 1e4);
class rs extends ER {
 constructor(e, n, r, i, o) {
  super(e, n, i, o),
   (this.provider = r),
   (this.authWindow = null),
   (this.pollId = null),
   rs.currentPopupAction && rs.currentPopupAction.cancel(),
   (rs.currentPopupAction = this);
 }
 async executeNotNull() {
  const e = await this.execute();
  return te(e, this.auth, "internal-error"), e;
 }
 async onExecution() {
  Nr(this.filter.length === 1, "Popup operations only handle one event");
  const e = my();
  (this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e)),
   (this.authWindow.associatedEvent = e),
   this.resolver._originValidation(this.auth).catch((n) => {
    this.reject(n);
   }),
   this.resolver._isIframeWebStorageSupported(this.auth, (n) => {
    n || this.reject(rr(this.auth, "web-storage-unsupported"));
   }),
   this.pollUserCancellation();
 }
 get eventId() {
  var e;
  return ((e = this.authWindow) === null || e === void 0 ? void 0 : e.associatedEvent) || null;
 }
 cancel() {
  this.reject(rr(this.auth, "cancelled-popup-request"));
 }
 cleanUp() {
  this.authWindow && this.authWindow.close(),
   this.pollId && window.clearTimeout(this.pollId),
   (this.authWindow = null),
   (this.pollId = null),
   (rs.currentPopupAction = null);
 }
 pollUserCancellation() {
  const e = () => {
   var n, r;
   if (
    !((r = (n = this.authWindow) === null || n === void 0 ? void 0 : n.window) === null || r === void 0) &&
    r.closed
   ) {
    this.pollId = window.setTimeout(() => {
     (this.pollId = null), this.reject(rr(this.auth, "popup-closed-by-user"));
    }, 8e3);
    return;
   }
   this.pollId = window.setTimeout(e, KO.get());
  };
  e();
 }
}
rs.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const JO = "pendingRedirect",
 Ec = new Map();
class YO extends ER {
 constructor(e, n, r = !1) {
  super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], n, void 0, r),
   (this.eventId = null);
 }
 async execute() {
  let e = Ec.get(this.auth._key());
  if (!e) {
   try {
    const r = (await QO(this.resolver, this.auth)) ? await super.execute() : null;
    e = () => Promise.resolve(r);
   } catch (n) {
    e = () => Promise.reject(n);
   }
   Ec.set(this.auth._key(), e);
  }
  return this.bypassAuthState || Ec.set(this.auth._key(), () => Promise.resolve(null)), e();
 }
 async onAuthEvent(e) {
  if (e.type === "signInViaRedirect") return super.onAuthEvent(e);
  if (e.type === "unknown") {
   this.resolve(null);
   return;
  }
  if (e.eventId) {
   const n = await this.auth._redirectUserForId(e.eventId);
   if (n) return (this.user = n), super.onAuthEvent(e);
   this.resolve(null);
  }
 }
 async onExecution() {}
 cleanUp() {}
}
async function QO(t, e) {
 const n = ZO(e),
  r = jO(t);
 if (!(await r._isAvailable())) return !1;
 const i = (await r._get(n)) === "true";
 return await r._remove(n), i;
}
function XO(t, e) {
 Ec.set(t._key(), e);
}
function jO(t) {
 return Tr(t._redirectPersistence);
}
function ZO(t) {
 return wc(JO, t.config.apiKey, t.name);
}
async function eF(t, e, n = !1) {
 if (Zn(t.app)) return Promise.reject(Ar(t));
 const r = bo(t),
  i = qO(r, e),
  s = await new YO(r, i, n).execute();
 return (
  s && !n && (delete s.user._redirectEventId, await r._persistUserIfCurrent(s.user), await r._setRedirectUser(null, e)),
  s
 );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const tF = 10 * 60 * 1e3;
class nF {
 constructor(e) {
  (this.auth = e),
   (this.cachedEventUids = new Set()),
   (this.consumers = new Set()),
   (this.queuedRedirectEvent = null),
   (this.hasHandledPotentialRedirect = !1),
   (this.lastProcessedEventTime = Date.now());
 }
 registerConsumer(e) {
  this.consumers.add(e),
   this.queuedRedirectEvent &&
    this.isEventForConsumer(this.queuedRedirectEvent, e) &&
    (this.sendToConsumer(this.queuedRedirectEvent, e),
    this.saveEventToCache(this.queuedRedirectEvent),
    (this.queuedRedirectEvent = null));
 }
 unregisterConsumer(e) {
  this.consumers.delete(e);
 }
 onEvent(e) {
  if (this.hasEventBeenHandled(e)) return !1;
  let n = !1;
  return (
   this.consumers.forEach((r) => {
    this.isEventForConsumer(e, r) && ((n = !0), this.sendToConsumer(e, r), this.saveEventToCache(e));
   }),
   this.hasHandledPotentialRedirect ||
    !rF(e) ||
    ((this.hasHandledPotentialRedirect = !0), n || ((this.queuedRedirectEvent = e), (n = !0))),
   n
  );
 }
 sendToConsumer(e, n) {
  var r;
  if (e.error && !TR(e)) {
   const i = ((r = e.error.code) === null || r === void 0 ? void 0 : r.split("auth/")[1]) || "internal-error";
   n.onError(rr(this.auth, i));
  } else n.onAuthEvent(e);
 }
 isEventForConsumer(e, n) {
  const r = n.eventId === null || (!!e.eventId && e.eventId === n.eventId);
  return n.filter.includes(e.type) && r;
 }
 hasEventBeenHandled(e) {
  return (
   Date.now() - this.lastProcessedEventTime >= tF && this.cachedEventUids.clear(), this.cachedEventUids.has(I0(e))
  );
 }
 saveEventToCache(e) {
  this.cachedEventUids.add(I0(e)), (this.lastProcessedEventTime = Date.now());
 }
}
function I0(t) {
 return [t.type, t.eventId, t.sessionId, t.tenantId].filter((e) => e).join("-");
}
function TR({ type: t, error: e }) {
 return t === "unknown" && (e == null ? void 0 : e.code) === "auth/no-auth-event";
}
function rF(t) {
 switch (t.type) {
  case "signInViaRedirect":
  case "linkViaRedirect":
  case "reauthViaRedirect":
   return !0;
  case "unknown":
   return TR(t);
  default:
   return !1;
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function iF(t, e = {}) {
 return Ur(t, "GET", "/v1/projects", e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const oF = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
 sF = /^https?/;
async function aF(t) {
 if (t.config.emulator) return;
 const { authorizedDomains: e } = await iF(t);
 for (const n of e)
  try {
   if (lF(n)) return;
  } catch {}
 qn(t, "unauthorized-domain");
}
function lF(t) {
 const e = am(),
  { protocol: n, hostname: r } = new URL(e);
 if (t.startsWith("chrome-extension://")) {
  const s = new URL(t);
  return s.hostname === "" && r === ""
   ? n === "chrome-extension:" && t.replace("chrome-extension://", "") === e.replace("chrome-extension://", "")
   : n === "chrome-extension:" && s.hostname === r;
 }
 if (!sF.test(n)) return !1;
 if (oF.test(t)) return r === t;
 const i = t.replace(/\./g, "\\.");
 return new RegExp("^(.+\\." + i + "|" + i + ")$", "i").test(r);
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const uF = new zl(3e4, 6e4);
function S0() {
 const t = ir().___jsl;
 if (t != null && t.H) {
  for (const e of Object.keys(t.H))
   if (((t.H[e].r = t.H[e].r || []), (t.H[e].L = t.H[e].L || []), (t.H[e].r = [...t.H[e].L]), t.CP))
    for (let n = 0; n < t.CP.length; n++) t.CP[n] = null;
 }
}
function cF(t) {
 return new Promise((e, n) => {
  var r, i, o;
  function s() {
   S0(),
    gapi.load("gapi.iframes", {
     callback: () => {
      e(gapi.iframes.getContext());
     },
     ontimeout: () => {
      S0(), n(rr(t, "network-request-failed"));
     },
     timeout: uF.get(),
    });
  }
  if (!((i = (r = ir().gapi) === null || r === void 0 ? void 0 : r.iframes) === null || i === void 0) && i.Iframe)
   e(gapi.iframes.getContext());
  else if (!((o = ir().gapi) === null || o === void 0) && o.load) s();
  else {
   const a = tO("iframefcb");
   return (
    (ir()[a] = () => {
     gapi.load ? s() : n(rr(t, "network-request-failed"));
    }),
    aR(`${eO()}?onload=${a}`).catch((l) => n(l))
   );
  }
 }).catch((e) => {
  throw ((Tc = null), e);
 });
}
let Tc = null;
function dF(t) {
 return (Tc = Tc || cF(t)), Tc;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const fF = new zl(5e3, 15e3),
 hF = "__/auth/iframe",
 pF = "emulator/auth/iframe",
 mF = {
  style: { position: "absolute", top: "-100px", width: "1px", height: "1px" },
  "aria-hidden": "true",
  tabindex: "-1",
 },
 gF = new Map([
  ["identitytoolkit.googleapis.com", "p"],
  ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
  ["test-identitytoolkit.sandbox.googleapis.com", "t"],
 ]);
function yF(t) {
 const e = t.config;
 te(e.authDomain, t, "auth-domain-config-required");
 const n = e.emulator ? cy(e, pF) : `https://${t.config.authDomain}/${hF}`,
  r = { apiKey: e.apiKey, appName: t.name, v: ko },
  i = gF.get(t.config.apiHost);
 i && (r.eid = i);
 const o = t._getFrameworks();
 return o.length && (r.fw = o.join(",")), `${n}?${ql(r).slice(1)}`;
}
async function vF(t) {
 const e = await dF(t),
  n = ir().gapi;
 return (
  te(n, t, "internal-error"),
  e.open(
   {
    where: document.body,
    url: yF(t),
    messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
    attributes: mF,
    dontclear: !0,
   },
   (r) =>
    new Promise(async (i, o) => {
     await r.restyle({ setHideOnLeave: !1 });
     const s = rr(t, "network-request-failed"),
      a = ir().setTimeout(() => {
       o(s);
      }, fF.get());
     function l() {
      ir().clearTimeout(a), i(r);
     }
     r.ping(l).then(l, () => {
      o(s);
     });
    })
  )
 );
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const _F = { location: "yes", resizable: "yes", statusbar: "yes", toolbar: "no" },
 wF = 500,
 EF = 600,
 TF = "_blank",
 IF = "http://localhost";
class A0 {
 constructor(e) {
  (this.window = e), (this.associatedEvent = null);
 }
 close() {
  if (this.window)
   try {
    this.window.close();
   } catch {}
 }
}
function SF(t, e, n, r = wF, i = EF) {
 const o = Math.max((window.screen.availHeight - i) / 2, 0).toString(),
  s = Math.max((window.screen.availWidth - r) / 2, 0).toString();
 let a = "";
 const l = Object.assign(Object.assign({}, _F), { width: r.toString(), height: i.toString(), top: o, left: s }),
  u = Lt().toLowerCase();
 n && (a = eR(u) ? TF : n), jC(u) && ((e = e || IF), (l.scrollbars = "yes"));
 const h = Object.entries(l).reduce((m, [v, w]) => `${m}${v}=${w},`, "");
 if (zU(u) && a !== "_self") return AF(e || "", a), new A0(null);
 const p = window.open(e || "", a, h);
 te(p, t, "popup-blocked");
 try {
  p.focus();
 } catch {}
 return new A0(p);
}
function AF(t, e) {
 const n = document.createElement("a");
 (n.href = t), (n.target = e);
 const r = document.createEvent("MouseEvent");
 r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(r);
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const CF = "__/auth/handler",
 RF = "emulator/auth/handler",
 PF = encodeURIComponent("fac");
async function C0(t, e, n, r, i, o) {
 te(t.config.authDomain, t, "auth-domain-config-required"), te(t.config.apiKey, t, "invalid-api-key");
 const s = { apiKey: t.config.apiKey, appName: t.name, authType: n, redirectUrl: r, v: ko, eventId: i };
 if (e instanceof uR) {
  e.setDefaultLanguage(t.languageCode),
   (s.providerId = e.providerId || ""),
   cV(e.getCustomParameters()) || (s.customParameters = JSON.stringify(e.getCustomParameters()));
  for (const [h, p] of Object.entries({})) s[h] = p;
 }
 if (e instanceof Kl) {
  const h = e.getScopes().filter((p) => p !== "");
  h.length > 0 && (s.scopes = h.join(","));
 }
 t.tenantId && (s.tid = t.tenantId);
 const a = s;
 for (const h of Object.keys(a)) a[h] === void 0 && delete a[h];
 const l = await t._getAppCheckToken(),
  u = l ? `#${PF}=${encodeURIComponent(l)}` : "";
 return `${kF(t)}?${ql(a).slice(1)}${u}`;
}
function kF({ config: t }) {
 return t.emulator ? cy(t, RF) : `https://${t.authDomain}/${CF}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Fh = "webStorageSupport";
class bF {
 constructor() {
  (this.eventManagers = {}),
   (this.iframes = {}),
   (this.originValidationPromises = {}),
   (this._redirectPersistence = gR),
   (this._completeRedirectFn = eF),
   (this._overrideRedirectResult = XO);
 }
 async _openPopup(e, n, r, i) {
  var o;
  Nr(
   (o = this.eventManagers[e._key()]) === null || o === void 0 ? void 0 : o.manager,
   "_initialize() not called before _openPopup()"
  );
  const s = await C0(e, n, r, am(), i);
  return SF(e, s, my());
 }
 async _openRedirect(e, n, r, i) {
  await this._originValidation(e);
  const o = await C0(e, n, r, am(), i);
  return MO(o), new Promise(() => {});
 }
 _initialize(e) {
  const n = e._key();
  if (this.eventManagers[n]) {
   const { manager: i, promise: o } = this.eventManagers[n];
   return i ? Promise.resolve(i) : (Nr(o, "If manager is not set, promise should be"), o);
  }
  const r = this.initAndGetManager(e);
  return (
   (this.eventManagers[n] = { promise: r }),
   r.catch(() => {
    delete this.eventManagers[n];
   }),
   r
  );
 }
 async initAndGetManager(e) {
  const n = await vF(e),
   r = new nF(e);
  return (
   n.register(
    "authEvent",
    (i) => (
     te(i == null ? void 0 : i.authEvent, e, "invalid-auth-event"), { status: r.onEvent(i.authEvent) ? "ACK" : "ERROR" }
    ),
    gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER
   ),
   (this.eventManagers[e._key()] = { manager: r }),
   (this.iframes[e._key()] = n),
   r
  );
 }
 _isIframeWebStorageSupported(e, n) {
  this.iframes[e._key()].send(
   Fh,
   { type: Fh },
   (i) => {
    var o;
    const s = (o = i == null ? void 0 : i[0]) === null || o === void 0 ? void 0 : o[Fh];
    s !== void 0 && n(!!s), qn(e, "internal-error");
   },
   gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER
  );
 }
 _originValidation(e) {
  const n = e._key();
  return (
   this.originValidationPromises[n] || (this.originValidationPromises[n] = aF(e)), this.originValidationPromises[n]
  );
 }
 get _shouldInitProactively() {
  return oR() || ZC() || fy();
 }
}
const NF = bF;
var R0 = "@firebase/auth",
 P0 = "1.7.9";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class xF {
 constructor(e) {
  (this.auth = e), (this.internalListeners = new Map());
 }
 getUid() {
  var e;
  return this.assertAuthConfigured(), ((e = this.auth.currentUser) === null || e === void 0 ? void 0 : e.uid) || null;
 }
 async getToken(e) {
  return (
   this.assertAuthConfigured(),
   await this.auth._initializationPromise,
   this.auth.currentUser ? { accessToken: await this.auth.currentUser.getIdToken(e) } : null
  );
 }
 addAuthTokenListener(e) {
  if ((this.assertAuthConfigured(), this.internalListeners.has(e))) return;
  const n = this.auth.onIdTokenChanged((r) => {
   e((r == null ? void 0 : r.stsTokenManager.accessToken) || null);
  });
  this.internalListeners.set(e, n), this.updateProactiveRefresh();
 }
 removeAuthTokenListener(e) {
  this.assertAuthConfigured();
  const n = this.internalListeners.get(e);
  n && (this.internalListeners.delete(e), n(), this.updateProactiveRefresh());
 }
 assertAuthConfigured() {
  te(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth");
 }
 updateProactiveRefresh() {
  this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh();
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function MF(t) {
 switch (t) {
  case "Node":
   return "node";
  case "ReactNative":
   return "rn";
  case "Worker":
   return "webworker";
  case "Cordova":
   return "cordova";
  case "WebExtension":
   return "web-extension";
  default:
   return;
 }
}
function DF(t) {
 Hn(
  new Pn(
   "auth",
   (e, { options: n }) => {
    const r = e.getProvider("app").getImmediate(),
     i = e.getProvider("heartbeat"),
     o = e.getProvider("app-check-internal"),
     { apiKey: s, authDomain: a } = r.options;
    te(s && !s.includes(":"), "invalid-api-key", { appName: r.name });
    const l = {
      apiKey: s,
      authDomain: a,
      clientPlatform: t,
      apiHost: "identitytoolkit.googleapis.com",
      tokenApiHost: "securetoken.googleapis.com",
      apiScheme: "https",
      sdkClientVersion: sR(t),
     },
     u = new XU(r, i, o, l);
    return sO(u, n), u;
   },
   "PUBLIC"
  )
   .setInstantiationMode("EXPLICIT")
   .setInstanceCreatedCallback((e, n, r) => {
    e.getProvider("auth-internal").initialize();
   })
 ),
  Hn(
   new Pn(
    "auth-internal",
    (e) => {
     const n = bo(e.getProvider("auth").getImmediate());
     return ((r) => new xF(r))(n);
    },
    "PRIVATE"
   ).setInstantiationMode("EXPLICIT")
  ),
  rn(R0, P0, MF(t)),
  rn(R0, P0, "esm2017");
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const LF = 5 * 60,
 VF = LC("authIdTokenMaxAge") || LF;
let k0 = null;
const UF = (t) => async (e) => {
 const n = e && (await e.getIdTokenResult()),
  r = n && (new Date().getTime() - Date.parse(n.issuedAtTime)) / 1e3;
 if (r && r > VF) return;
 const i = n == null ? void 0 : n.token;
 k0 !== i &&
  ((k0 = i), await fetch(t, { method: i ? "POST" : "DELETE", headers: i ? { Authorization: `Bearer ${i}` } : {} }));
};
function IR(t = Gl()) {
 const e = Mi(t, "auth");
 if (e.isInitialized()) return e.getImmediate();
 const n = oO(t, { popupRedirectResolver: NF, persistence: [HO, bO, gR] }),
  r = LC("authTokenSyncURL");
 if (r && typeof isSecureContext == "boolean" && isSecureContext) {
  const o = new URL(r, location.origin);
  if (location.origin === o.origin) {
   const s = UF(o.toString());
   CO(n, s, () => s(n.currentUser)), AO(n, (a) => s(a));
  }
 }
 const i = xC("auth");
 return i && aO(n, `http://${i}`), n;
}
function OF() {
 var t, e;
 return (e = (t = document.getElementsByTagName("head")) === null || t === void 0 ? void 0 : t[0]) !== null &&
  e !== void 0
  ? e
  : document;
}
jU({
 loadJS(t) {
  return new Promise((e, n) => {
   const r = document.createElement("script");
   r.setAttribute("src", t),
    (r.onload = e),
    (r.onerror = (i) => {
     const o = rr("internal-error");
     (o.customData = i), n(o);
    }),
    (r.type = "text/javascript"),
    (r.charset = "UTF-8"),
    OF().appendChild(r);
  });
 },
 gapiScript: "https://apis.google.com/js/api.js",
 recaptchaV2Script: "https://www.google.com/recaptcha/api.js",
 recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render=",
});
DF("Browser");
var b0 =
 typeof globalThis < "u"
  ? globalThis
  : typeof window < "u"
    ? window
    : typeof global < "u"
      ? global
      : typeof self < "u"
        ? self
        : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/ var oo, SR;
(function () {
 var t;
 /** @license

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/ function e(P, I) {
  function R() {}
  (R.prototype = I.prototype),
   (P.D = I.prototype),
   (P.prototype = new R()),
   (P.prototype.constructor = P),
   (P.C = function (k, x, D) {
    for (var b = Array(arguments.length - 2), se = 2; se < arguments.length; se++) b[se - 2] = arguments[se];
    return I.prototype[x].apply(k, b);
   });
 }
 function n() {
  this.blockSize = -1;
 }
 function r() {
  (this.blockSize = -1),
   (this.blockSize = 64),
   (this.g = Array(4)),
   (this.B = Array(this.blockSize)),
   (this.o = this.h = 0),
   this.s();
 }
 e(r, n),
  (r.prototype.s = function () {
   (this.g[0] = 1732584193),
    (this.g[1] = 4023233417),
    (this.g[2] = 2562383102),
    (this.g[3] = 271733878),
    (this.o = this.h = 0);
  });
 function i(P, I, R) {
  R || (R = 0);
  var k = Array(16);
  if (typeof I == "string")
   for (var x = 0; 16 > x; ++x)
    k[x] = I.charCodeAt(R++) | (I.charCodeAt(R++) << 8) | (I.charCodeAt(R++) << 16) | (I.charCodeAt(R++) << 24);
  else for (x = 0; 16 > x; ++x) k[x] = I[R++] | (I[R++] << 8) | (I[R++] << 16) | (I[R++] << 24);
  (I = P.g[0]), (R = P.g[1]), (x = P.g[2]);
  var D = P.g[3],
   b = (I + (D ^ (R & (x ^ D))) + k[0] + 3614090360) & 4294967295;
  (I = R + (((b << 7) & 4294967295) | (b >>> 25))),
   (b = (D + (x ^ (I & (R ^ x))) + k[1] + 3905402710) & 4294967295),
   (D = I + (((b << 12) & 4294967295) | (b >>> 20))),
   (b = (x + (R ^ (D & (I ^ R))) + k[2] + 606105819) & 4294967295),
   (x = D + (((b << 17) & 4294967295) | (b >>> 15))),
   (b = (R + (I ^ (x & (D ^ I))) + k[3] + 3250441966) & 4294967295),
   (R = x + (((b << 22) & 4294967295) | (b >>> 10))),
   (b = (I + (D ^ (R & (x ^ D))) + k[4] + 4118548399) & 4294967295),
   (I = R + (((b << 7) & 4294967295) | (b >>> 25))),
   (b = (D + (x ^ (I & (R ^ x))) + k[5] + 1200080426) & 4294967295),
   (D = I + (((b << 12) & 4294967295) | (b >>> 20))),
   (b = (x + (R ^ (D & (I ^ R))) + k[6] + 2821735955) & 4294967295),
   (x = D + (((b << 17) & 4294967295) | (b >>> 15))),
   (b = (R + (I ^ (x & (D ^ I))) + k[7] + 4249261313) & 4294967295),
   (R = x + (((b << 22) & 4294967295) | (b >>> 10))),
   (b = (I + (D ^ (R & (x ^ D))) + k[8] + 1770035416) & 4294967295),
   (I = R + (((b << 7) & 4294967295) | (b >>> 25))),
   (b = (D + (x ^ (I & (R ^ x))) + k[9] + 2336552879) & 4294967295),
   (D = I + (((b << 12) & 4294967295) | (b >>> 20))),
   (b = (x + (R ^ (D & (I ^ R))) + k[10] + 4294925233) & 4294967295),
   (x = D + (((b << 17) & 4294967295) | (b >>> 15))),
   (b = (R + (I ^ (x & (D ^ I))) + k[11] + 2304563134) & 4294967295),
   (R = x + (((b << 22) & 4294967295) | (b >>> 10))),
   (b = (I + (D ^ (R & (x ^ D))) + k[12] + 1804603682) & 4294967295),
   (I = R + (((b << 7) & 4294967295) | (b >>> 25))),
   (b = (D + (x ^ (I & (R ^ x))) + k[13] + 4254626195) & 4294967295),
   (D = I + (((b << 12) & 4294967295) | (b >>> 20))),
   (b = (x + (R ^ (D & (I ^ R))) + k[14] + 2792965006) & 4294967295),
   (x = D + (((b << 17) & 4294967295) | (b >>> 15))),
   (b = (R + (I ^ (x & (D ^ I))) + k[15] + 1236535329) & 4294967295),
   (R = x + (((b << 22) & 4294967295) | (b >>> 10))),
   (b = (I + (x ^ (D & (R ^ x))) + k[1] + 4129170786) & 4294967295),
   (I = R + (((b << 5) & 4294967295) | (b >>> 27))),
   (b = (D + (R ^ (x & (I ^ R))) + k[6] + 3225465664) & 4294967295),
   (D = I + (((b << 9) & 4294967295) | (b >>> 23))),
   (b = (x + (I ^ (R & (D ^ I))) + k[11] + 643717713) & 4294967295),
   (x = D + (((b << 14) & 4294967295) | (b >>> 18))),
   (b = (R + (D ^ (I & (x ^ D))) + k[0] + 3921069994) & 4294967295),
   (R = x + (((b << 20) & 4294967295) | (b >>> 12))),
   (b = (I + (x ^ (D & (R ^ x))) + k[5] + 3593408605) & 4294967295),
   (I = R + (((b << 5) & 4294967295) | (b >>> 27))),
   (b = (D + (R ^ (x & (I ^ R))) + k[10] + 38016083) & 4294967295),
   (D = I + (((b << 9) & 4294967295) | (b >>> 23))),
   (b = (x + (I ^ (R & (D ^ I))) + k[15] + 3634488961) & 4294967295),
   (x = D + (((b << 14) & 4294967295) | (b >>> 18))),
   (b = (R + (D ^ (I & (x ^ D))) + k[4] + 3889429448) & 4294967295),
   (R = x + (((b << 20) & 4294967295) | (b >>> 12))),
   (b = (I + (x ^ (D & (R ^ x))) + k[9] + 568446438) & 4294967295),
   (I = R + (((b << 5) & 4294967295) | (b >>> 27))),
   (b = (D + (R ^ (x & (I ^ R))) + k[14] + 3275163606) & 4294967295),
   (D = I + (((b << 9) & 4294967295) | (b >>> 23))),
   (b = (x + (I ^ (R & (D ^ I))) + k[3] + 4107603335) & 4294967295),
   (x = D + (((b << 14) & 4294967295) | (b >>> 18))),
   (b = (R + (D ^ (I & (x ^ D))) + k[8] + 1163531501) & 4294967295),
   (R = x + (((b << 20) & 4294967295) | (b >>> 12))),
   (b = (I + (x ^ (D & (R ^ x))) + k[13] + 2850285829) & 4294967295),
   (I = R + (((b << 5) & 4294967295) | (b >>> 27))),
   (b = (D + (R ^ (x & (I ^ R))) + k[2] + 4243563512) & 4294967295),
   (D = I + (((b << 9) & 4294967295) | (b >>> 23))),
   (b = (x + (I ^ (R & (D ^ I))) + k[7] + 1735328473) & 4294967295),
   (x = D + (((b << 14) & 4294967295) | (b >>> 18))),
   (b = (R + (D ^ (I & (x ^ D))) + k[12] + 2368359562) & 4294967295),
   (R = x + (((b << 20) & 4294967295) | (b >>> 12))),
   (b = (I + (R ^ x ^ D) + k[5] + 4294588738) & 4294967295),
   (I = R + (((b << 4) & 4294967295) | (b >>> 28))),
   (b = (D + (I ^ R ^ x) + k[8] + 2272392833) & 4294967295),
   (D = I + (((b << 11) & 4294967295) | (b >>> 21))),
   (b = (x + (D ^ I ^ R) + k[11] + 1839030562) & 4294967295),
   (x = D + (((b << 16) & 4294967295) | (b >>> 16))),
   (b = (R + (x ^ D ^ I) + k[14] + 4259657740) & 4294967295),
   (R = x + (((b << 23) & 4294967295) | (b >>> 9))),
   (b = (I + (R ^ x ^ D) + k[1] + 2763975236) & 4294967295),
   (I = R + (((b << 4) & 4294967295) | (b >>> 28))),
   (b = (D + (I ^ R ^ x) + k[4] + 1272893353) & 4294967295),
   (D = I + (((b << 11) & 4294967295) | (b >>> 21))),
   (b = (x + (D ^ I ^ R) + k[7] + 4139469664) & 4294967295),
   (x = D + (((b << 16) & 4294967295) | (b >>> 16))),
   (b = (R + (x ^ D ^ I) + k[10] + 3200236656) & 4294967295),
   (R = x + (((b << 23) & 4294967295) | (b >>> 9))),
   (b = (I + (R ^ x ^ D) + k[13] + 681279174) & 4294967295),
   (I = R + (((b << 4) & 4294967295) | (b >>> 28))),
   (b = (D + (I ^ R ^ x) + k[0] + 3936430074) & 4294967295),
   (D = I + (((b << 11) & 4294967295) | (b >>> 21))),
   (b = (x + (D ^ I ^ R) + k[3] + 3572445317) & 4294967295),
   (x = D + (((b << 16) & 4294967295) | (b >>> 16))),
   (b = (R + (x ^ D ^ I) + k[6] + 76029189) & 4294967295),
   (R = x + (((b << 23) & 4294967295) | (b >>> 9))),
   (b = (I + (R ^ x ^ D) + k[9] + 3654602809) & 4294967295),
   (I = R + (((b << 4) & 4294967295) | (b >>> 28))),
   (b = (D + (I ^ R ^ x) + k[12] + 3873151461) & 4294967295),
   (D = I + (((b << 11) & 4294967295) | (b >>> 21))),
   (b = (x + (D ^ I ^ R) + k[15] + 530742520) & 4294967295),
   (x = D + (((b << 16) & 4294967295) | (b >>> 16))),
   (b = (R + (x ^ D ^ I) + k[2] + 3299628645) & 4294967295),
   (R = x + (((b << 23) & 4294967295) | (b >>> 9))),
   (b = (I + (x ^ (R | ~D)) + k[0] + 4096336452) & 4294967295),
   (I = R + (((b << 6) & 4294967295) | (b >>> 26))),
   (b = (D + (R ^ (I | ~x)) + k[7] + 1126891415) & 4294967295),
   (D = I + (((b << 10) & 4294967295) | (b >>> 22))),
   (b = (x + (I ^ (D | ~R)) + k[14] + 2878612391) & 4294967295),
   (x = D + (((b << 15) & 4294967295) | (b >>> 17))),
   (b = (R + (D ^ (x | ~I)) + k[5] + 4237533241) & 4294967295),
   (R = x + (((b << 21) & 4294967295) | (b >>> 11))),
   (b = (I + (x ^ (R | ~D)) + k[12] + 1700485571) & 4294967295),
   (I = R + (((b << 6) & 4294967295) | (b >>> 26))),
   (b = (D + (R ^ (I | ~x)) + k[3] + 2399980690) & 4294967295),
   (D = I + (((b << 10) & 4294967295) | (b >>> 22))),
   (b = (x + (I ^ (D | ~R)) + k[10] + 4293915773) & 4294967295),
   (x = D + (((b << 15) & 4294967295) | (b >>> 17))),
   (b = (R + (D ^ (x | ~I)) + k[1] + 2240044497) & 4294967295),
   (R = x + (((b << 21) & 4294967295) | (b >>> 11))),
   (b = (I + (x ^ (R | ~D)) + k[8] + 1873313359) & 4294967295),
   (I = R + (((b << 6) & 4294967295) | (b >>> 26))),
   (b = (D + (R ^ (I | ~x)) + k[15] + 4264355552) & 4294967295),
   (D = I + (((b << 10) & 4294967295) | (b >>> 22))),
   (b = (x + (I ^ (D | ~R)) + k[6] + 2734768916) & 4294967295),
   (x = D + (((b << 15) & 4294967295) | (b >>> 17))),
   (b = (R + (D ^ (x | ~I)) + k[13] + 1309151649) & 4294967295),
   (R = x + (((b << 21) & 4294967295) | (b >>> 11))),
   (b = (I + (x ^ (R | ~D)) + k[4] + 4149444226) & 4294967295),
   (I = R + (((b << 6) & 4294967295) | (b >>> 26))),
   (b = (D + (R ^ (I | ~x)) + k[11] + 3174756917) & 4294967295),
   (D = I + (((b << 10) & 4294967295) | (b >>> 22))),
   (b = (x + (I ^ (D | ~R)) + k[2] + 718787259) & 4294967295),
   (x = D + (((b << 15) & 4294967295) | (b >>> 17))),
   (b = (R + (D ^ (x | ~I)) + k[9] + 3951481745) & 4294967295),
   (P.g[0] = (P.g[0] + I) & 4294967295),
   (P.g[1] = (P.g[1] + (x + (((b << 21) & 4294967295) | (b >>> 11)))) & 4294967295),
   (P.g[2] = (P.g[2] + x) & 4294967295),
   (P.g[3] = (P.g[3] + D) & 4294967295);
 }
 (r.prototype.u = function (P, I) {
  I === void 0 && (I = P.length);
  for (var R = I - this.blockSize, k = this.B, x = this.h, D = 0; D < I; ) {
   if (x == 0) for (; D <= R; ) i(this, P, D), (D += this.blockSize);
   if (typeof P == "string") {
    for (; D < I; )
     if (((k[x++] = P.charCodeAt(D++)), x == this.blockSize)) {
      i(this, k), (x = 0);
      break;
     }
   } else
    for (; D < I; )
     if (((k[x++] = P[D++]), x == this.blockSize)) {
      i(this, k), (x = 0);
      break;
     }
  }
  (this.h = x), (this.o += I);
 }),
  (r.prototype.v = function () {
   var P = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
   P[0] = 128;
   for (var I = 1; I < P.length - 8; ++I) P[I] = 0;
   var R = 8 * this.o;
   for (I = P.length - 8; I < P.length; ++I) (P[I] = R & 255), (R /= 256);
   for (this.u(P), P = Array(16), I = R = 0; 4 > I; ++I)
    for (var k = 0; 32 > k; k += 8) P[R++] = (this.g[I] >>> k) & 255;
   return P;
  });
 function o(P, I) {
  var R = a;
  return Object.prototype.hasOwnProperty.call(R, P) ? R[P] : (R[P] = I(P));
 }
 function s(P, I) {
  this.h = I;
  for (var R = [], k = !0, x = P.length - 1; 0 <= x; x--) {
   var D = P[x] | 0;
   (k && D == I) || ((R[x] = D), (k = !1));
  }
  this.g = R;
 }
 var a = {};
 function l(P) {
  return -128 <= P && 128 > P
   ? o(P, function (I) {
      return new s([I | 0], 0 > I ? -1 : 0);
     })
   : new s([P | 0], 0 > P ? -1 : 0);
 }
 function u(P) {
  if (isNaN(P) || !isFinite(P)) return p;
  if (0 > P) return A(u(-P));
  for (var I = [], R = 1, k = 0; P >= R; k++) (I[k] = (P / R) | 0), (R *= 4294967296);
  return new s(I, 0);
 }
 function h(P, I) {
  if (P.length == 0) throw Error("number format error: empty string");
  if (((I = I || 10), 2 > I || 36 < I)) throw Error("radix out of range: " + I);
  if (P.charAt(0) == "-") return A(h(P.substring(1), I));
  if (0 <= P.indexOf("-")) throw Error('number format error: interior "-" character');
  for (var R = u(Math.pow(I, 8)), k = p, x = 0; x < P.length; x += 8) {
   var D = Math.min(8, P.length - x),
    b = parseInt(P.substring(x, x + D), I);
   8 > D ? ((D = u(Math.pow(I, D))), (k = k.j(D).add(u(b)))) : ((k = k.j(R)), (k = k.add(u(b))));
  }
  return k;
 }
 var p = l(0),
  m = l(1),
  v = l(16777216);
 (t = s.prototype),
  (t.m = function () {
   if (C(this)) return -A(this).m();
   for (var P = 0, I = 1, R = 0; R < this.g.length; R++) {
    var k = this.i(R);
    (P += (0 <= k ? k : 4294967296 + k) * I), (I *= 4294967296);
   }
   return P;
  }),
  (t.toString = function (P) {
   if (((P = P || 10), 2 > P || 36 < P)) throw Error("radix out of range: " + P);
   if (w(this)) return "0";
   if (C(this)) return "-" + A(this).toString(P);
   for (var I = u(Math.pow(P, 6)), R = this, k = ""; ; ) {
    var x = N(R, I).g;
    R = T(R, x.j(I));
    var D = ((0 < R.g.length ? R.g[0] : R.h) >>> 0).toString(P);
    if (((R = x), w(R))) return D + k;
    for (; 6 > D.length; ) D = "0" + D;
    k = D + k;
   }
  }),
  (t.i = function (P) {
   return 0 > P ? 0 : P < this.g.length ? this.g[P] : this.h;
  });
 function w(P) {
  if (P.h != 0) return !1;
  for (var I = 0; I < P.g.length; I++) if (P.g[I] != 0) return !1;
  return !0;
 }
 function C(P) {
  return P.h == -1;
 }
 t.l = function (P) {
  return (P = T(this, P)), C(P) ? -1 : w(P) ? 0 : 1;
 };
 function A(P) {
  for (var I = P.g.length, R = [], k = 0; k < I; k++) R[k] = ~P.g[k];
  return new s(R, ~P.h).add(m);
 }
 (t.abs = function () {
  return C(this) ? A(this) : this;
 }),
  (t.add = function (P) {
   for (var I = Math.max(this.g.length, P.g.length), R = [], k = 0, x = 0; x <= I; x++) {
    var D = k + (this.i(x) & 65535) + (P.i(x) & 65535),
     b = (D >>> 16) + (this.i(x) >>> 16) + (P.i(x) >>> 16);
    (k = b >>> 16), (D &= 65535), (b &= 65535), (R[x] = (b << 16) | D);
   }
   return new s(R, R[R.length - 1] & -2147483648 ? -1 : 0);
  });
 function T(P, I) {
  return P.add(A(I));
 }
 t.j = function (P) {
  if (w(this) || w(P)) return p;
  if (C(this)) return C(P) ? A(this).j(A(P)) : A(A(this).j(P));
  if (C(P)) return A(this.j(A(P)));
  if (0 > this.l(v) && 0 > P.l(v)) return u(this.m() * P.m());
  for (var I = this.g.length + P.g.length, R = [], k = 0; k < 2 * I; k++) R[k] = 0;
  for (k = 0; k < this.g.length; k++)
   for (var x = 0; x < P.g.length; x++) {
    var D = this.i(k) >>> 16,
     b = this.i(k) & 65535,
     se = P.i(x) >>> 16,
     Jt = P.i(x) & 65535;
    (R[2 * k + 2 * x] += b * Jt),
     _(R, 2 * k + 2 * x),
     (R[2 * k + 2 * x + 1] += D * Jt),
     _(R, 2 * k + 2 * x + 1),
     (R[2 * k + 2 * x + 1] += b * se),
     _(R, 2 * k + 2 * x + 1),
     (R[2 * k + 2 * x + 2] += D * se),
     _(R, 2 * k + 2 * x + 2);
   }
  for (k = 0; k < I; k++) R[k] = (R[2 * k + 1] << 16) | R[2 * k];
  for (k = I; k < 2 * I; k++) R[k] = 0;
  return new s(R, 0);
 };
 function _(P, I) {
  for (; (P[I] & 65535) != P[I]; ) (P[I + 1] += P[I] >>> 16), (P[I] &= 65535), I++;
 }
 function E(P, I) {
  (this.g = P), (this.h = I);
 }
 function N(P, I) {
  if (w(I)) throw Error("division by zero");
  if (w(P)) return new E(p, p);
  if (C(P)) return (I = N(A(P), I)), new E(A(I.g), A(I.h));
  if (C(I)) return (I = N(P, A(I))), new E(A(I.g), I.h);
  if (30 < P.g.length) {
   if (C(P) || C(I)) throw Error("slowDivide_ only works with positive integers.");
   for (var R = m, k = I; 0 >= k.l(P); ) (R = M(R)), (k = M(k));
   var x = F(R, 1),
    D = F(k, 1);
   for (k = F(k, 2), R = F(R, 2); !w(k); ) {
    var b = D.add(k);
    0 >= b.l(P) && ((x = x.add(R)), (D = b)), (k = F(k, 1)), (R = F(R, 1));
   }
   return (I = T(P, x.j(I))), new E(x, I);
  }
  for (x = p; 0 <= P.l(I); ) {
   for (
    R = Math.max(1, Math.floor(P.m() / I.m())),
     k = Math.ceil(Math.log(R) / Math.LN2),
     k = 48 >= k ? 1 : Math.pow(2, k - 48),
     D = u(R),
     b = D.j(I);
    C(b) || 0 < b.l(P);

   )
    (R -= k), (D = u(R)), (b = D.j(I));
   w(D) && (D = m), (x = x.add(D)), (P = T(P, b));
  }
  return new E(x, P);
 }
 (t.A = function (P) {
  return N(this, P).h;
 }),
  (t.and = function (P) {
   for (var I = Math.max(this.g.length, P.g.length), R = [], k = 0; k < I; k++) R[k] = this.i(k) & P.i(k);
   return new s(R, this.h & P.h);
  }),
  (t.or = function (P) {
   for (var I = Math.max(this.g.length, P.g.length), R = [], k = 0; k < I; k++) R[k] = this.i(k) | P.i(k);
   return new s(R, this.h | P.h);
  }),
  (t.xor = function (P) {
   for (var I = Math.max(this.g.length, P.g.length), R = [], k = 0; k < I; k++) R[k] = this.i(k) ^ P.i(k);
   return new s(R, this.h ^ P.h);
  });
 function M(P) {
  for (var I = P.g.length + 1, R = [], k = 0; k < I; k++) R[k] = (P.i(k) << 1) | (P.i(k - 1) >>> 31);
  return new s(R, P.h);
 }
 function F(P, I) {
  var R = I >> 5;
  I %= 32;
  for (var k = P.g.length - R, x = [], D = 0; D < k; D++)
   x[D] = 0 < I ? (P.i(D + R) >>> I) | (P.i(D + R + 1) << (32 - I)) : P.i(D + R);
  return new s(x, P.h);
 }
 (r.prototype.digest = r.prototype.v),
  (r.prototype.reset = r.prototype.s),
  (r.prototype.update = r.prototype.u),
  (SR = r),
  (s.prototype.add = s.prototype.add),
  (s.prototype.multiply = s.prototype.j),
  (s.prototype.modulo = s.prototype.A),
  (s.prototype.compare = s.prototype.l),
  (s.prototype.toNumber = s.prototype.m),
  (s.prototype.toString = s.prototype.toString),
  (s.prototype.getBits = s.prototype.i),
  (s.fromNumber = u),
  (s.fromString = h),
  (oo = s);
}).apply(typeof b0 < "u" ? b0 : typeof self < "u" ? self : typeof window < "u" ? window : {});
var zu =
 typeof globalThis < "u"
  ? globalThis
  : typeof window < "u"
    ? window
    : typeof global < "u"
      ? global
      : typeof self < "u"
        ? self
        : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/ var AR, xa, CR, Ic, dm, RR, PR, kR;
(function () {
 var t,
  e =
   typeof Object.defineProperties == "function"
    ? Object.defineProperty
    : function (f, g, y) {
       return f == Array.prototype || f == Object.prototype || (f[g] = y.value), f;
      };
 function n(f) {
  f = [
   typeof globalThis == "object" && globalThis,
   f,
   typeof window == "object" && window,
   typeof self == "object" && self,
   typeof zu == "object" && zu,
  ];
  for (var g = 0; g < f.length; ++g) {
   var y = f[g];
   if (y && y.Math == Math) return y;
  }
  throw Error("Cannot find global object");
 }
 var r = n(this);
 function i(f, g) {
  if (g)
   e: {
    var y = r;
    f = f.split(".");
    for (var S = 0; S < f.length - 1; S++) {
     var V = f[S];
     if (!(V in y)) break e;
     y = y[V];
    }
    (f = f[f.length - 1]),
     (S = y[f]),
     (g = g(S)),
     g != S && g != null && e(y, f, { configurable: !0, writable: !0, value: g });
   }
 }
 function o(f, g) {
  f instanceof String && (f += "");
  var y = 0,
   S = !1,
   V = {
    next: function () {
     if (!S && y < f.length) {
      var U = y++;
      return { value: g(U, f[U]), done: !1 };
     }
     return (S = !0), { done: !0, value: void 0 };
    },
   };
  return (
   (V[Symbol.iterator] = function () {
    return V;
   }),
   V
  );
 }
 i("Array.prototype.values", function (f) {
  return (
   f ||
   function () {
    return o(this, function (g, y) {
     return y;
    });
   }
  );
 });
 /** @license

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/ var s = s || {},
  a = this || self;
 function l(f) {
  var g = typeof f;
  return (
   (g = g != "object" ? g : f ? (Array.isArray(f) ? "array" : g) : "null"),
   g == "array" || (g == "object" && typeof f.length == "number")
  );
 }
 function u(f) {
  var g = typeof f;
  return (g == "object" && f != null) || g == "function";
 }
 function h(f, g, y) {
  return f.call.apply(f.bind, arguments);
 }
 function p(f, g, y) {
  if (!f) throw Error();
  if (2 < arguments.length) {
   var S = Array.prototype.slice.call(arguments, 2);
   return function () {
    var V = Array.prototype.slice.call(arguments);
    return Array.prototype.unshift.apply(V, S), f.apply(g, V);
   };
  }
  return function () {
   return f.apply(g, arguments);
  };
 }
 function m(f, g, y) {
  return (
   (m = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? h : p),
   m.apply(null, arguments)
  );
 }
 function v(f, g) {
  var y = Array.prototype.slice.call(arguments, 1);
  return function () {
   var S = y.slice();
   return S.push.apply(S, arguments), f.apply(this, S);
  };
 }
 function w(f, g) {
  function y() {}
  (y.prototype = g.prototype),
   (f.aa = g.prototype),
   (f.prototype = new y()),
   (f.prototype.constructor = f),
   (f.Qb = function (S, V, U) {
    for (var G = Array(arguments.length - 2), Ce = 2; Ce < arguments.length; Ce++) G[Ce - 2] = arguments[Ce];
    return g.prototype[V].apply(S, G);
   });
 }
 function C(f) {
  const g = f.length;
  if (0 < g) {
   const y = Array(g);
   for (let S = 0; S < g; S++) y[S] = f[S];
   return y;
  }
  return [];
 }
 function A(f, g) {
  for (let y = 1; y < arguments.length; y++) {
   const S = arguments[y];
   if (l(S)) {
    const V = f.length || 0,
     U = S.length || 0;
    f.length = V + U;
    for (let G = 0; G < U; G++) f[V + G] = S[G];
   } else f.push(S);
  }
 }
 class T {
  constructor(g, y) {
   (this.i = g), (this.j = y), (this.h = 0), (this.g = null);
  }
  get() {
   let g;
   return 0 < this.h ? (this.h--, (g = this.g), (this.g = g.next), (g.next = null)) : (g = this.i()), g;
  }
 }
 function _(f) {
  return /^[\s\xa0]*$/.test(f);
 }
 function E() {
  var f = a.navigator;
  return f && (f = f.userAgent) ? f : "";
 }
 function N(f) {
  return N[" "](f), f;
 }
 N[" "] = function () {};
 var M =
  E().indexOf("Gecko") != -1 &&
  !(E().toLowerCase().indexOf("webkit") != -1 && E().indexOf("Edge") == -1) &&
  !(E().indexOf("Trident") != -1 || E().indexOf("MSIE") != -1) &&
  E().indexOf("Edge") == -1;
 function F(f, g, y) {
  for (const S in f) g.call(y, f[S], S, f);
 }
 function P(f, g) {
  for (const y in f) g.call(void 0, f[y], y, f);
 }
 function I(f) {
  const g = {};
  for (const y in f) g[y] = f[y];
  return g;
 }
 const R = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
 function k(f, g) {
  let y, S;
  for (let V = 1; V < arguments.length; V++) {
   S = arguments[V];
   for (y in S) f[y] = S[y];
   for (let U = 0; U < R.length; U++) (y = R[U]), Object.prototype.hasOwnProperty.call(S, y) && (f[y] = S[y]);
  }
 }
 function x(f) {
  var g = 1;
  f = f.split(":");
  const y = [];
  for (; 0 < g && f.length; ) y.push(f.shift()), g--;
  return f.length && y.push(f.join(":")), y;
 }
 function D(f) {
  a.setTimeout(() => {
   throw f;
  }, 0);
 }
 function b() {
  var f = Z;
  let g = null;
  return f.g && ((g = f.g), (f.g = f.g.next), f.g || (f.h = null), (g.next = null)), g;
 }
 class se {
  constructor() {
   this.h = this.g = null;
  }
  add(g, y) {
   const S = Jt.get();
   S.set(g, y), this.h ? (this.h.next = S) : (this.g = S), (this.h = S);
  }
 }
 var Jt = new T(
  () => new $r(),
  (f) => f.reset()
 );
 class $r {
  constructor() {
   this.next = this.g = this.h = null;
  }
  set(g, y) {
   (this.h = g), (this.g = y), (this.next = null);
  }
  reset() {
   this.next = this.g = this.h = null;
  }
 }
 let _n,
  z = !1,
  Z = new se(),
  ae = () => {
   const f = a.Promise.resolve(void 0);
   _n = () => {
    f.then(Le);
   };
  };
 var Le = () => {
  for (var f; (f = b()); ) {
   try {
    f.h.call(f.g);
   } catch (y) {
    D(y);
   }
   var g = Jt;
   g.j(f), 100 > g.h && (g.h++, (f.next = g.g), (g.g = f));
  }
  z = !1;
 };
 function Ae() {
  (this.s = this.s), (this.C = this.C);
 }
 (Ae.prototype.s = !1),
  (Ae.prototype.ma = function () {
   this.s || ((this.s = !0), this.N());
  }),
  (Ae.prototype.N = function () {
   if (this.C) for (; this.C.length; ) this.C.shift()();
  });
 function We(f, g) {
  (this.type = f), (this.g = this.target = g), (this.defaultPrevented = !1);
 }
 We.prototype.h = function () {
  this.defaultPrevented = !0;
 };
 var cr = (function () {
  if (!a.addEventListener || !Object.defineProperty) return !1;
  var f = !1,
   g = Object.defineProperty({}, "passive", {
    get: function () {
     f = !0;
    },
   });
  try {
   const y = () => {};
   a.addEventListener("test", y, g), a.removeEventListener("test", y, g);
  } catch {}
  return f;
 })();
 function dr(f, g) {
  if (
   (We.call(this, f ? f.type : ""),
   (this.relatedTarget = this.g = this.target = null),
   (this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0),
   (this.key = ""),
   (this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1),
   (this.state = null),
   (this.pointerId = 0),
   (this.pointerType = ""),
   (this.i = null),
   f)
  ) {
   var y = (this.type = f.type),
    S = f.changedTouches && f.changedTouches.length ? f.changedTouches[0] : null;
   if (((this.target = f.target || f.srcElement), (this.g = g), (g = f.relatedTarget))) {
    if (M) {
     e: {
      try {
       N(g.nodeName);
       var V = !0;
       break e;
      } catch {}
      V = !1;
     }
     V || (g = null);
    }
   } else y == "mouseover" ? (g = f.fromElement) : y == "mouseout" && (g = f.toElement);
   (this.relatedTarget = g),
    S
     ? ((this.clientX = S.clientX !== void 0 ? S.clientX : S.pageX),
       (this.clientY = S.clientY !== void 0 ? S.clientY : S.pageY),
       (this.screenX = S.screenX || 0),
       (this.screenY = S.screenY || 0))
     : ((this.clientX = f.clientX !== void 0 ? f.clientX : f.pageX),
       (this.clientY = f.clientY !== void 0 ? f.clientY : f.pageY),
       (this.screenX = f.screenX || 0),
       (this.screenY = f.screenY || 0)),
    (this.button = f.button),
    (this.key = f.key || ""),
    (this.ctrlKey = f.ctrlKey),
    (this.altKey = f.altKey),
    (this.shiftKey = f.shiftKey),
    (this.metaKey = f.metaKey),
    (this.pointerId = f.pointerId || 0),
    (this.pointerType = typeof f.pointerType == "string" ? f.pointerType : fr[f.pointerType] || ""),
    (this.state = f.state),
    (this.i = f),
    f.defaultPrevented && dr.aa.h.call(this);
  }
 }
 w(dr, We);
 var fr = { 2: "touch", 3: "pen", 4: "mouse" };
 dr.prototype.h = function () {
  dr.aa.h.call(this);
  var f = this.i;
  f.preventDefault ? f.preventDefault() : (f.returnValue = !1);
 };
 var hr = "closure_listenable_" + ((1e6 * Math.random()) | 0),
  Ab = 0;
 function Cb(f, g, y, S, V) {
  (this.listener = f),
   (this.proxy = null),
   (this.src = g),
   (this.type = y),
   (this.capture = !!S),
   (this.ha = V),
   (this.key = ++Ab),
   (this.da = this.fa = !1);
 }
 function au(f) {
  (f.da = !0), (f.listener = null), (f.proxy = null), (f.src = null), (f.ha = null);
 }
 function lu(f) {
  (this.src = f), (this.g = {}), (this.h = 0);
 }
 lu.prototype.add = function (f, g, y, S, V) {
  var U = f.toString();
  (f = this.g[U]), f || ((f = this.g[U] = []), this.h++);
  var G = Lf(f, g, S, V);
  return -1 < G ? ((g = f[G]), y || (g.fa = !1)) : ((g = new Cb(g, this.src, U, !!S, V)), (g.fa = y), f.push(g)), g;
 };
 function Df(f, g) {
  var y = g.type;
  if (y in f.g) {
   var S = f.g[y],
    V = Array.prototype.indexOf.call(S, g, void 0),
    U;
   (U = 0 <= V) && Array.prototype.splice.call(S, V, 1), U && (au(g), f.g[y].length == 0 && (delete f.g[y], f.h--));
  }
 }
 function Lf(f, g, y, S) {
  for (var V = 0; V < f.length; ++V) {
   var U = f[V];
   if (!U.da && U.listener == g && U.capture == !!y && U.ha == S) return V;
  }
  return -1;
 }
 var Vf = "closure_lm_" + ((1e6 * Math.random()) | 0),
  Uf = {};
 function Sv(f, g, y, S, V) {
  if (Array.isArray(g)) {
   for (var U = 0; U < g.length; U++) Sv(f, g[U], y, S, V);
   return null;
  }
  return (y = Rv(y)), f && f[hr] ? f.K(g, y, u(S) ? !!S.capture : !1, V) : Rb(f, g, y, !1, S, V);
 }
 function Rb(f, g, y, S, V, U) {
  if (!g) throw Error("Invalid event type");
  var G = u(V) ? !!V.capture : !!V,
   Ce = Ff(f);
  if ((Ce || (f[Vf] = Ce = new lu(f)), (y = Ce.add(g, y, S, G, U)), y.proxy)) return y;
  if (((S = Pb()), (y.proxy = S), (S.src = f), (S.listener = y), f.addEventListener))
   cr || (V = G), V === void 0 && (V = !1), f.addEventListener(g.toString(), S, V);
  else if (f.attachEvent) f.attachEvent(Cv(g.toString()), S);
  else if (f.addListener && f.removeListener) f.addListener(S);
  else throw Error("addEventListener and attachEvent are unavailable.");
  return y;
 }
 function Pb() {
  function f(y) {
   return g.call(f.src, f.listener, y);
  }
  const g = kb;
  return f;
 }
 function Av(f, g, y, S, V) {
  if (Array.isArray(g)) for (var U = 0; U < g.length; U++) Av(f, g[U], y, S, V);
  else
   (S = u(S) ? !!S.capture : !!S),
    (y = Rv(y)),
    f && f[hr]
     ? ((f = f.i),
       (g = String(g).toString()),
       g in f.g &&
        ((U = f.g[g]),
        (y = Lf(U, y, S, V)),
        -1 < y && (au(U[y]), Array.prototype.splice.call(U, y, 1), U.length == 0 && (delete f.g[g], f.h--))))
     : f &&
       (f = Ff(f)) &&
       ((g = f.g[g.toString()]), (f = -1), g && (f = Lf(g, y, S, V)), (y = -1 < f ? g[f] : null) && Of(y));
 }
 function Of(f) {
  if (typeof f != "number" && f && !f.da) {
   var g = f.src;
   if (g && g[hr]) Df(g.i, f);
   else {
    var y = f.type,
     S = f.proxy;
    g.removeEventListener
     ? g.removeEventListener(y, S, f.capture)
     : g.detachEvent
       ? g.detachEvent(Cv(y), S)
       : g.addListener && g.removeListener && g.removeListener(S),
     (y = Ff(g)) ? (Df(y, f), y.h == 0 && ((y.src = null), (g[Vf] = null))) : au(f);
   }
  }
 }
 function Cv(f) {
  return f in Uf ? Uf[f] : (Uf[f] = "on" + f);
 }
 function kb(f, g) {
  if (f.da) f = !0;
  else {
   g = new dr(g, this);
   var y = f.listener,
    S = f.ha || f.src;
   f.fa && Of(f), (f = y.call(S, g));
  }
  return f;
 }
 function Ff(f) {
  return (f = f[Vf]), f instanceof lu ? f : null;
 }
 var Bf = "__closure_events_fn_" + ((1e9 * Math.random()) >>> 0);
 function Rv(f) {
  return typeof f == "function"
   ? f
   : (f[Bf] ||
      (f[Bf] = function (g) {
       return f.handleEvent(g);
      }),
     f[Bf]);
 }
 function wt() {
  Ae.call(this), (this.i = new lu(this)), (this.M = this), (this.F = null);
 }
 w(wt, Ae),
  (wt.prototype[hr] = !0),
  (wt.prototype.removeEventListener = function (f, g, y, S) {
   Av(this, f, g, y, S);
  });
 function Vt(f, g) {
  var y,
   S = f.F;
  if (S) for (y = []; S; S = S.F) y.push(S);
  if (((f = f.M), (S = g.type || g), typeof g == "string")) g = new We(g, f);
  else if (g instanceof We) g.target = g.target || f;
  else {
   var V = g;
   (g = new We(S, f)), k(g, V);
  }
  if (((V = !0), y))
   for (var U = y.length - 1; 0 <= U; U--) {
    var G = (g.g = y[U]);
    V = uu(G, S, !0, g) && V;
   }
  if (((G = g.g = f), (V = uu(G, S, !0, g) && V), (V = uu(G, S, !1, g) && V), y))
   for (U = 0; U < y.length; U++) (G = g.g = y[U]), (V = uu(G, S, !1, g) && V);
 }
 (wt.prototype.N = function () {
  if ((wt.aa.N.call(this), this.i)) {
   var f = this.i,
    g;
   for (g in f.g) {
    for (var y = f.g[g], S = 0; S < y.length; S++) au(y[S]);
    delete f.g[g], f.h--;
   }
  }
  this.F = null;
 }),
  (wt.prototype.K = function (f, g, y, S) {
   return this.i.add(String(f), g, !1, y, S);
  }),
  (wt.prototype.L = function (f, g, y, S) {
   return this.i.add(String(f), g, !0, y, S);
  });
 function uu(f, g, y, S) {
  if (((g = f.i.g[String(g)]), !g)) return !0;
  g = g.concat();
  for (var V = !0, U = 0; U < g.length; ++U) {
   var G = g[U];
   if (G && !G.da && G.capture == y) {
    var Ce = G.listener,
     ft = G.ha || G.src;
    G.fa && Df(f.i, G), (V = Ce.call(ft, S) !== !1 && V);
   }
  }
  return V && !S.defaultPrevented;
 }
 function Pv(f, g, y) {
  if (typeof f == "function") y && (f = m(f, y));
  else if (f && typeof f.handleEvent == "function") f = m(f.handleEvent, f);
  else throw Error("Invalid listener argument");
  return 2147483647 < Number(g) ? -1 : a.setTimeout(f, g || 0);
 }
 function kv(f) {
  f.g = Pv(() => {
   (f.g = null), f.i && ((f.i = !1), kv(f));
  }, f.l);
  const g = f.h;
  (f.h = null), f.m.apply(null, g);
 }
 class bb extends Ae {
  constructor(g, y) {
   super(), (this.m = g), (this.l = y), (this.h = null), (this.i = !1), (this.g = null);
  }
  j(g) {
   (this.h = arguments), this.g ? (this.i = !0) : kv(this);
  }
  N() {
   super.N(), this.g && (a.clearTimeout(this.g), (this.g = null), (this.i = !1), (this.h = null));
  }
 }
 function Zs(f) {
  Ae.call(this), (this.h = f), (this.g = {});
 }
 w(Zs, Ae);
 var bv = [];
 function Nv(f) {
  F(
   f.g,
   function (g, y) {
    this.g.hasOwnProperty(y) && Of(g);
   },
   f
  ),
   (f.g = {});
 }
 (Zs.prototype.N = function () {
  Zs.aa.N.call(this), Nv(this);
 }),
  (Zs.prototype.handleEvent = function () {
   throw Error("EventHandler.handleEvent not implemented");
  });
 var $f = a.JSON.stringify,
  Nb = a.JSON.parse,
  xb = class {
   stringify(f) {
    return a.JSON.stringify(f, void 0);
   }
   parse(f) {
    return a.JSON.parse(f, void 0);
   }
  };
 function Hf() {}
 Hf.prototype.h = null;
 function xv(f) {
  return f.h || (f.h = f.i());
 }
 function Mv() {}
 var ea = { OPEN: "a", kb: "b", Ja: "c", wb: "d" };
 function qf() {
  We.call(this, "d");
 }
 w(qf, We);
 function Gf() {
  We.call(this, "c");
 }
 w(Gf, We);
 var Ui = {},
  Dv = null;
 function cu() {
  return (Dv = Dv || new wt());
 }
 Ui.La = "serverreachability";
 function Lv(f) {
  We.call(this, Ui.La, f);
 }
 w(Lv, We);
 function ta(f) {
  const g = cu();
  Vt(g, new Lv(g));
 }
 Ui.STAT_EVENT = "statevent";
 function Vv(f, g) {
  We.call(this, Ui.STAT_EVENT, f), (this.stat = g);
 }
 w(Vv, We);
 function Ut(f) {
  const g = cu();
  Vt(g, new Vv(g, f));
 }
 Ui.Ma = "timingevent";
 function Uv(f, g) {
  We.call(this, Ui.Ma, f), (this.size = g);
 }
 w(Uv, We);
 function na(f, g) {
  if (typeof f != "function") throw Error("Fn must not be null and must be a function");
  return a.setTimeout(function () {
   f();
  }, g);
 }
 function ra() {
  this.g = !0;
 }
 ra.prototype.xa = function () {
  this.g = !1;
 };
 function Mb(f, g, y, S, V, U) {
  f.info(function () {
   if (f.g)
    if (U)
     for (var G = "", Ce = U.split("&"), ft = 0; ft < Ce.length; ft++) {
      var me = Ce[ft].split("=");
      if (1 < me.length) {
       var Et = me[0];
       me = me[1];
       var Tt = Et.split("_");
       G = 2 <= Tt.length && Tt[1] == "type" ? G + (Et + "=" + me + "&") : G + (Et + "=redacted&");
      }
     }
    else G = null;
   else G = U;
   return (
    "XMLHTTP REQ (" +
    S +
    ") [attempt " +
    V +
    "]: " +
    g +
    `
` +
    y +
    `
` +
    G
   );
  });
 }
 function Db(f, g, y, S, V, U, G) {
  f.info(function () {
   return (
    "XMLHTTP RESP (" +
    S +
    ") [ attempt " +
    V +
    "]: " +
    g +
    `
` +
    y +
    `
` +
    U +
    " " +
    G
   );
  });
 }
 function Do(f, g, y, S) {
  f.info(function () {
   return "XMLHTTP TEXT (" + g + "): " + Vb(f, y) + (S ? " " + S : "");
  });
 }
 function Lb(f, g) {
  f.info(function () {
   return "TIMEOUT: " + g;
  });
 }
 ra.prototype.info = function () {};
 function Vb(f, g) {
  if (!f.g) return g;
  if (!g) return null;
  try {
   var y = JSON.parse(g);
   if (y) {
    for (f = 0; f < y.length; f++)
     if (Array.isArray(y[f])) {
      var S = y[f];
      if (!(2 > S.length)) {
       var V = S[1];
       if (Array.isArray(V) && !(1 > V.length)) {
        var U = V[0];
        if (U != "noop" && U != "stop" && U != "close") for (var G = 1; G < V.length; G++) V[G] = "";
       }
      }
     }
   }
   return $f(y);
  } catch {
   return g;
  }
 }
 var du = { NO_ERROR: 0, gb: 1, tb: 2, sb: 3, nb: 4, rb: 5, ub: 6, Ia: 7, TIMEOUT: 8, xb: 9 },
  Ov = {
   lb: "complete",
   Hb: "success",
   Ja: "error",
   Ia: "abort",
   zb: "ready",
   Ab: "readystatechange",
   TIMEOUT: "timeout",
   vb: "incrementaldata",
   yb: "progress",
   ob: "downloadprogress",
   Pb: "uploadprogress",
  },
  zf;
 function fu() {}
 w(fu, Hf),
  (fu.prototype.g = function () {
   return new XMLHttpRequest();
  }),
  (fu.prototype.i = function () {
   return {};
  }),
  (zf = new fu());
 function Hr(f, g, y, S) {
  (this.j = f),
   (this.i = g),
   (this.l = y),
   (this.R = S || 1),
   (this.U = new Zs(this)),
   (this.I = 45e3),
   (this.H = null),
   (this.o = !1),
   (this.m = this.A = this.v = this.L = this.F = this.S = this.B = null),
   (this.D = []),
   (this.g = null),
   (this.C = 0),
   (this.s = this.u = null),
   (this.X = -1),
   (this.J = !1),
   (this.O = 0),
   (this.M = null),
   (this.W = this.K = this.T = this.P = !1),
   (this.h = new Fv());
 }
 function Fv() {
  (this.i = null), (this.g = ""), (this.h = !1);
 }
 var Bv = {},
  Wf = {};
 function Kf(f, g, y) {
  (f.L = 1), (f.v = gu(pr(g))), (f.m = y), (f.P = !0), $v(f, null);
 }
 function $v(f, g) {
  (f.F = Date.now()), hu(f), (f.A = pr(f.v));
  var y = f.A,
   S = f.R;
  Array.isArray(S) || (S = [String(S)]),
   t_(y.i, "t", S),
   (f.C = 0),
   (y = f.j.J),
   (f.h = new Fv()),
   (f.g = __(f.j, y ? g : null, !f.m)),
   0 < f.O && (f.M = new bb(m(f.Y, f, f.g), f.O)),
   (g = f.U),
   (y = f.g),
   (S = f.ca);
  var V = "readystatechange";
  Array.isArray(V) || (V && (bv[0] = V.toString()), (V = bv));
  for (var U = 0; U < V.length; U++) {
   var G = Sv(y, V[U], S || g.handleEvent, !1, g.h || g);
   if (!G) break;
   g.g[G.key] = G;
  }
  (g = f.H ? I(f.H) : {}),
   f.m
    ? (f.u || (f.u = "POST"), (g["Content-Type"] = "application/x-www-form-urlencoded"), f.g.ea(f.A, f.u, f.m, g))
    : ((f.u = "GET"), f.g.ea(f.A, f.u, null, g)),
   ta(),
   Mb(f.i, f.u, f.A, f.l, f.R, f.m);
 }
 (Hr.prototype.ca = function (f) {
  f = f.target;
  const g = this.M;
  g && mr(f) == 3 ? g.j() : this.Y(f);
 }),
  (Hr.prototype.Y = function (f) {
   try {
    if (f == this.g)
     e: {
      const Tt = mr(this.g);
      var g = this.g.Ba();
      const Uo = this.g.Z();
      if (!(3 > Tt) && (Tt != 3 || (this.g && (this.h.h || this.g.oa() || l_(this.g))))) {
       this.J || Tt != 4 || g == 7 || (g == 8 || 0 >= Uo ? ta(3) : ta(2)), Jf(this);
       var y = this.g.Z();
       this.X = y;
       t: if (Hv(this)) {
        var S = l_(this.g);
        f = "";
        var V = S.length,
         U = mr(this.g) == 4;
        if (!this.h.i) {
         if (typeof TextDecoder > "u") {
          Oi(this), ia(this);
          var G = "";
          break t;
         }
         this.h.i = new a.TextDecoder();
        }
        for (g = 0; g < V; g++) (this.h.h = !0), (f += this.h.i.decode(S[g], { stream: !(U && g == V - 1) }));
        (S.length = 0), (this.h.g += f), (this.C = 0), (G = this.h.g);
       } else G = this.g.oa();
       if (((this.o = y == 200), Db(this.i, this.u, this.A, this.l, this.R, Tt, y), this.o)) {
        if (this.T && !this.K) {
         t: {
          if (this.g) {
           var Ce,
            ft = this.g;
           if ((Ce = ft.g ? ft.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !_(Ce)) {
            var me = Ce;
            break t;
           }
          }
          me = null;
         }
         if ((y = me))
          Do(this.i, this.l, y, "Initial handshake response via X-HTTP-Initial-Response"), (this.K = !0), Yf(this, y);
         else {
          (this.o = !1), (this.s = 3), Ut(12), Oi(this), ia(this);
          break e;
         }
        }
        if (this.P) {
         y = !0;
         let Nn;
         for (; !this.J && this.C < G.length; )
          if (((Nn = Ub(this, G)), Nn == Wf)) {
           Tt == 4 && ((this.s = 4), Ut(14), (y = !1)), Do(this.i, this.l, null, "[Incomplete Response]");
           break;
          } else if (Nn == Bv) {
           (this.s = 4), Ut(15), Do(this.i, this.l, G, "[Invalid Chunk]"), (y = !1);
           break;
          } else Do(this.i, this.l, Nn, null), Yf(this, Nn);
         if (
          (Hv(this) && this.C != 0 && ((this.h.g = this.h.g.slice(this.C)), (this.C = 0)),
          Tt != 4 || G.length != 0 || this.h.h || ((this.s = 1), Ut(16), (y = !1)),
          (this.o = this.o && y),
          !y)
         )
          Do(this.i, this.l, G, "[Invalid Chunked Response]"), Oi(this), ia(this);
         else if (0 < G.length && !this.W) {
          this.W = !0;
          var Et = this.j;
          Et.g == this &&
           Et.ba &&
           !Et.M &&
           (Et.j.info("Great, no buffering proxy detected. Bytes received: " + G.length), th(Et), (Et.M = !0), Ut(11));
         }
        } else Do(this.i, this.l, G, null), Yf(this, G);
        Tt == 4 && Oi(this), this.o && !this.J && (Tt == 4 ? m_(this.j, this) : ((this.o = !1), hu(this)));
       } else
        eN(this.g),
         y == 400 && 0 < G.indexOf("Unknown SID") ? ((this.s = 3), Ut(12)) : ((this.s = 0), Ut(13)),
         Oi(this),
         ia(this);
      }
     }
   } catch {
   } finally {
   }
  });
 function Hv(f) {
  return f.g ? f.u == "GET" && f.L != 2 && f.j.Ca : !1;
 }
 function Ub(f, g) {
  var y = f.C,
   S = g.indexOf(
    `
`,
    y
   );
  return S == -1
   ? Wf
   : ((y = Number(g.substring(y, S))),
     isNaN(y) ? Bv : ((S += 1), S + y > g.length ? Wf : ((g = g.slice(S, S + y)), (f.C = S + y), g)));
 }
 Hr.prototype.cancel = function () {
  (this.J = !0), Oi(this);
 };
 function hu(f) {
  (f.S = Date.now() + f.I), qv(f, f.I);
 }
 function qv(f, g) {
  if (f.B != null) throw Error("WatchDog timer not null");
  f.B = na(m(f.ba, f), g);
 }
 function Jf(f) {
  f.B && (a.clearTimeout(f.B), (f.B = null));
 }
 Hr.prototype.ba = function () {
  this.B = null;
  const f = Date.now();
  0 <= f - this.S
   ? (Lb(this.i, this.A), this.L != 2 && (ta(), Ut(17)), Oi(this), (this.s = 2), ia(this))
   : qv(this, this.S - f);
 };
 function ia(f) {
  f.j.G == 0 || f.J || m_(f.j, f);
 }
 function Oi(f) {
  Jf(f);
  var g = f.M;
  g && typeof g.ma == "function" && g.ma(), (f.M = null), Nv(f.U), f.g && ((g = f.g), (f.g = null), g.abort(), g.ma());
 }
 function Yf(f, g) {
  try {
   var y = f.j;
   if (y.G != 0 && (y.g == f || Qf(y.h, f))) {
    if (!f.K && Qf(y.h, f) && y.G == 3) {
     try {
      var S = y.Da.g.parse(g);
     } catch {
      S = null;
     }
     if (Array.isArray(S) && S.length == 3) {
      var V = S;
      if (V[0] == 0) {
       e: if (!y.u) {
        if (y.g)
         if (y.g.F + 3e3 < f.F) Tu(y), wu(y);
         else break e;
        eh(y), Ut(18);
       }
      } else (y.za = V[1]), 0 < y.za - y.T && 37500 > V[2] && y.F && y.v == 0 && !y.C && (y.C = na(m(y.Za, y), 6e3));
      if (1 >= Wv(y.h) && y.ca) {
       try {
        y.ca();
       } catch {}
       y.ca = void 0;
      }
     } else Bi(y, 11);
    } else if (((f.K || y.g == f) && Tu(y), !_(g)))
     for (V = y.Da.g.parse(g), g = 0; g < V.length; g++) {
      let me = V[g];
      if (((y.T = me[0]), (me = me[1]), y.G == 2))
       if (me[0] == "c") {
        (y.K = me[1]), (y.ia = me[2]);
        const Et = me[3];
        Et != null && ((y.la = Et), y.j.info("VER=" + y.la));
        const Tt = me[4];
        Tt != null && ((y.Aa = Tt), y.j.info("SVER=" + y.Aa));
        const Uo = me[5];
        Uo != null &&
         typeof Uo == "number" &&
         0 < Uo &&
         ((S = 1.5 * Uo), (y.L = S), y.j.info("backChannelRequestTimeoutMs_=" + S)),
         (S = y);
        const Nn = f.g;
        if (Nn) {
         const Su = Nn.g ? Nn.g.getResponseHeader("X-Client-Wire-Protocol") : null;
         if (Su) {
          var U = S.h;
          U.g ||
           (Su.indexOf("spdy") == -1 && Su.indexOf("quic") == -1 && Su.indexOf("h2") == -1) ||
           ((U.j = U.l), (U.g = new Set()), U.h && (Xf(U, U.h), (U.h = null)));
         }
         if (S.D) {
          const nh = Nn.g ? Nn.g.getResponseHeader("X-HTTP-Session-Id") : null;
          nh && ((S.ya = nh), ke(S.I, S.D, nh));
         }
        }
        (y.G = 3),
         y.l && y.l.ua(),
         y.ba && ((y.R = Date.now() - f.F), y.j.info("Handshake RTT: " + y.R + "ms")),
         (S = y);
        var G = f;
        if (((S.qa = v_(S, S.J ? S.ia : null, S.W)), G.K)) {
         Kv(S.h, G);
         var Ce = G,
          ft = S.L;
         ft && (Ce.I = ft), Ce.B && (Jf(Ce), hu(Ce)), (S.g = G);
        } else h_(S);
        0 < y.i.length && Eu(y);
       } else (me[0] != "stop" && me[0] != "close") || Bi(y, 7);
      else
       y.G == 3 &&
        (me[0] == "stop" || me[0] == "close"
         ? me[0] == "stop"
           ? Bi(y, 7)
           : Zf(y)
         : me[0] != "noop" && y.l && y.l.ta(me),
        (y.v = 0));
     }
   }
   ta(4);
  } catch {}
 }
 var Ob = class {
  constructor(f, g) {
   (this.g = f), (this.map = g);
  }
 };
 function Gv(f) {
  (this.l = f || 10),
   a.PerformanceNavigationTiming
    ? ((f = a.performance.getEntriesByType("navigation")),
      (f = 0 < f.length && (f[0].nextHopProtocol == "hq" || f[0].nextHopProtocol == "h2")))
    : (f = !!(a.chrome && a.chrome.loadTimes && a.chrome.loadTimes() && a.chrome.loadTimes().wasFetchedViaSpdy)),
   (this.j = f ? this.l : 1),
   (this.g = null),
   1 < this.j && (this.g = new Set()),
   (this.h = null),
   (this.i = []);
 }
 function zv(f) {
  return f.h ? !0 : f.g ? f.g.size >= f.j : !1;
 }
 function Wv(f) {
  return f.h ? 1 : f.g ? f.g.size : 0;
 }
 function Qf(f, g) {
  return f.h ? f.h == g : f.g ? f.g.has(g) : !1;
 }
 function Xf(f, g) {
  f.g ? f.g.add(g) : (f.h = g);
 }
 function Kv(f, g) {
  f.h && f.h == g ? (f.h = null) : f.g && f.g.has(g) && f.g.delete(g);
 }
 Gv.prototype.cancel = function () {
  if (((this.i = Jv(this)), this.h)) this.h.cancel(), (this.h = null);
  else if (this.g && this.g.size !== 0) {
   for (const f of this.g.values()) f.cancel();
   this.g.clear();
  }
 };
 function Jv(f) {
  if (f.h != null) return f.i.concat(f.h.D);
  if (f.g != null && f.g.size !== 0) {
   let g = f.i;
   for (const y of f.g.values()) g = g.concat(y.D);
   return g;
  }
  return C(f.i);
 }
 function Fb(f) {
  if (f.V && typeof f.V == "function") return f.V();
  if ((typeof Map < "u" && f instanceof Map) || (typeof Set < "u" && f instanceof Set)) return Array.from(f.values());
  if (typeof f == "string") return f.split("");
  if (l(f)) {
   for (var g = [], y = f.length, S = 0; S < y; S++) g.push(f[S]);
   return g;
  }
  (g = []), (y = 0);
  for (S in f) g[y++] = f[S];
  return g;
 }
 function Bb(f) {
  if (f.na && typeof f.na == "function") return f.na();
  if (!f.V || typeof f.V != "function") {
   if (typeof Map < "u" && f instanceof Map) return Array.from(f.keys());
   if (!(typeof Set < "u" && f instanceof Set)) {
    if (l(f) || typeof f == "string") {
     var g = [];
     f = f.length;
     for (var y = 0; y < f; y++) g.push(y);
     return g;
    }
    (g = []), (y = 0);
    for (const S in f) g[y++] = S;
    return g;
   }
  }
 }
 function Yv(f, g) {
  if (f.forEach && typeof f.forEach == "function") f.forEach(g, void 0);
  else if (l(f) || typeof f == "string") Array.prototype.forEach.call(f, g, void 0);
  else for (var y = Bb(f), S = Fb(f), V = S.length, U = 0; U < V; U++) g.call(void 0, S[U], y && y[U], f);
 }
 var Qv = RegExp(
  "^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$"
 );
 function $b(f, g) {
  if (f) {
   f = f.split("&");
   for (var y = 0; y < f.length; y++) {
    var S = f[y].indexOf("="),
     V = null;
    if (0 <= S) {
     var U = f[y].substring(0, S);
     V = f[y].substring(S + 1);
    } else U = f[y];
    g(U, V ? decodeURIComponent(V.replace(/\+/g, " ")) : "");
   }
  }
 }
 function Fi(f) {
  if (((this.g = this.o = this.j = ""), (this.s = null), (this.m = this.l = ""), (this.h = !1), f instanceof Fi)) {
   (this.h = f.h), pu(this, f.j), (this.o = f.o), (this.g = f.g), mu(this, f.s), (this.l = f.l);
   var g = f.i,
    y = new aa();
   (y.i = g.i), g.g && ((y.g = new Map(g.g)), (y.h = g.h)), Xv(this, y), (this.m = f.m);
  } else
   f && (g = String(f).match(Qv))
    ? ((this.h = !1),
      pu(this, g[1] || "", !0),
      (this.o = oa(g[2] || "")),
      (this.g = oa(g[3] || "", !0)),
      mu(this, g[4]),
      (this.l = oa(g[5] || "", !0)),
      Xv(this, g[6] || "", !0),
      (this.m = oa(g[7] || "")))
    : ((this.h = !1), (this.i = new aa(null, this.h)));
 }
 Fi.prototype.toString = function () {
  var f = [],
   g = this.j;
  g && f.push(sa(g, jv, !0), ":");
  var y = this.g;
  return (
   (y || g == "file") &&
    (f.push("//"),
    (g = this.o) && f.push(sa(g, jv, !0), "@"),
    f.push(encodeURIComponent(String(y)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")),
    (y = this.s),
    y != null && f.push(":", String(y))),
   (y = this.l) && (this.g && y.charAt(0) != "/" && f.push("/"), f.push(sa(y, y.charAt(0) == "/" ? Gb : qb, !0))),
   (y = this.i.toString()) && f.push("?", y),
   (y = this.m) && f.push("#", sa(y, Wb)),
   f.join("")
  );
 };
 function pr(f) {
  return new Fi(f);
 }
 function pu(f, g, y) {
  (f.j = y ? oa(g, !0) : g), f.j && (f.j = f.j.replace(/:$/, ""));
 }
 function mu(f, g) {
  if (g) {
   if (((g = Number(g)), isNaN(g) || 0 > g)) throw Error("Bad port number " + g);
   f.s = g;
  } else f.s = null;
 }
 function Xv(f, g, y) {
  g instanceof aa ? ((f.i = g), Kb(f.i, f.h)) : (y || (g = sa(g, zb)), (f.i = new aa(g, f.h)));
 }
 function ke(f, g, y) {
  f.i.set(g, y);
 }
 function gu(f) {
  return (
   ke(
    f,
    "zx",
    Math.floor(2147483648 * Math.random()).toString(36) +
     Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)
   ),
   f
  );
 }
 function oa(f, g) {
  return f ? (g ? decodeURI(f.replace(/%25/g, "%2525")) : decodeURIComponent(f)) : "";
 }
 function sa(f, g, y) {
  return typeof f == "string"
   ? ((f = encodeURI(f).replace(g, Hb)), y && (f = f.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), f)
   : null;
 }
 function Hb(f) {
  return (f = f.charCodeAt(0)), "%" + ((f >> 4) & 15).toString(16) + (f & 15).toString(16);
 }
 var jv = /[#\/\?@]/g,
  qb = /[#\?:]/g,
  Gb = /[#\?]/g,
  zb = /[#\?@]/g,
  Wb = /#/g;
 function aa(f, g) {
  (this.h = this.g = null), (this.i = f || null), (this.j = !!g);
 }
 function qr(f) {
  f.g ||
   ((f.g = new Map()),
   (f.h = 0),
   f.i &&
    $b(f.i, function (g, y) {
     f.add(decodeURIComponent(g.replace(/\+/g, " ")), y);
    }));
 }
 (t = aa.prototype),
  (t.add = function (f, g) {
   qr(this), (this.i = null), (f = Lo(this, f));
   var y = this.g.get(f);
   return y || this.g.set(f, (y = [])), y.push(g), (this.h += 1), this;
  });
 function Zv(f, g) {
  qr(f), (g = Lo(f, g)), f.g.has(g) && ((f.i = null), (f.h -= f.g.get(g).length), f.g.delete(g));
 }
 function e_(f, g) {
  return qr(f), (g = Lo(f, g)), f.g.has(g);
 }
 (t.forEach = function (f, g) {
  qr(this),
   this.g.forEach(function (y, S) {
    y.forEach(function (V) {
     f.call(g, V, S, this);
    }, this);
   }, this);
 }),
  (t.na = function () {
   qr(this);
   const f = Array.from(this.g.values()),
    g = Array.from(this.g.keys()),
    y = [];
   for (let S = 0; S < g.length; S++) {
    const V = f[S];
    for (let U = 0; U < V.length; U++) y.push(g[S]);
   }
   return y;
  }),
  (t.V = function (f) {
   qr(this);
   let g = [];
   if (typeof f == "string") e_(this, f) && (g = g.concat(this.g.get(Lo(this, f))));
   else {
    f = Array.from(this.g.values());
    for (let y = 0; y < f.length; y++) g = g.concat(f[y]);
   }
   return g;
  }),
  (t.set = function (f, g) {
   return (
    qr(this),
    (this.i = null),
    (f = Lo(this, f)),
    e_(this, f) && (this.h -= this.g.get(f).length),
    this.g.set(f, [g]),
    (this.h += 1),
    this
   );
  }),
  (t.get = function (f, g) {
   return f ? ((f = this.V(f)), 0 < f.length ? String(f[0]) : g) : g;
  });
 function t_(f, g, y) {
  Zv(f, g), 0 < y.length && ((f.i = null), f.g.set(Lo(f, g), C(y)), (f.h += y.length));
 }
 t.toString = function () {
  if (this.i) return this.i;
  if (!this.g) return "";
  const f = [],
   g = Array.from(this.g.keys());
  for (var y = 0; y < g.length; y++) {
   var S = g[y];
   const U = encodeURIComponent(String(S)),
    G = this.V(S);
   for (S = 0; S < G.length; S++) {
    var V = U;
    G[S] !== "" && (V += "=" + encodeURIComponent(String(G[S]))), f.push(V);
   }
  }
  return (this.i = f.join("&"));
 };
 function Lo(f, g) {
  return (g = String(g)), f.j && (g = g.toLowerCase()), g;
 }
 function Kb(f, g) {
  g &&
   !f.j &&
   (qr(f),
   (f.i = null),
   f.g.forEach(function (y, S) {
    var V = S.toLowerCase();
    S != V && (Zv(this, S), t_(this, V, y));
   }, f)),
   (f.j = g);
 }
 function Jb(f, g) {
  const y = new ra();
  if (a.Image) {
   const S = new Image();
   (S.onload = v(Gr, y, "TestLoadImage: loaded", !0, g, S)),
    (S.onerror = v(Gr, y, "TestLoadImage: error", !1, g, S)),
    (S.onabort = v(Gr, y, "TestLoadImage: abort", !1, g, S)),
    (S.ontimeout = v(Gr, y, "TestLoadImage: timeout", !1, g, S)),
    a.setTimeout(function () {
     S.ontimeout && S.ontimeout();
    }, 1e4),
    (S.src = f);
  } else g(!1);
 }
 function Yb(f, g) {
  const y = new ra(),
   S = new AbortController(),
   V = setTimeout(() => {
    S.abort(), Gr(y, "TestPingServer: timeout", !1, g);
   }, 1e4);
  fetch(f, { signal: S.signal })
   .then((U) => {
    clearTimeout(V), U.ok ? Gr(y, "TestPingServer: ok", !0, g) : Gr(y, "TestPingServer: server error", !1, g);
   })
   .catch(() => {
    clearTimeout(V), Gr(y, "TestPingServer: error", !1, g);
   });
 }
 function Gr(f, g, y, S, V) {
  try {
   V && ((V.onload = null), (V.onerror = null), (V.onabort = null), (V.ontimeout = null)), S(y);
  } catch {}
 }
 function Qb() {
  this.g = new xb();
 }
 function Xb(f, g, y) {
  const S = y || "";
  try {
   Yv(f, function (V, U) {
    let G = V;
    u(V) && (G = $f(V)), g.push(S + U + "=" + encodeURIComponent(G));
   });
  } catch (V) {
   throw (g.push(S + "type=" + encodeURIComponent("_badmap")), V);
  }
 }
 function yu(f) {
  (this.l = f.Ub || null), (this.j = f.eb || !1);
 }
 w(yu, Hf),
  (yu.prototype.g = function () {
   return new vu(this.l, this.j);
  }),
  (yu.prototype.i = (function (f) {
   return function () {
    return f;
   };
  })({}));
 function vu(f, g) {
  wt.call(this),
   (this.D = f),
   (this.o = g),
   (this.m = void 0),
   (this.status = this.readyState = 0),
   (this.responseType = this.responseText = this.response = this.statusText = ""),
   (this.onreadystatechange = null),
   (this.u = new Headers()),
   (this.h = null),
   (this.B = "GET"),
   (this.A = ""),
   (this.g = !1),
   (this.v = this.j = this.l = null);
 }
 w(vu, wt),
  (t = vu.prototype),
  (t.open = function (f, g) {
   if (this.readyState != 0) throw (this.abort(), Error("Error reopening a connection"));
   (this.B = f), (this.A = g), (this.readyState = 1), ua(this);
  }),
  (t.send = function (f) {
   if (this.readyState != 1) throw (this.abort(), Error("need to call open() first. "));
   this.g = !0;
   const g = { headers: this.u, method: this.B, credentials: this.m, cache: void 0 };
   f && (g.body = f), (this.D || a).fetch(new Request(this.A, g)).then(this.Sa.bind(this), this.ga.bind(this));
  }),
  (t.abort = function () {
   (this.response = this.responseText = ""),
    (this.u = new Headers()),
    (this.status = 0),
    this.j && this.j.cancel("Request was aborted.").catch(() => {}),
    1 <= this.readyState && this.g && this.readyState != 4 && ((this.g = !1), la(this)),
    (this.readyState = 0);
  }),
  (t.Sa = function (f) {
   if (
    this.g &&
    ((this.l = f),
    this.h ||
     ((this.status = this.l.status),
     (this.statusText = this.l.statusText),
     (this.h = f.headers),
     (this.readyState = 2),
     ua(this)),
    this.g && ((this.readyState = 3), ua(this), this.g))
   )
    if (this.responseType === "arraybuffer") f.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this));
    else if (typeof a.ReadableStream < "u" && "body" in f) {
     if (((this.j = f.body.getReader()), this.o)) {
      if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
      this.response = [];
     } else (this.response = this.responseText = ""), (this.v = new TextDecoder());
     n_(this);
    } else f.text().then(this.Ra.bind(this), this.ga.bind(this));
  });
 function n_(f) {
  f.j.read().then(f.Pa.bind(f)).catch(f.ga.bind(f));
 }
 (t.Pa = function (f) {
  if (this.g) {
   if (this.o && f.value) this.response.push(f.value);
   else if (!this.o) {
    var g = f.value ? f.value : new Uint8Array(0);
    (g = this.v.decode(g, { stream: !f.done })) && (this.response = this.responseText += g);
   }
   f.done ? la(this) : ua(this), this.readyState == 3 && n_(this);
  }
 }),
  (t.Ra = function (f) {
   this.g && ((this.response = this.responseText = f), la(this));
  }),
  (t.Qa = function (f) {
   this.g && ((this.response = f), la(this));
  }),
  (t.ga = function () {
   this.g && la(this);
  });
 function la(f) {
  (f.readyState = 4), (f.l = null), (f.j = null), (f.v = null), ua(f);
 }
 (t.setRequestHeader = function (f, g) {
  this.u.append(f, g);
 }),
  (t.getResponseHeader = function (f) {
   return (this.h && this.h.get(f.toLowerCase())) || "";
  }),
  (t.getAllResponseHeaders = function () {
   if (!this.h) return "";
   const f = [],
    g = this.h.entries();
   for (var y = g.next(); !y.done; ) (y = y.value), f.push(y[0] + ": " + y[1]), (y = g.next());
   return f.join(`\r
`);
  });
 function ua(f) {
  f.onreadystatechange && f.onreadystatechange.call(f);
 }
 Object.defineProperty(vu.prototype, "withCredentials", {
  get: function () {
   return this.m === "include";
  },
  set: function (f) {
   this.m = f ? "include" : "same-origin";
  },
 });
 function r_(f) {
  let g = "";
  return (
   F(f, function (y, S) {
    (g += S),
     (g += ":"),
     (g += y),
     (g += `\r
`);
   }),
   g
  );
 }
 function jf(f, g, y) {
  e: {
   for (S in y) {
    var S = !1;
    break e;
   }
   S = !0;
  }
  S || ((y = r_(y)), typeof f == "string" ? y != null && encodeURIComponent(String(y)) : ke(f, g, y));
 }
 function $e(f) {
  wt.call(this),
   (this.headers = new Map()),
   (this.o = f || null),
   (this.h = !1),
   (this.v = this.g = null),
   (this.D = ""),
   (this.m = 0),
   (this.l = ""),
   (this.j = this.B = this.u = this.A = !1),
   (this.I = null),
   (this.H = ""),
   (this.J = !1);
 }
 w($e, wt);
 var jb = /^https?$/i,
  Zb = ["POST", "PUT"];
 (t = $e.prototype),
  (t.Ha = function (f) {
   this.J = f;
  }),
  (t.ea = function (f, g, y, S) {
   if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + f);
   (g = g ? g.toUpperCase() : "GET"),
    (this.D = f),
    (this.l = ""),
    (this.m = 0),
    (this.A = !1),
    (this.h = !0),
    (this.g = this.o ? this.o.g() : zf.g()),
    (this.v = this.o ? xv(this.o) : xv(zf)),
    (this.g.onreadystatechange = m(this.Ea, this));
   try {
    (this.B = !0), this.g.open(g, String(f), !0), (this.B = !1);
   } catch (U) {
    i_(this, U);
    return;
   }
   if (((f = y || ""), (y = new Map(this.headers)), S))
    if (Object.getPrototypeOf(S) === Object.prototype) for (var V in S) y.set(V, S[V]);
    else if (typeof S.keys == "function" && typeof S.get == "function") for (const U of S.keys()) y.set(U, S.get(U));
    else throw Error("Unknown input type for opt_headers: " + String(S));
   (S = Array.from(y.keys()).find((U) => U.toLowerCase() == "content-type")),
    (V = a.FormData && f instanceof a.FormData),
    !(0 <= Array.prototype.indexOf.call(Zb, g, void 0)) ||
     S ||
     V ||
     y.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
   for (const [U, G] of y) this.g.setRequestHeader(U, G);
   this.H && (this.g.responseType = this.H),
    "withCredentials" in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J);
   try {
    a_(this), (this.u = !0), this.g.send(f), (this.u = !1);
   } catch (U) {
    i_(this, U);
   }
  });
 function i_(f, g) {
  (f.h = !1), f.g && ((f.j = !0), f.g.abort(), (f.j = !1)), (f.l = g), (f.m = 5), o_(f), _u(f);
 }
 function o_(f) {
  f.A || ((f.A = !0), Vt(f, "complete"), Vt(f, "error"));
 }
 (t.abort = function (f) {
  this.g &&
   this.h &&
   ((this.h = !1),
   (this.j = !0),
   this.g.abort(),
   (this.j = !1),
   (this.m = f || 7),
   Vt(this, "complete"),
   Vt(this, "abort"),
   _u(this));
 }),
  (t.N = function () {
   this.g && (this.h && ((this.h = !1), (this.j = !0), this.g.abort(), (this.j = !1)), _u(this, !0)),
    $e.aa.N.call(this);
  }),
  (t.Ea = function () {
   this.s || (this.B || this.u || this.j ? s_(this) : this.bb());
  }),
  (t.bb = function () {
   s_(this);
  });
 function s_(f) {
  if (f.h && typeof s < "u" && (!f.v[1] || mr(f) != 4 || f.Z() != 2)) {
   if (f.u && mr(f) == 4) Pv(f.Ea, 0, f);
   else if ((Vt(f, "readystatechange"), mr(f) == 4)) {
    f.h = !1;
    try {
     const G = f.Z();
     e: switch (G) {
      case 200:
      case 201:
      case 202:
      case 204:
      case 206:
      case 304:
      case 1223:
       var g = !0;
       break e;
      default:
       g = !1;
     }
     var y;
     if (!(y = g)) {
      var S;
      if ((S = G === 0)) {
       var V = String(f.D).match(Qv)[1] || null;
       !V && a.self && a.self.location && (V = a.self.location.protocol.slice(0, -1)),
        (S = !jb.test(V ? V.toLowerCase() : ""));
      }
      y = S;
     }
     if (y) Vt(f, "complete"), Vt(f, "success");
     else {
      f.m = 6;
      try {
       var U = 2 < mr(f) ? f.g.statusText : "";
      } catch {
       U = "";
      }
      (f.l = U + " [" + f.Z() + "]"), o_(f);
     }
    } finally {
     _u(f);
    }
   }
  }
 }
 function _u(f, g) {
  if (f.g) {
   a_(f);
   const y = f.g,
    S = f.v[0] ? () => {} : null;
   (f.g = null), (f.v = null), g || Vt(f, "ready");
   try {
    y.onreadystatechange = S;
   } catch {}
  }
 }
 function a_(f) {
  f.I && (a.clearTimeout(f.I), (f.I = null));
 }
 t.isActive = function () {
  return !!this.g;
 };
 function mr(f) {
  return f.g ? f.g.readyState : 0;
 }
 (t.Z = function () {
  try {
   return 2 < mr(this) ? this.g.status : -1;
  } catch {
   return -1;
  }
 }),
  (t.oa = function () {
   try {
    return this.g ? this.g.responseText : "";
   } catch {
    return "";
   }
  }),
  (t.Oa = function (f) {
   if (this.g) {
    var g = this.g.responseText;
    return f && g.indexOf(f) == 0 && (g = g.substring(f.length)), Nb(g);
   }
  });
 function l_(f) {
  try {
   if (!f.g) return null;
   if ("response" in f.g) return f.g.response;
   switch (f.H) {
    case "":
    case "text":
     return f.g.responseText;
    case "arraybuffer":
     if ("mozResponseArrayBuffer" in f.g) return f.g.mozResponseArrayBuffer;
   }
   return null;
  } catch {
   return null;
  }
 }
 function eN(f) {
  const g = {};
  f = ((f.g && 2 <= mr(f) && f.g.getAllResponseHeaders()) || "").split(`\r
`);
  for (let S = 0; S < f.length; S++) {
   if (_(f[S])) continue;
   var y = x(f[S]);
   const V = y[0];
   if (((y = y[1]), typeof y != "string")) continue;
   y = y.trim();
   const U = g[V] || [];
   (g[V] = U), U.push(y);
  }
  P(g, function (S) {
   return S.join(", ");
  });
 }
 (t.Ba = function () {
  return this.m;
 }),
  (t.Ka = function () {
   return typeof this.l == "string" ? this.l : String(this.l);
  });
 function ca(f, g, y) {
  return (y && y.internalChannelParams && y.internalChannelParams[f]) || g;
 }
 function u_(f) {
  (this.Aa = 0),
   (this.i = []),
   (this.j = new ra()),
   (this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null),
   (this.Ya = this.U = 0),
   (this.Va = ca("failFast", !1, f)),
   (this.F = this.C = this.u = this.s = this.l = null),
   (this.X = !0),
   (this.za = this.T = -1),
   (this.Y = this.v = this.B = 0),
   (this.Ta = ca("baseRetryDelayMs", 5e3, f)),
   (this.cb = ca("retryDelaySeedMs", 1e4, f)),
   (this.Wa = ca("forwardChannelMaxRetries", 2, f)),
   (this.wa = ca("forwardChannelRequestTimeoutMs", 2e4, f)),
   (this.pa = (f && f.xmlHttpFactory) || void 0),
   (this.Xa = (f && f.Tb) || void 0),
   (this.Ca = (f && f.useFetchStreams) || !1),
   (this.L = void 0),
   (this.J = (f && f.supportsCrossDomainXhr) || !1),
   (this.K = ""),
   (this.h = new Gv(f && f.concurrentRequestLimit)),
   (this.Da = new Qb()),
   (this.P = (f && f.fastHandshake) || !1),
   (this.O = (f && f.encodeInitMessageHeaders) || !1),
   this.P && this.O && (this.O = !1),
   (this.Ua = (f && f.Rb) || !1),
   f && f.xa && this.j.xa(),
   f && f.forceLongPolling && (this.X = !1),
   (this.ba = (!this.P && this.X && f && f.detectBufferingProxy) || !1),
   (this.ja = void 0),
   f && f.longPollingTimeout && 0 < f.longPollingTimeout && (this.ja = f.longPollingTimeout),
   (this.ca = void 0),
   (this.R = 0),
   (this.M = !1),
   (this.ka = this.A = null);
 }
 (t = u_.prototype),
  (t.la = 8),
  (t.G = 1),
  (t.connect = function (f, g, y, S) {
   Ut(0),
    (this.W = f),
    (this.H = g || {}),
    y && S !== void 0 && ((this.H.OSID = y), (this.H.OAID = S)),
    (this.F = this.X),
    (this.I = v_(this, null, this.W)),
    Eu(this);
  });
 function Zf(f) {
  if ((c_(f), f.G == 3)) {
   var g = f.U++,
    y = pr(f.I);
   if (
    (ke(y, "SID", f.K),
    ke(y, "RID", g),
    ke(y, "TYPE", "terminate"),
    da(f, y),
    (g = new Hr(f, f.j, g)),
    (g.L = 2),
    (g.v = gu(pr(y))),
    (y = !1),
    a.navigator && a.navigator.sendBeacon)
   )
    try {
     y = a.navigator.sendBeacon(g.v.toString(), "");
    } catch {}
   !y && a.Image && ((new Image().src = g.v), (y = !0)),
    y || ((g.g = __(g.j, null)), g.g.ea(g.v)),
    (g.F = Date.now()),
    hu(g);
  }
  y_(f);
 }
 function wu(f) {
  f.g && (th(f), f.g.cancel(), (f.g = null));
 }
 function c_(f) {
  wu(f),
   f.u && (a.clearTimeout(f.u), (f.u = null)),
   Tu(f),
   f.h.cancel(),
   f.s && (typeof f.s == "number" && a.clearTimeout(f.s), (f.s = null));
 }
 function Eu(f) {
  if (!zv(f.h) && !f.s) {
   f.s = !0;
   var g = f.Ga;
   _n || ae(), z || (_n(), (z = !0)), Z.add(g, f), (f.B = 0);
  }
 }
 function tN(f, g) {
  return Wv(f.h) >= f.h.j - (f.s ? 1 : 0)
   ? !1
   : f.s
     ? ((f.i = g.D.concat(f.i)), !0)
     : f.G == 1 || f.G == 2 || f.B >= (f.Va ? 0 : f.Wa)
       ? !1
       : ((f.s = na(m(f.Ga, f, g), g_(f, f.B))), f.B++, !0);
 }
 t.Ga = function (f) {
  if (this.s)
   if (((this.s = null), this.G == 1)) {
    if (!f) {
     (this.U = Math.floor(1e5 * Math.random())), (f = this.U++);
     const V = new Hr(this, this.j, f);
     let U = this.o;
     if (
      (this.S && (U ? ((U = I(U)), k(U, this.S)) : (U = this.S)),
      this.m !== null || this.O || ((V.H = U), (U = null)),
      this.P)
     )
      e: {
       for (var g = 0, y = 0; y < this.i.length; y++) {
        t: {
         var S = this.i[y];
         if ("__data__" in S.map && ((S = S.map.__data__), typeof S == "string")) {
          S = S.length;
          break t;
         }
         S = void 0;
        }
        if (S === void 0) break;
        if (((g += S), 4096 < g)) {
         g = y;
         break e;
        }
        if (g === 4096 || y === this.i.length - 1) {
         g = y + 1;
         break e;
        }
       }
       g = 1e3;
      }
     else g = 1e3;
     (g = f_(this, V, g)),
      (y = pr(this.I)),
      ke(y, "RID", f),
      ke(y, "CVER", 22),
      this.D && ke(y, "X-HTTP-Session-Id", this.D),
      da(this, y),
      U && (this.O ? (g = "headers=" + encodeURIComponent(String(r_(U))) + "&" + g) : this.m && jf(y, this.m, U)),
      Xf(this.h, V),
      this.Ua && ke(y, "TYPE", "init"),
      this.P ? (ke(y, "$req", g), ke(y, "SID", "null"), (V.T = !0), Kf(V, y, null)) : Kf(V, y, g),
      (this.G = 2);
    }
   } else this.G == 3 && (f ? d_(this, f) : this.i.length == 0 || zv(this.h) || d_(this));
 };
 function d_(f, g) {
  var y;
  g ? (y = g.l) : (y = f.U++);
  const S = pr(f.I);
  ke(S, "SID", f.K),
   ke(S, "RID", y),
   ke(S, "AID", f.T),
   da(f, S),
   f.m && f.o && jf(S, f.m, f.o),
   (y = new Hr(f, f.j, y, f.B + 1)),
   f.m === null && (y.H = f.o),
   g && (f.i = g.D.concat(f.i)),
   (g = f_(f, y, 1e3)),
   (y.I = Math.round(0.5 * f.wa) + Math.round(0.5 * f.wa * Math.random())),
   Xf(f.h, y),
   Kf(y, S, g);
 }
 function da(f, g) {
  f.H &&
   F(f.H, function (y, S) {
    ke(g, S, y);
   }),
   f.l &&
    Yv({}, function (y, S) {
     ke(g, S, y);
    });
 }
 function f_(f, g, y) {
  y = Math.min(f.i.length, y);
  var S = f.l ? m(f.l.Na, f.l, f) : null;
  e: {
   var V = f.i;
   let U = -1;
   for (;;) {
    const G = ["count=" + y];
    U == -1 ? (0 < y ? ((U = V[0].g), G.push("ofs=" + U)) : (U = 0)) : G.push("ofs=" + U);
    let Ce = !0;
    for (let ft = 0; ft < y; ft++) {
     let me = V[ft].g;
     const Et = V[ft].map;
     if (((me -= U), 0 > me)) (U = Math.max(0, V[ft].g - 100)), (Ce = !1);
     else
      try {
       Xb(Et, G, "req" + me + "_");
      } catch {
       S && S(Et);
      }
    }
    if (Ce) {
     S = G.join("&");
     break e;
    }
   }
  }
  return (f = f.i.splice(0, y)), (g.D = f), S;
 }
 function h_(f) {
  if (!f.g && !f.u) {
   f.Y = 1;
   var g = f.Fa;
   _n || ae(), z || (_n(), (z = !0)), Z.add(g, f), (f.v = 0);
  }
 }
 function eh(f) {
  return f.g || f.u || 3 <= f.v ? !1 : (f.Y++, (f.u = na(m(f.Fa, f), g_(f, f.v))), f.v++, !0);
 }
 (t.Fa = function () {
  if (((this.u = null), p_(this), this.ba && !(this.M || this.g == null || 0 >= this.R))) {
   var f = 2 * this.R;
   this.j.info("BP detection timer enabled: " + f), (this.A = na(m(this.ab, this), f));
  }
 }),
  (t.ab = function () {
   this.A &&
    ((this.A = null),
    this.j.info("BP detection timeout reached."),
    this.j.info("Buffering proxy detected and switch to long-polling!"),
    (this.F = !1),
    (this.M = !0),
    Ut(10),
    wu(this),
    p_(this));
  });
 function th(f) {
  f.A != null && (a.clearTimeout(f.A), (f.A = null));
 }
 function p_(f) {
  (f.g = new Hr(f, f.j, "rpc", f.Y)), f.m === null && (f.g.H = f.o), (f.g.O = 0);
  var g = pr(f.qa);
  ke(g, "RID", "rpc"),
   ke(g, "SID", f.K),
   ke(g, "AID", f.T),
   ke(g, "CI", f.F ? "0" : "1"),
   !f.F && f.ja && ke(g, "TO", f.ja),
   ke(g, "TYPE", "xmlhttp"),
   da(f, g),
   f.m && f.o && jf(g, f.m, f.o),
   f.L && (f.g.I = f.L);
  var y = f.g;
  (f = f.ia), (y.L = 1), (y.v = gu(pr(g))), (y.m = null), (y.P = !0), $v(y, f);
 }
 t.Za = function () {
  this.C != null && ((this.C = null), wu(this), eh(this), Ut(19));
 };
 function Tu(f) {
  f.C != null && (a.clearTimeout(f.C), (f.C = null));
 }
 function m_(f, g) {
  var y = null;
  if (f.g == g) {
   Tu(f), th(f), (f.g = null);
   var S = 2;
  } else if (Qf(f.h, g)) (y = g.D), Kv(f.h, g), (S = 1);
  else return;
  if (f.G != 0) {
   if (g.o)
    if (S == 1) {
     (y = g.m ? g.m.length : 0), (g = Date.now() - g.F);
     var V = f.B;
     (S = cu()), Vt(S, new Uv(S, y)), Eu(f);
    } else h_(f);
   else if (((V = g.s), V == 3 || (V == 0 && 0 < g.X) || !((S == 1 && tN(f, g)) || (S == 2 && eh(f)))))
    switch ((y && 0 < y.length && ((g = f.h), (g.i = g.i.concat(y))), V)) {
     case 1:
      Bi(f, 5);
      break;
     case 4:
      Bi(f, 10);
      break;
     case 3:
      Bi(f, 6);
      break;
     default:
      Bi(f, 2);
    }
  }
 }
 function g_(f, g) {
  let y = f.Ta + Math.floor(Math.random() * f.cb);
  return f.isActive() || (y *= 2), y * g;
 }
 function Bi(f, g) {
  if ((f.j.info("Error code " + g), g == 2)) {
   var y = m(f.fb, f),
    S = f.Xa;
   const V = !S;
   (S = new Fi(S || "//www.google.com/images/cleardot.gif")),
    (a.location && a.location.protocol == "http") || pu(S, "https"),
    gu(S),
    V ? Jb(S.toString(), y) : Yb(S.toString(), y);
  } else Ut(2);
  (f.G = 0), f.l && f.l.sa(g), y_(f), c_(f);
 }
 t.fb = function (f) {
  f ? (this.j.info("Successfully pinged google.com"), Ut(2)) : (this.j.info("Failed to ping google.com"), Ut(1));
 };
 function y_(f) {
  if (((f.G = 0), (f.ka = []), f.l)) {
   const g = Jv(f.h);
   (g.length != 0 || f.i.length != 0) && (A(f.ka, g), A(f.ka, f.i), (f.h.i.length = 0), C(f.i), (f.i.length = 0)),
    f.l.ra();
  }
 }
 function v_(f, g, y) {
  var S = y instanceof Fi ? pr(y) : new Fi(y);
  if (S.g != "") g && (S.g = g + "." + S.g), mu(S, S.s);
  else {
   var V = a.location;
   (S = V.protocol), (g = g ? g + "." + V.hostname : V.hostname), (V = +V.port);
   var U = new Fi(null);
   S && pu(U, S), g && (U.g = g), V && mu(U, V), y && (U.l = y), (S = U);
  }
  return (y = f.D), (g = f.ya), y && g && ke(S, y, g), ke(S, "VER", f.la), da(f, S), S;
 }
 function __(f, g, y) {
  if (g && !f.J) throw Error("Can't create secondary domain capable XhrIo object.");
  return (g = f.Ca && !f.pa ? new $e(new yu({ eb: y })) : new $e(f.pa)), g.Ha(f.J), g;
 }
 t.isActive = function () {
  return !!this.l && this.l.isActive(this);
 };
 function w_() {}
 (t = w_.prototype),
  (t.ua = function () {}),
  (t.ta = function () {}),
  (t.sa = function () {}),
  (t.ra = function () {}),
  (t.isActive = function () {
   return !0;
  }),
  (t.Na = function () {});
 function Iu() {}
 Iu.prototype.g = function (f, g) {
  return new sn(f, g);
 };
 function sn(f, g) {
  wt.call(this),
   (this.g = new u_(g)),
   (this.l = f),
   (this.h = (g && g.messageUrlParams) || null),
   (f = (g && g.messageHeaders) || null),
   g &&
    g.clientProtocolHeaderRequired &&
    (f ? (f["X-Client-Protocol"] = "webchannel") : (f = { "X-Client-Protocol": "webchannel" })),
   (this.g.o = f),
   (f = (g && g.initMessageHeaders) || null),
   g &&
    g.messageContentType &&
    (f
     ? (f["X-WebChannel-Content-Type"] = g.messageContentType)
     : (f = { "X-WebChannel-Content-Type": g.messageContentType })),
   g && g.va && (f ? (f["X-WebChannel-Client-Profile"] = g.va) : (f = { "X-WebChannel-Client-Profile": g.va })),
   (this.g.S = f),
   (f = g && g.Sb) && !_(f) && (this.g.m = f),
   (this.v = (g && g.supportsCrossDomainXhr) || !1),
   (this.u = (g && g.sendRawJson) || !1),
   (g = g && g.httpSessionIdParam) &&
    !_(g) &&
    ((this.g.D = g), (f = this.h), f !== null && g in f && ((f = this.h), g in f && delete f[g])),
   (this.j = new Vo(this));
 }
 w(sn, wt),
  (sn.prototype.m = function () {
   (this.g.l = this.j), this.v && (this.g.J = !0), this.g.connect(this.l, this.h || void 0);
  }),
  (sn.prototype.close = function () {
   Zf(this.g);
  }),
  (sn.prototype.o = function (f) {
   var g = this.g;
   if (typeof f == "string") {
    var y = {};
    (y.__data__ = f), (f = y);
   } else this.u && ((y = {}), (y.__data__ = $f(f)), (f = y));
   g.i.push(new Ob(g.Ya++, f)), g.G == 3 && Eu(g);
  }),
  (sn.prototype.N = function () {
   (this.g.l = null), delete this.j, Zf(this.g), delete this.g, sn.aa.N.call(this);
  });
 function E_(f) {
  qf.call(this),
   f.__headers__ &&
    ((this.headers = f.__headers__), (this.statusCode = f.__status__), delete f.__headers__, delete f.__status__);
  var g = f.__sm__;
  if (g) {
   e: {
    for (const y in g) {
     f = y;
     break e;
    }
    f = void 0;
   }
   (this.i = f) && ((f = this.i), (g = g !== null && f in g ? g[f] : void 0)), (this.data = g);
  } else this.data = f;
 }
 w(E_, qf);
 function T_() {
  Gf.call(this), (this.status = 1);
 }
 w(T_, Gf);
 function Vo(f) {
  this.g = f;
 }
 w(Vo, w_),
  (Vo.prototype.ua = function () {
   Vt(this.g, "a");
  }),
  (Vo.prototype.ta = function (f) {
   Vt(this.g, new E_(f));
  }),
  (Vo.prototype.sa = function (f) {
   Vt(this.g, new T_());
  }),
  (Vo.prototype.ra = function () {
   Vt(this.g, "b");
  }),
  (Iu.prototype.createWebChannel = Iu.prototype.g),
  (sn.prototype.send = sn.prototype.o),
  (sn.prototype.open = sn.prototype.m),
  (sn.prototype.close = sn.prototype.close),
  (kR = function () {
   return new Iu();
  }),
  (PR = function () {
   return cu();
  }),
  (RR = Ui),
  (dm = {
   mb: 0,
   pb: 1,
   qb: 2,
   Jb: 3,
   Ob: 4,
   Lb: 5,
   Mb: 6,
   Kb: 7,
   Ib: 8,
   Nb: 9,
   PROXY: 10,
   NOPROXY: 11,
   Gb: 12,
   Cb: 13,
   Db: 14,
   Bb: 15,
   Eb: 16,
   Fb: 17,
   ib: 18,
   hb: 19,
   jb: 20,
  }),
  (du.NO_ERROR = 0),
  (du.TIMEOUT = 8),
  (du.HTTP_ERROR = 6),
  (Ic = du),
  (Ov.COMPLETE = "complete"),
  (CR = Ov),
  (Mv.EventType = ea),
  (ea.OPEN = "a"),
  (ea.CLOSE = "b"),
  (ea.ERROR = "c"),
  (ea.MESSAGE = "d"),
  (wt.prototype.listen = wt.prototype.K),
  (xa = Mv),
  ($e.prototype.listenOnce = $e.prototype.L),
  ($e.prototype.getLastError = $e.prototype.Ka),
  ($e.prototype.getLastErrorCode = $e.prototype.Ba),
  ($e.prototype.getStatus = $e.prototype.Z),
  ($e.prototype.getResponseJson = $e.prototype.Oa),
  ($e.prototype.getResponseText = $e.prototype.oa),
  ($e.prototype.send = $e.prototype.ea),
  ($e.prototype.setWithCredentials = $e.prototype.Ha),
  (AR = $e);
}).apply(typeof zu < "u" ? zu : typeof self < "u" ? self : typeof window < "u" ? window : {});
const N0 = "@firebase/firestore";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ct {
 constructor(e) {
  this.uid = e;
 }
 isAuthenticated() {
  return this.uid != null;
 }
 toKey() {
  return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
 }
 isEqual(e) {
  return e.uid === this.uid;
 }
}
(Ct.UNAUTHENTICATED = new Ct(null)),
 (Ct.GOOGLE_CREDENTIALS = new Ct("google-credentials-uid")),
 (Ct.FIRST_PARTY = new Ct("first-party-uid")),
 (Ct.MOCK_USER = new Ct("mock-user"));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let zs = "10.14.0";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const go = new of("@firebase/firestore");
function wa() {
 return go.logLevel;
}
function Q(t, ...e) {
 if (go.logLevel <= de.DEBUG) {
  const n = e.map(yy);
  go.debug(`Firestore (${zs}): ${t}`, ...n);
 }
}
function xr(t, ...e) {
 if (go.logLevel <= de.ERROR) {
  const n = e.map(yy);
  go.error(`Firestore (${zs}): ${t}`, ...n);
 }
}
function ks(t, ...e) {
 if (go.logLevel <= de.WARN) {
  const n = e.map(yy);
  go.warn(`Firestore (${zs}): ${t}`, ...n);
 }
}
function yy(t) {
 if (typeof t == "string") return t;
 try {
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */ return (function (n) {
   return JSON.stringify(n);
  })(t);
 } catch {
  return t;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function ne(t = "Unexpected state") {
 const e = `FIRESTORE (${zs}) INTERNAL ASSERTION FAILED: ` + t;
 throw (xr(e), new Error(e));
}
function we(t, e) {
 t || ne();
}
function re(t, e) {
 return t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const B = {
 OK: "ok",
 CANCELLED: "cancelled",
 UNKNOWN: "unknown",
 INVALID_ARGUMENT: "invalid-argument",
 DEADLINE_EXCEEDED: "deadline-exceeded",
 NOT_FOUND: "not-found",
 ALREADY_EXISTS: "already-exists",
 PERMISSION_DENIED: "permission-denied",
 UNAUTHENTICATED: "unauthenticated",
 RESOURCE_EXHAUSTED: "resource-exhausted",
 FAILED_PRECONDITION: "failed-precondition",
 ABORTED: "aborted",
 OUT_OF_RANGE: "out-of-range",
 UNIMPLEMENTED: "unimplemented",
 INTERNAL: "internal",
 UNAVAILABLE: "unavailable",
 DATA_LOSS: "data-loss",
};
class J extends bn {
 constructor(e, n) {
  super(e, n),
   (this.code = e),
   (this.message = n),
   (this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class or {
 constructor() {
  this.promise = new Promise((e, n) => {
   (this.resolve = e), (this.reject = n);
  });
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class bR {
 constructor(e, n) {
  (this.user = n), (this.type = "OAuth"), (this.headers = new Map()), this.headers.set("Authorization", `Bearer ${e}`);
 }
}
class FF {
 getToken() {
  return Promise.resolve(null);
 }
 invalidateToken() {}
 start(e, n) {
  e.enqueueRetryable(() => n(Ct.UNAUTHENTICATED));
 }
 shutdown() {}
}
class BF {
 constructor(e) {
  (this.token = e), (this.changeListener = null);
 }
 getToken() {
  return Promise.resolve(this.token);
 }
 invalidateToken() {}
 start(e, n) {
  (this.changeListener = n), e.enqueueRetryable(() => n(this.token.user));
 }
 shutdown() {
  this.changeListener = null;
 }
}
class $F {
 constructor(e) {
  (this.t = e), (this.currentUser = Ct.UNAUTHENTICATED), (this.i = 0), (this.forceRefresh = !1), (this.auth = null);
 }
 start(e, n) {
  we(this.o === void 0);
  let r = this.i;
  const i = (l) => (this.i !== r ? ((r = this.i), n(l)) : Promise.resolve());
  let o = new or();
  this.o = () => {
   this.i++, (this.currentUser = this.u()), o.resolve(), (o = new or()), e.enqueueRetryable(() => i(this.currentUser));
  };
  const s = () => {
    const l = o;
    e.enqueueRetryable(async () => {
     await l.promise, await i(this.currentUser);
    });
   },
   a = (l) => {
    Q("FirebaseAuthCredentialsProvider", "Auth detected"),
     (this.auth = l),
     this.o && (this.auth.addAuthTokenListener(this.o), s());
   };
  this.t.onInit((l) => a(l)),
   setTimeout(() => {
    if (!this.auth) {
     const l = this.t.getImmediate({ optional: !0 });
     l ? a(l) : (Q("FirebaseAuthCredentialsProvider", "Auth not yet detected"), o.resolve(), (o = new or()));
    }
   }, 0),
   s();
 }
 getToken() {
  const e = this.i,
   n = this.forceRefresh;
  return (
   (this.forceRefresh = !1),
   this.auth
    ? this.auth
       .getToken(n)
       .then((r) =>
        this.i !== e
         ? (Q("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken())
         : r
           ? (we(typeof r.accessToken == "string"), new bR(r.accessToken, this.currentUser))
           : null
       )
    : Promise.resolve(null)
  );
 }
 invalidateToken() {
  this.forceRefresh = !0;
 }
 shutdown() {
  this.auth && this.o && this.auth.removeAuthTokenListener(this.o), (this.o = void 0);
 }
 u() {
  const e = this.auth && this.auth.getUid();
  return we(e === null || typeof e == "string"), new Ct(e);
 }
}
class HF {
 constructor(e, n, r) {
  (this.l = e),
   (this.h = n),
   (this.P = r),
   (this.type = "FirstParty"),
   (this.user = Ct.FIRST_PARTY),
   (this.I = new Map());
 }
 T() {
  return this.P ? this.P() : null;
 }
 get headers() {
  this.I.set("X-Goog-AuthUser", this.l);
  const e = this.T();
  return e && this.I.set("Authorization", e), this.h && this.I.set("X-Goog-Iam-Authorization-Token", this.h), this.I;
 }
}
class qF {
 constructor(e, n, r) {
  (this.l = e), (this.h = n), (this.P = r);
 }
 getToken() {
  return Promise.resolve(new HF(this.l, this.h, this.P));
 }
 start(e, n) {
  e.enqueueRetryable(() => n(Ct.FIRST_PARTY));
 }
 shutdown() {}
 invalidateToken() {}
}
class GF {
 constructor(e) {
  (this.value = e),
   (this.type = "AppCheck"),
   (this.headers = new Map()),
   e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
 }
}
class zF {
 constructor(e) {
  (this.A = e), (this.forceRefresh = !1), (this.appCheck = null), (this.R = null);
 }
 start(e, n) {
  we(this.o === void 0);
  const r = (o) => {
   o.error != null &&
    Q(
     "FirebaseAppCheckTokenProvider",
     `Error getting App Check token; using placeholder token instead. Error: ${o.error.message}`
    );
   const s = o.token !== this.R;
   return (
    (this.R = o.token),
    Q("FirebaseAppCheckTokenProvider", `Received ${s ? "new" : "existing"} token.`),
    s ? n(o.token) : Promise.resolve()
   );
  };
  this.o = (o) => {
   e.enqueueRetryable(() => r(o));
  };
  const i = (o) => {
   Q("FirebaseAppCheckTokenProvider", "AppCheck detected"),
    (this.appCheck = o),
    this.o && this.appCheck.addTokenListener(this.o);
  };
  this.A.onInit((o) => i(o)),
   setTimeout(() => {
    if (!this.appCheck) {
     const o = this.A.getImmediate({ optional: !0 });
     o ? i(o) : Q("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
    }
   }, 0);
 }
 getToken() {
  const e = this.forceRefresh;
  return (
   (this.forceRefresh = !1),
   this.appCheck
    ? this.appCheck
       .getToken(e)
       .then((n) => (n ? (we(typeof n.token == "string"), (this.R = n.token), new GF(n.token)) : null))
    : Promise.resolve(null)
  );
 }
 invalidateToken() {
  this.forceRefresh = !0;
 }
 shutdown() {
  this.appCheck && this.o && this.appCheck.removeTokenListener(this.o), (this.o = void 0);
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function WF(t) {
 const e = typeof self < "u" && (self.crypto || self.msCrypto),
  n = new Uint8Array(t);
 if (e && typeof e.getRandomValues == "function") e.getRandomValues(n);
 else for (let r = 0; r < t; r++) n[r] = Math.floor(256 * Math.random());
 return n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class NR {
 static newId() {
  const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
   n = Math.floor(256 / e.length) * e.length;
  let r = "";
  for (; r.length < 20; ) {
   const i = WF(40);
   for (let o = 0; o < i.length; ++o) r.length < 20 && i[o] < n && (r += e.charAt(i[o] % e.length));
  }
  return r;
 }
}
function ge(t, e) {
 return t < e ? -1 : t > e ? 1 : 0;
}
function bs(t, e, n) {
 return t.length === e.length && t.every((r, i) => n(r, e[i]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class st {
 constructor(e, n) {
  if (((this.seconds = e), (this.nanoseconds = n), n < 0))
   throw new J(B.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + n);
  if (n >= 1e9) throw new J(B.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + n);
  if (e < -62135596800) throw new J(B.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e);
  if (e >= 253402300800) throw new J(B.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e);
 }
 static now() {
  return st.fromMillis(Date.now());
 }
 static fromDate(e) {
  return st.fromMillis(e.getTime());
 }
 static fromMillis(e) {
  const n = Math.floor(e / 1e3),
   r = Math.floor(1e6 * (e - 1e3 * n));
  return new st(n, r);
 }
 toDate() {
  return new Date(this.toMillis());
 }
 toMillis() {
  return 1e3 * this.seconds + this.nanoseconds / 1e6;
 }
 _compareTo(e) {
  return this.seconds === e.seconds ? ge(this.nanoseconds, e.nanoseconds) : ge(this.seconds, e.seconds);
 }
 isEqual(e) {
  return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
 }
 toString() {
  return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
 }
 toJSON() {
  return { seconds: this.seconds, nanoseconds: this.nanoseconds };
 }
 valueOf() {
  const e = this.seconds - -62135596800;
  return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class oe {
 constructor(e) {
  this.timestamp = e;
 }
 static fromTimestamp(e) {
  return new oe(e);
 }
 static min() {
  return new oe(new st(0, 0));
 }
 static max() {
  return new oe(new st(253402300799, 999999999));
 }
 compareTo(e) {
  return this.timestamp._compareTo(e.timestamp);
 }
 isEqual(e) {
  return this.timestamp.isEqual(e.timestamp);
 }
 toMicroseconds() {
  return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
 }
 toString() {
  return "SnapshotVersion(" + this.timestamp.toString() + ")";
 }
 toTimestamp() {
  return this.timestamp;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Tl {
 constructor(e, n, r) {
  n === void 0 ? (n = 0) : n > e.length && ne(),
   r === void 0 ? (r = e.length - n) : r > e.length - n && ne(),
   (this.segments = e),
   (this.offset = n),
   (this.len = r);
 }
 get length() {
  return this.len;
 }
 isEqual(e) {
  return Tl.comparator(this, e) === 0;
 }
 child(e) {
  const n = this.segments.slice(this.offset, this.limit());
  return (
   e instanceof Tl
    ? e.forEach((r) => {
       n.push(r);
      })
    : n.push(e),
   this.construct(n)
  );
 }
 limit() {
  return this.offset + this.length;
 }
 popFirst(e) {
  return (e = e === void 0 ? 1 : e), this.construct(this.segments, this.offset + e, this.length - e);
 }
 popLast() {
  return this.construct(this.segments, this.offset, this.length - 1);
 }
 firstSegment() {
  return this.segments[this.offset];
 }
 lastSegment() {
  return this.get(this.length - 1);
 }
 get(e) {
  return this.segments[this.offset + e];
 }
 isEmpty() {
  return this.length === 0;
 }
 isPrefixOf(e) {
  if (e.length < this.length) return !1;
  for (let n = 0; n < this.length; n++) if (this.get(n) !== e.get(n)) return !1;
  return !0;
 }
 isImmediateParentOf(e) {
  if (this.length + 1 !== e.length) return !1;
  for (let n = 0; n < this.length; n++) if (this.get(n) !== e.get(n)) return !1;
  return !0;
 }
 forEach(e) {
  for (let n = this.offset, r = this.limit(); n < r; n++) e(this.segments[n]);
 }
 toArray() {
  return this.segments.slice(this.offset, this.limit());
 }
 static comparator(e, n) {
  const r = Math.min(e.length, n.length);
  for (let i = 0; i < r; i++) {
   const o = e.get(i),
    s = n.get(i);
   if (o < s) return -1;
   if (o > s) return 1;
  }
  return e.length < n.length ? -1 : e.length > n.length ? 1 : 0;
 }
}
class Ne extends Tl {
 construct(e, n, r) {
  return new Ne(e, n, r);
 }
 canonicalString() {
  return this.toArray().join("/");
 }
 toString() {
  return this.canonicalString();
 }
 toUriEncodedString() {
  return this.toArray().map(encodeURIComponent).join("/");
 }
 static fromString(...e) {
  const n = [];
  for (const r of e) {
   if (r.indexOf("//") >= 0)
    throw new J(B.INVALID_ARGUMENT, `Invalid segment (${r}). Paths must not contain // in them.`);
   n.push(...r.split("/").filter((i) => i.length > 0));
  }
  return new Ne(n);
 }
 static emptyPath() {
  return new Ne([]);
 }
}
const KF = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class mt extends Tl {
 construct(e, n, r) {
  return new mt(e, n, r);
 }
 static isValidIdentifier(e) {
  return KF.test(e);
 }
 canonicalString() {
  return this.toArray()
   .map((e) => ((e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`")), mt.isValidIdentifier(e) || (e = "`" + e + "`"), e))
   .join(".");
 }
 toString() {
  return this.canonicalString();
 }
 isKeyField() {
  return this.length === 1 && this.get(0) === "__name__";
 }
 static keyField() {
  return new mt(["__name__"]);
 }
 static fromServerFormat(e) {
  const n = [];
  let r = "",
   i = 0;
  const o = () => {
   if (r.length === 0)
    throw new J(
     B.INVALID_ARGUMENT,
     `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`
    );
   n.push(r), (r = "");
  };
  let s = !1;
  for (; i < e.length; ) {
   const a = e[i];
   if (a === "\\") {
    if (i + 1 === e.length) throw new J(B.INVALID_ARGUMENT, "Path has trailing escape character: " + e);
    const l = e[i + 1];
    if (l !== "\\" && l !== "." && l !== "`") throw new J(B.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e);
    (r += l), (i += 2);
   } else a === "`" ? ((s = !s), i++) : a !== "." || s ? ((r += a), i++) : (o(), i++);
  }
  if ((o(), s)) throw new J(B.INVALID_ARGUMENT, "Unterminated ` in path: " + e);
  return new mt(n);
 }
 static emptyPath() {
  return new mt([]);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class j {
 constructor(e) {
  this.path = e;
 }
 static fromPath(e) {
  return new j(Ne.fromString(e));
 }
 static fromName(e) {
  return new j(Ne.fromString(e).popFirst(5));
 }
 static empty() {
  return new j(Ne.emptyPath());
 }
 get collectionGroup() {
  return this.path.popLast().lastSegment();
 }
 hasCollectionId(e) {
  return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
 }
 getCollectionGroup() {
  return this.path.get(this.path.length - 2);
 }
 getCollectionPath() {
  return this.path.popLast();
 }
 isEqual(e) {
  return e !== null && Ne.comparator(this.path, e.path) === 0;
 }
 toString() {
  return this.path.toString();
 }
 static comparator(e, n) {
  return Ne.comparator(e.path, n.path);
 }
 static isDocumentKey(e) {
  return e.length % 2 == 0;
 }
 static fromSegments(e) {
  return new j(new Ne(e.slice()));
 }
}
function JF(t, e) {
 const n = t.toTimestamp().seconds,
  r = t.toTimestamp().nanoseconds + 1,
  i = oe.fromTimestamp(r === 1e9 ? new st(n + 1, 0) : new st(n, r));
 return new Ci(i, j.empty(), e);
}
function YF(t) {
 return new Ci(t.readTime, t.key, -1);
}
class Ci {
 constructor(e, n, r) {
  (this.readTime = e), (this.documentKey = n), (this.largestBatchId = r);
 }
 static min() {
  return new Ci(oe.min(), j.empty(), -1);
 }
 static max() {
  return new Ci(oe.max(), j.empty(), -1);
 }
}
function QF(t, e) {
 let n = t.readTime.compareTo(e.readTime);
 return n !== 0
  ? n
  : ((n = j.comparator(t.documentKey, e.documentKey)), n !== 0 ? n : ge(t.largestBatchId, e.largestBatchId));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const XF =
 "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class jF {
 constructor() {
  this.onCommittedListeners = [];
 }
 addOnCommittedListener(e) {
  this.onCommittedListeners.push(e);
 }
 raiseOnCommittedEvent() {
  this.onCommittedListeners.forEach((e) => e());
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Yl(t) {
 if (t.code !== B.FAILED_PRECONDITION || t.message !== XF) throw t;
 Q("LocalStore", "Unexpectedly lost primary lease");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class $ {
 constructor(e) {
  (this.nextCallback = null),
   (this.catchCallback = null),
   (this.result = void 0),
   (this.error = void 0),
   (this.isDone = !1),
   (this.callbackAttached = !1),
   e(
    (n) => {
     (this.isDone = !0), (this.result = n), this.nextCallback && this.nextCallback(n);
    },
    (n) => {
     (this.isDone = !0), (this.error = n), this.catchCallback && this.catchCallback(n);
    }
   );
 }
 catch(e) {
  return this.next(void 0, e);
 }
 next(e, n) {
  return (
   this.callbackAttached && ne(),
   (this.callbackAttached = !0),
   this.isDone
    ? this.error
      ? this.wrapFailure(n, this.error)
      : this.wrapSuccess(e, this.result)
    : new $((r, i) => {
       (this.nextCallback = (o) => {
        this.wrapSuccess(e, o).next(r, i);
       }),
        (this.catchCallback = (o) => {
         this.wrapFailure(n, o).next(r, i);
        });
      })
  );
 }
 toPromise() {
  return new Promise((e, n) => {
   this.next(e, n);
  });
 }
 wrapUserFunction(e) {
  try {
   const n = e();
   return n instanceof $ ? n : $.resolve(n);
  } catch (n) {
   return $.reject(n);
  }
 }
 wrapSuccess(e, n) {
  return e ? this.wrapUserFunction(() => e(n)) : $.resolve(n);
 }
 wrapFailure(e, n) {
  return e ? this.wrapUserFunction(() => e(n)) : $.reject(n);
 }
 static resolve(e) {
  return new $((n, r) => {
   n(e);
  });
 }
 static reject(e) {
  return new $((n, r) => {
   r(e);
  });
 }
 static waitFor(e) {
  return new $((n, r) => {
   let i = 0,
    o = 0,
    s = !1;
   e.forEach((a) => {
    ++i,
     a.next(
      () => {
       ++o, s && o === i && n();
      },
      (l) => r(l)
     );
   }),
    (s = !0),
    o === i && n();
  });
 }
 static or(e) {
  let n = $.resolve(!1);
  for (const r of e) n = n.next((i) => (i ? $.resolve(i) : r()));
  return n;
 }
 static forEach(e, n) {
  const r = [];
  return (
   e.forEach((i, o) => {
    r.push(n.call(this, i, o));
   }),
   this.waitFor(r)
  );
 }
 static mapArray(e, n) {
  return new $((r, i) => {
   const o = e.length,
    s = new Array(o);
   let a = 0;
   for (let l = 0; l < o; l++) {
    const u = l;
    n(e[u]).next(
     (h) => {
      (s[u] = h), ++a, a === o && r(s);
     },
     (h) => i(h)
    );
   }
  });
 }
 static doWhile(e, n) {
  return new $((r, i) => {
   const o = () => {
    e() === !0
     ? n().next(() => {
        o();
       }, i)
     : r();
   };
   o();
  });
 }
}
function ZF(t) {
 const e = t.match(/Android ([\d.]+)/i),
  n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
 return Number(n);
}
function Ql(t) {
 return t.name === "IndexedDbTransactionError";
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class vy {
 constructor(e, n) {
  (this.previousValue = e),
   n && ((n.sequenceNumberHandler = (r) => this.ie(r)), (this.se = (r) => n.writeSequenceNumber(r)));
 }
 ie(e) {
  return (this.previousValue = Math.max(e, this.previousValue)), this.previousValue;
 }
 next() {
  const e = ++this.previousValue;
  return this.se && this.se(e), e;
 }
}
vy.oe = -1;
function uf(t) {
 return t == null;
}
function yd(t) {
 return t === 0 && 1 / t == -1 / 0;
}
function eB(t) {
 return (
  typeof t == "number" && Number.isInteger(t) && !yd(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER
 );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function x0(t) {
 let e = 0;
 for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && e++;
 return e;
}
function No(t, e) {
 for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]);
}
function tB(t, e) {
 const n = [];
 for (const r in t) Object.prototype.hasOwnProperty.call(t, r) && n.push(e(t[r], r, t));
 return n;
}
function xR(t) {
 for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;
 return !0;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Be {
 constructor(e, n) {
  (this.comparator = e), (this.root = n || pt.EMPTY);
 }
 insert(e, n) {
  return new Be(this.comparator, this.root.insert(e, n, this.comparator).copy(null, null, pt.BLACK, null, null));
 }
 remove(e) {
  return new Be(this.comparator, this.root.remove(e, this.comparator).copy(null, null, pt.BLACK, null, null));
 }
 get(e) {
  let n = this.root;
  for (; !n.isEmpty(); ) {
   const r = this.comparator(e, n.key);
   if (r === 0) return n.value;
   r < 0 ? (n = n.left) : r > 0 && (n = n.right);
  }
  return null;
 }
 indexOf(e) {
  let n = 0,
   r = this.root;
  for (; !r.isEmpty(); ) {
   const i = this.comparator(e, r.key);
   if (i === 0) return n + r.left.size;
   i < 0 ? (r = r.left) : ((n += r.left.size + 1), (r = r.right));
  }
  return -1;
 }
 isEmpty() {
  return this.root.isEmpty();
 }
 get size() {
  return this.root.size;
 }
 minKey() {
  return this.root.minKey();
 }
 maxKey() {
  return this.root.maxKey();
 }
 inorderTraversal(e) {
  return this.root.inorderTraversal(e);
 }
 forEach(e) {
  this.inorderTraversal((n, r) => (e(n, r), !1));
 }
 toString() {
  const e = [];
  return this.inorderTraversal((n, r) => (e.push(`${n}:${r}`), !1)), `{${e.join(", ")}}`;
 }
 reverseTraversal(e) {
  return this.root.reverseTraversal(e);
 }
 getIterator() {
  return new Wu(this.root, null, this.comparator, !1);
 }
 getIteratorFrom(e) {
  return new Wu(this.root, e, this.comparator, !1);
 }
 getReverseIterator() {
  return new Wu(this.root, null, this.comparator, !0);
 }
 getReverseIteratorFrom(e) {
  return new Wu(this.root, e, this.comparator, !0);
 }
}
class Wu {
 constructor(e, n, r, i) {
  (this.isReverse = i), (this.nodeStack = []);
  let o = 1;
  for (; !e.isEmpty(); )
   if (((o = n ? r(e.key, n) : 1), n && i && (o *= -1), o < 0)) e = this.isReverse ? e.left : e.right;
   else {
    if (o === 0) {
     this.nodeStack.push(e);
     break;
    }
    this.nodeStack.push(e), (e = this.isReverse ? e.right : e.left);
   }
 }
 getNext() {
  let e = this.nodeStack.pop();
  const n = { key: e.key, value: e.value };
  if (this.isReverse) for (e = e.left; !e.isEmpty(); ) this.nodeStack.push(e), (e = e.right);
  else for (e = e.right; !e.isEmpty(); ) this.nodeStack.push(e), (e = e.left);
  return n;
 }
 hasNext() {
  return this.nodeStack.length > 0;
 }
 peek() {
  if (this.nodeStack.length === 0) return null;
  const e = this.nodeStack[this.nodeStack.length - 1];
  return { key: e.key, value: e.value };
 }
}
class pt {
 constructor(e, n, r, i, o) {
  (this.key = e),
   (this.value = n),
   (this.color = r ?? pt.RED),
   (this.left = i ?? pt.EMPTY),
   (this.right = o ?? pt.EMPTY),
   (this.size = this.left.size + 1 + this.right.size);
 }
 copy(e, n, r, i, o) {
  return new pt(e ?? this.key, n ?? this.value, r ?? this.color, i ?? this.left, o ?? this.right);
 }
 isEmpty() {
  return !1;
 }
 inorderTraversal(e) {
  return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
 }
 reverseTraversal(e) {
  return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
 }
 min() {
  return this.left.isEmpty() ? this : this.left.min();
 }
 minKey() {
  return this.min().key;
 }
 maxKey() {
  return this.right.isEmpty() ? this.key : this.right.maxKey();
 }
 insert(e, n, r) {
  let i = this;
  const o = r(e, i.key);
  return (
   (i =
    o < 0
     ? i.copy(null, null, null, i.left.insert(e, n, r), null)
     : o === 0
       ? i.copy(null, n, null, null, null)
       : i.copy(null, null, null, null, i.right.insert(e, n, r))),
   i.fixUp()
  );
 }
 removeMin() {
  if (this.left.isEmpty()) return pt.EMPTY;
  let e = this;
  return (
   e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()),
   (e = e.copy(null, null, null, e.left.removeMin(), null)),
   e.fixUp()
  );
 }
 remove(e, n) {
  let r,
   i = this;
  if (n(e, i.key) < 0)
   i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()),
    (i = i.copy(null, null, null, i.left.remove(e, n), null));
  else {
   if (
    (i.left.isRed() && (i = i.rotateRight()),
    i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()),
    n(e, i.key) === 0)
   ) {
    if (i.right.isEmpty()) return pt.EMPTY;
    (r = i.right.min()), (i = i.copy(r.key, r.value, null, null, i.right.removeMin()));
   }
   i = i.copy(null, null, null, null, i.right.remove(e, n));
  }
  return i.fixUp();
 }
 isRed() {
  return this.color;
 }
 fixUp() {
  let e = this;
  return (
   e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()),
   e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()),
   e.left.isRed() && e.right.isRed() && (e = e.colorFlip()),
   e
  );
 }
 moveRedLeft() {
  let e = this.colorFlip();
  return (
   e.right.left.isRed() &&
    ((e = e.copy(null, null, null, null, e.right.rotateRight())), (e = e.rotateLeft()), (e = e.colorFlip())),
   e
  );
 }
 moveRedRight() {
  let e = this.colorFlip();
  return e.left.left.isRed() && ((e = e.rotateRight()), (e = e.colorFlip())), e;
 }
 rotateLeft() {
  const e = this.copy(null, null, pt.RED, null, this.right.left);
  return this.right.copy(null, null, this.color, e, null);
 }
 rotateRight() {
  const e = this.copy(null, null, pt.RED, this.left.right, null);
  return this.left.copy(null, null, this.color, null, e);
 }
 colorFlip() {
  const e = this.left.copy(null, null, !this.left.color, null, null),
   n = this.right.copy(null, null, !this.right.color, null, null);
  return this.copy(null, null, !this.color, e, n);
 }
 checkMaxDepth() {
  const e = this.check();
  return Math.pow(2, e) <= this.size + 1;
 }
 check() {
  if ((this.isRed() && this.left.isRed()) || this.right.isRed()) throw ne();
  const e = this.left.check();
  if (e !== this.right.check()) throw ne();
  return e + (this.isRed() ? 0 : 1);
 }
}
(pt.EMPTY = null), (pt.RED = !0), (pt.BLACK = !1);
pt.EMPTY = new (class {
 constructor() {
  this.size = 0;
 }
 get key() {
  throw ne();
 }
 get value() {
  throw ne();
 }
 get color() {
  throw ne();
 }
 get left() {
  throw ne();
 }
 get right() {
  throw ne();
 }
 copy(e, n, r, i, o) {
  return this;
 }
 insert(e, n, r) {
  return new pt(e, n);
 }
 remove(e, n) {
  return this;
 }
 isEmpty() {
  return !0;
 }
 inorderTraversal(e) {
  return !1;
 }
 reverseTraversal(e) {
  return !1;
 }
 minKey() {
  return null;
 }
 maxKey() {
  return null;
 }
 isRed() {
  return !1;
 }
 checkMaxDepth() {
  return !0;
 }
 check() {
  return 0;
 }
})();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class yt {
 constructor(e) {
  (this.comparator = e), (this.data = new Be(this.comparator));
 }
 has(e) {
  return this.data.get(e) !== null;
 }
 first() {
  return this.data.minKey();
 }
 last() {
  return this.data.maxKey();
 }
 get size() {
  return this.data.size;
 }
 indexOf(e) {
  return this.data.indexOf(e);
 }
 forEach(e) {
  this.data.inorderTraversal((n, r) => (e(n), !1));
 }
 forEachInRange(e, n) {
  const r = this.data.getIteratorFrom(e[0]);
  for (; r.hasNext(); ) {
   const i = r.getNext();
   if (this.comparator(i.key, e[1]) >= 0) return;
   n(i.key);
  }
 }
 forEachWhile(e, n) {
  let r;
  for (r = n !== void 0 ? this.data.getIteratorFrom(n) : this.data.getIterator(); r.hasNext(); )
   if (!e(r.getNext().key)) return;
 }
 firstAfterOrEqual(e) {
  const n = this.data.getIteratorFrom(e);
  return n.hasNext() ? n.getNext().key : null;
 }
 getIterator() {
  return new M0(this.data.getIterator());
 }
 getIteratorFrom(e) {
  return new M0(this.data.getIteratorFrom(e));
 }
 add(e) {
  return this.copy(this.data.remove(e).insert(e, !0));
 }
 delete(e) {
  return this.has(e) ? this.copy(this.data.remove(e)) : this;
 }
 isEmpty() {
  return this.data.isEmpty();
 }
 unionWith(e) {
  let n = this;
  return (
   n.size < e.size && ((n = e), (e = this)),
   e.forEach((r) => {
    n = n.add(r);
   }),
   n
  );
 }
 isEqual(e) {
  if (!(e instanceof yt) || this.size !== e.size) return !1;
  const n = this.data.getIterator(),
   r = e.data.getIterator();
  for (; n.hasNext(); ) {
   const i = n.getNext().key,
    o = r.getNext().key;
   if (this.comparator(i, o) !== 0) return !1;
  }
  return !0;
 }
 toArray() {
  const e = [];
  return (
   this.forEach((n) => {
    e.push(n);
   }),
   e
  );
 }
 toString() {
  const e = [];
  return this.forEach((n) => e.push(n)), "SortedSet(" + e.toString() + ")";
 }
 copy(e) {
  const n = new yt(this.comparator);
  return (n.data = e), n;
 }
}
class M0 {
 constructor(e) {
  this.iter = e;
 }
 getNext() {
  return this.iter.getNext().key;
 }
 hasNext() {
  return this.iter.hasNext();
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class un {
 constructor(e) {
  (this.fields = e), e.sort(mt.comparator);
 }
 static empty() {
  return new un([]);
 }
 unionWith(e) {
  let n = new yt(mt.comparator);
  for (const r of this.fields) n = n.add(r);
  for (const r of e) n = n.add(r);
  return new un(n.toArray());
 }
 covers(e) {
  for (const n of this.fields) if (n.isPrefixOf(e)) return !0;
  return !1;
 }
 isEqual(e) {
  return bs(this.fields, e.fields, (n, r) => n.isEqual(r));
 }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class MR extends Error {
 constructor() {
  super(...arguments), (this.name = "Base64DecodeError");
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _t {
 constructor(e) {
  this.binaryString = e;
 }
 static fromBase64String(e) {
  const n = (function (i) {
   try {
    return atob(i);
   } catch (o) {
    throw typeof DOMException < "u" && o instanceof DOMException ? new MR("Invalid base64 string: " + o) : o;
   }
  })(e);
  return new _t(n);
 }
 static fromUint8Array(e) {
  const n = (function (i) {
   let o = "";
   for (let s = 0; s < i.length; ++s) o += String.fromCharCode(i[s]);
   return o;
  })(e);
  return new _t(n);
 }
 [Symbol.iterator]() {
  let e = 0;
  return {
   next: () =>
    e < this.binaryString.length ? { value: this.binaryString.charCodeAt(e++), done: !1 } : { value: void 0, done: !0 },
  };
 }
 toBase64() {
  return (function (n) {
   return btoa(n);
  })(this.binaryString);
 }
 toUint8Array() {
  return (function (n) {
   const r = new Uint8Array(n.length);
   for (let i = 0; i < n.length; i++) r[i] = n.charCodeAt(i);
   return r;
  })(this.binaryString);
 }
 approximateByteSize() {
  return 2 * this.binaryString.length;
 }
 compareTo(e) {
  return ge(this.binaryString, e.binaryString);
 }
 isEqual(e) {
  return this.binaryString === e.binaryString;
 }
}
_t.EMPTY_BYTE_STRING = new _t("");
const nB = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Ri(t) {
 if ((we(!!t), typeof t == "string")) {
  let e = 0;
  const n = nB.exec(t);
  if ((we(!!n), n[1])) {
   let i = n[1];
   (i = (i + "000000000").substr(0, 9)), (e = Number(i));
  }
  const r = new Date(t);
  return { seconds: Math.floor(r.getTime() / 1e3), nanos: e };
 }
 return { seconds: Je(t.seconds), nanos: Je(t.nanos) };
}
function Je(t) {
 return typeof t == "number" ? t : typeof t == "string" ? Number(t) : 0;
}
function yo(t) {
 return typeof t == "string" ? _t.fromBase64String(t) : _t.fromUint8Array(t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function _y(t) {
 var e, n;
 return (
  ((n = (((e = t == null ? void 0 : t.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) ===
   null || n === void 0
   ? void 0
   : n.stringValue) === "server_timestamp"
 );
}
function wy(t) {
 const e = t.mapValue.fields.__previous_value__;
 return _y(e) ? wy(e) : e;
}
function Il(t) {
 const e = Ri(t.mapValue.fields.__local_write_time__.timestampValue);
 return new st(e.seconds, e.nanos);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class rB {
 constructor(e, n, r, i, o, s, a, l, u) {
  (this.databaseId = e),
   (this.appId = n),
   (this.persistenceKey = r),
   (this.host = i),
   (this.ssl = o),
   (this.forceLongPolling = s),
   (this.autoDetectLongPolling = a),
   (this.longPollingOptions = l),
   (this.useFetchStreams = u);
 }
}
class Sl {
 constructor(e, n) {
  (this.projectId = e), (this.database = n || "(default)");
 }
 static empty() {
  return new Sl("", "");
 }
 get isDefaultDatabase() {
  return this.database === "(default)";
 }
 isEqual(e) {
  return e instanceof Sl && e.projectId === this.projectId && e.database === this.database;
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Ku = { mapValue: {} };
function vo(t) {
 return "nullValue" in t
  ? 0
  : "booleanValue" in t
    ? 1
    : "integerValue" in t || "doubleValue" in t
      ? 2
      : "timestampValue" in t
        ? 3
        : "stringValue" in t
          ? 5
          : "bytesValue" in t
            ? 6
            : "referenceValue" in t
              ? 7
              : "geoPointValue" in t
                ? 8
                : "arrayValue" in t
                  ? 9
                  : "mapValue" in t
                    ? _y(t)
                      ? 4
                      : oB(t)
                        ? 9007199254740991
                        : iB(t)
                          ? 10
                          : 11
                    : ne();
}
function ur(t, e) {
 if (t === e) return !0;
 const n = vo(t);
 if (n !== vo(e)) return !1;
 switch (n) {
  case 0:
  case 9007199254740991:
   return !0;
  case 1:
   return t.booleanValue === e.booleanValue;
  case 4:
   return Il(t).isEqual(Il(e));
  case 3:
   return (function (i, o) {
    if (
     typeof i.timestampValue == "string" &&
     typeof o.timestampValue == "string" &&
     i.timestampValue.length === o.timestampValue.length
    )
     return i.timestampValue === o.timestampValue;
    const s = Ri(i.timestampValue),
     a = Ri(o.timestampValue);
    return s.seconds === a.seconds && s.nanos === a.nanos;
   })(t, e);
  case 5:
   return t.stringValue === e.stringValue;
  case 6:
   return (function (i, o) {
    return yo(i.bytesValue).isEqual(yo(o.bytesValue));
   })(t, e);
  case 7:
   return t.referenceValue === e.referenceValue;
  case 8:
   return (function (i, o) {
    return (
     Je(i.geoPointValue.latitude) === Je(o.geoPointValue.latitude) &&
     Je(i.geoPointValue.longitude) === Je(o.geoPointValue.longitude)
    );
   })(t, e);
  case 2:
   return (function (i, o) {
    if ("integerValue" in i && "integerValue" in o) return Je(i.integerValue) === Je(o.integerValue);
    if ("doubleValue" in i && "doubleValue" in o) {
     const s = Je(i.doubleValue),
      a = Je(o.doubleValue);
     return s === a ? yd(s) === yd(a) : isNaN(s) && isNaN(a);
    }
    return !1;
   })(t, e);
  case 9:
   return bs(t.arrayValue.values || [], e.arrayValue.values || [], ur);
  case 10:
  case 11:
   return (function (i, o) {
    const s = i.mapValue.fields || {},
     a = o.mapValue.fields || {};
    if (x0(s) !== x0(a)) return !1;
    for (const l in s) if (s.hasOwnProperty(l) && (a[l] === void 0 || !ur(s[l], a[l]))) return !1;
    return !0;
   })(t, e);
  default:
   return ne();
 }
}
function Al(t, e) {
 return (t.values || []).find((n) => ur(n, e)) !== void 0;
}
function Ns(t, e) {
 if (t === e) return 0;
 const n = vo(t),
  r = vo(e);
 if (n !== r) return ge(n, r);
 switch (n) {
  case 0:
  case 9007199254740991:
   return 0;
  case 1:
   return ge(t.booleanValue, e.booleanValue);
  case 2:
   return (function (o, s) {
    const a = Je(o.integerValue || o.doubleValue),
     l = Je(s.integerValue || s.doubleValue);
    return a < l ? -1 : a > l ? 1 : a === l ? 0 : isNaN(a) ? (isNaN(l) ? 0 : -1) : 1;
   })(t, e);
  case 3:
   return D0(t.timestampValue, e.timestampValue);
  case 4:
   return D0(Il(t), Il(e));
  case 5:
   return ge(t.stringValue, e.stringValue);
  case 6:
   return (function (o, s) {
    const a = yo(o),
     l = yo(s);
    return a.compareTo(l);
   })(t.bytesValue, e.bytesValue);
  case 7:
   return (function (o, s) {
    const a = o.split("/"),
     l = s.split("/");
    for (let u = 0; u < a.length && u < l.length; u++) {
     const h = ge(a[u], l[u]);
     if (h !== 0) return h;
    }
    return ge(a.length, l.length);
   })(t.referenceValue, e.referenceValue);
  case 8:
   return (function (o, s) {
    const a = ge(Je(o.latitude), Je(s.latitude));
    return a !== 0 ? a : ge(Je(o.longitude), Je(s.longitude));
   })(t.geoPointValue, e.geoPointValue);
  case 9:
   return L0(t.arrayValue, e.arrayValue);
  case 10:
   return (function (o, s) {
    var a, l, u, h;
    const p = o.fields || {},
     m = s.fields || {},
     v = (a = p.value) === null || a === void 0 ? void 0 : a.arrayValue,
     w = (l = m.value) === null || l === void 0 ? void 0 : l.arrayValue,
     C = ge(
      ((u = v == null ? void 0 : v.values) === null || u === void 0 ? void 0 : u.length) || 0,
      ((h = w == null ? void 0 : w.values) === null || h === void 0 ? void 0 : h.length) || 0
     );
    return C !== 0 ? C : L0(v, w);
   })(t.mapValue, e.mapValue);
  case 11:
   return (function (o, s) {
    if (o === Ku.mapValue && s === Ku.mapValue) return 0;
    if (o === Ku.mapValue) return 1;
    if (s === Ku.mapValue) return -1;
    const a = o.fields || {},
     l = Object.keys(a),
     u = s.fields || {},
     h = Object.keys(u);
    l.sort(), h.sort();
    for (let p = 0; p < l.length && p < h.length; ++p) {
     const m = ge(l[p], h[p]);
     if (m !== 0) return m;
     const v = Ns(a[l[p]], u[h[p]]);
     if (v !== 0) return v;
    }
    return ge(l.length, h.length);
   })(t.mapValue, e.mapValue);
  default:
   throw ne();
 }
}
function D0(t, e) {
 if (typeof t == "string" && typeof e == "string" && t.length === e.length) return ge(t, e);
 const n = Ri(t),
  r = Ri(e),
  i = ge(n.seconds, r.seconds);
 return i !== 0 ? i : ge(n.nanos, r.nanos);
}
function L0(t, e) {
 const n = t.values || [],
  r = e.values || [];
 for (let i = 0; i < n.length && i < r.length; ++i) {
  const o = Ns(n[i], r[i]);
  if (o) return o;
 }
 return ge(n.length, r.length);
}
function xs(t) {
 return fm(t);
}
function fm(t) {
 return "nullValue" in t
  ? "null"
  : "booleanValue" in t
    ? "" + t.booleanValue
    : "integerValue" in t
      ? "" + t.integerValue
      : "doubleValue" in t
        ? "" + t.doubleValue
        : "timestampValue" in t
          ? (function (n) {
             const r = Ri(n);
             return `time(${r.seconds},${r.nanos})`;
            })(t.timestampValue)
          : "stringValue" in t
            ? t.stringValue
            : "bytesValue" in t
              ? (function (n) {
                 return yo(n).toBase64();
                })(t.bytesValue)
              : "referenceValue" in t
                ? (function (n) {
                   return j.fromName(n).toString();
                  })(t.referenceValue)
                : "geoPointValue" in t
                  ? (function (n) {
                     return `geo(${n.latitude},${n.longitude})`;
                    })(t.geoPointValue)
                  : "arrayValue" in t
                    ? (function (n) {
                       let r = "[",
                        i = !0;
                       for (const o of n.values || []) i ? (i = !1) : (r += ","), (r += fm(o));
                       return r + "]";
                      })(t.arrayValue)
                    : "mapValue" in t
                      ? (function (n) {
                         const r = Object.keys(n.fields || {}).sort();
                         let i = "{",
                          o = !0;
                         for (const s of r) o ? (o = !1) : (i += ","), (i += `${s}:${fm(n.fields[s])}`);
                         return i + "}";
                        })(t.mapValue)
                      : ne();
}
function V0(t, e) {
 return { referenceValue: `projects/${t.projectId}/databases/${t.database}/documents/${e.path.canonicalString()}` };
}
function hm(t) {
 return !!t && "integerValue" in t;
}
function Ey(t) {
 return !!t && "arrayValue" in t;
}
function U0(t) {
 return !!t && "nullValue" in t;
}
function O0(t) {
 return !!t && "doubleValue" in t && isNaN(Number(t.doubleValue));
}
function Sc(t) {
 return !!t && "mapValue" in t;
}
function iB(t) {
 var e, n;
 return (
  ((n = (((e = t == null ? void 0 : t.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) ===
   null || n === void 0
   ? void 0
   : n.stringValue) === "__vector__"
 );
}
function Ka(t) {
 if (t.geoPointValue) return { geoPointValue: Object.assign({}, t.geoPointValue) };
 if (t.timestampValue && typeof t.timestampValue == "object")
  return { timestampValue: Object.assign({}, t.timestampValue) };
 if (t.mapValue) {
  const e = { mapValue: { fields: {} } };
  return No(t.mapValue.fields, (n, r) => (e.mapValue.fields[n] = Ka(r))), e;
 }
 if (t.arrayValue) {
  const e = { arrayValue: { values: [] } };
  for (let n = 0; n < (t.arrayValue.values || []).length; ++n) e.arrayValue.values[n] = Ka(t.arrayValue.values[n]);
  return e;
 }
 return Object.assign({}, t);
}
function oB(t) {
 return (((t.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Xt {
 constructor(e) {
  this.value = e;
 }
 static empty() {
  return new Xt({ mapValue: {} });
 }
 field(e) {
  if (e.isEmpty()) return this.value;
  {
   let n = this.value;
   for (let r = 0; r < e.length - 1; ++r) if (((n = (n.mapValue.fields || {})[e.get(r)]), !Sc(n))) return null;
   return (n = (n.mapValue.fields || {})[e.lastSegment()]), n || null;
  }
 }
 set(e, n) {
  this.getFieldsMap(e.popLast())[e.lastSegment()] = Ka(n);
 }
 setAll(e) {
  let n = mt.emptyPath(),
   r = {},
   i = [];
  e.forEach((s, a) => {
   if (!n.isImmediateParentOf(a)) {
    const l = this.getFieldsMap(n);
    this.applyChanges(l, r, i), (r = {}), (i = []), (n = a.popLast());
   }
   s ? (r[a.lastSegment()] = Ka(s)) : i.push(a.lastSegment());
  });
  const o = this.getFieldsMap(n);
  this.applyChanges(o, r, i);
 }
 delete(e) {
  const n = this.field(e.popLast());
  Sc(n) && n.mapValue.fields && delete n.mapValue.fields[e.lastSegment()];
 }
 isEqual(e) {
  return ur(this.value, e.value);
 }
 getFieldsMap(e) {
  let n = this.value;
  n.mapValue.fields || (n.mapValue = { fields: {} });
  for (let r = 0; r < e.length; ++r) {
   let i = n.mapValue.fields[e.get(r)];
   (Sc(i) && i.mapValue.fields) || ((i = { mapValue: { fields: {} } }), (n.mapValue.fields[e.get(r)] = i)), (n = i);
  }
  return n.mapValue.fields;
 }
 applyChanges(e, n, r) {
  No(n, (i, o) => (e[i] = o));
  for (const i of r) delete e[i];
 }
 clone() {
  return new Xt(Ka(this.value));
 }
}
function DR(t) {
 const e = [];
 return (
  No(t.fields, (n, r) => {
   const i = new mt([n]);
   if (Sc(r)) {
    const o = DR(r.mapValue).fields;
    if (o.length === 0) e.push(i);
    else for (const s of o) e.push(i.child(s));
   } else e.push(i);
  }),
  new un(e)
 );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class kt {
 constructor(e, n, r, i, o, s, a) {
  (this.key = e),
   (this.documentType = n),
   (this.version = r),
   (this.readTime = i),
   (this.createTime = o),
   (this.data = s),
   (this.documentState = a);
 }
 static newInvalidDocument(e) {
  return new kt(e, 0, oe.min(), oe.min(), oe.min(), Xt.empty(), 0);
 }
 static newFoundDocument(e, n, r, i) {
  return new kt(e, 1, n, oe.min(), r, i, 0);
 }
 static newNoDocument(e, n) {
  return new kt(e, 2, n, oe.min(), oe.min(), Xt.empty(), 0);
 }
 static newUnknownDocument(e, n) {
  return new kt(e, 3, n, oe.min(), oe.min(), Xt.empty(), 2);
 }
 convertToFoundDocument(e, n) {
  return (
   !this.createTime.isEqual(oe.min()) || (this.documentType !== 2 && this.documentType !== 0) || (this.createTime = e),
   (this.version = e),
   (this.documentType = 1),
   (this.data = n),
   (this.documentState = 0),
   this
  );
 }
 convertToNoDocument(e) {
  return (this.version = e), (this.documentType = 2), (this.data = Xt.empty()), (this.documentState = 0), this;
 }
 convertToUnknownDocument(e) {
  return (this.version = e), (this.documentType = 3), (this.data = Xt.empty()), (this.documentState = 2), this;
 }
 setHasCommittedMutations() {
  return (this.documentState = 2), this;
 }
 setHasLocalMutations() {
  return (this.documentState = 1), (this.version = oe.min()), this;
 }
 setReadTime(e) {
  return (this.readTime = e), this;
 }
 get hasLocalMutations() {
  return this.documentState === 1;
 }
 get hasCommittedMutations() {
  return this.documentState === 2;
 }
 get hasPendingWrites() {
  return this.hasLocalMutations || this.hasCommittedMutations;
 }
 isValidDocument() {
  return this.documentType !== 0;
 }
 isFoundDocument() {
  return this.documentType === 1;
 }
 isNoDocument() {
  return this.documentType === 2;
 }
 isUnknownDocument() {
  return this.documentType === 3;
 }
 isEqual(e) {
  return (
   e instanceof kt &&
   this.key.isEqual(e.key) &&
   this.version.isEqual(e.version) &&
   this.documentType === e.documentType &&
   this.documentState === e.documentState &&
   this.data.isEqual(e.data)
  );
 }
 mutableCopy() {
  return new kt(
   this.key,
   this.documentType,
   this.version,
   this.readTime,
   this.createTime,
   this.data.clone(),
   this.documentState
  );
 }
 toString() {
  return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
 }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class vd {
 constructor(e, n) {
  (this.position = e), (this.inclusive = n);
 }
}
function F0(t, e, n) {
 let r = 0;
 for (let i = 0; i < t.position.length; i++) {
  const o = e[i],
   s = t.position[i];
  if (
   (o.field.isKeyField() ? (r = j.comparator(j.fromName(s.referenceValue), n.key)) : (r = Ns(s, n.data.field(o.field))),
   o.dir === "desc" && (r *= -1),
   r !== 0)
  )
   break;
 }
 return r;
}
function B0(t, e) {
 if (t === null) return e === null;
 if (e === null || t.inclusive !== e.inclusive || t.position.length !== e.position.length) return !1;
 for (let n = 0; n < t.position.length; n++) if (!ur(t.position[n], e.position[n])) return !1;
 return !0;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Cl {
 constructor(e, n = "asc") {
  (this.field = e), (this.dir = n);
 }
}
function sB(t, e) {
 return t.dir === e.dir && t.field.isEqual(e.field);
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class LR {}
class tt extends LR {
 constructor(e, n, r) {
  super(), (this.field = e), (this.op = n), (this.value = r);
 }
 static create(e, n, r) {
  return e.isKeyField()
   ? n === "in" || n === "not-in"
     ? this.createKeyFieldInFilter(e, n, r)
     : new lB(e, n, r)
   : n === "array-contains"
     ? new dB(e, r)
     : n === "in"
       ? new fB(e, r)
       : n === "not-in"
         ? new hB(e, r)
         : n === "array-contains-any"
           ? new pB(e, r)
           : new tt(e, n, r);
 }
 static createKeyFieldInFilter(e, n, r) {
  return n === "in" ? new uB(e, r) : new cB(e, r);
 }
 matches(e) {
  const n = e.data.field(this.field);
  return this.op === "!="
   ? n !== null && this.matchesComparison(Ns(n, this.value))
   : n !== null && vo(this.value) === vo(n) && this.matchesComparison(Ns(n, this.value));
 }
 matchesComparison(e) {
  switch (this.op) {
   case "<":
    return e < 0;
   case "<=":
    return e <= 0;
   case "==":
    return e === 0;
   case "!=":
    return e !== 0;
   case ">":
    return e > 0;
   case ">=":
    return e >= 0;
   default:
    return ne();
  }
 }
 isInequality() {
  return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
 }
 getFlattenedFilters() {
  return [this];
 }
 getFilters() {
  return [this];
 }
}
class Gn extends LR {
 constructor(e, n) {
  super(), (this.filters = e), (this.op = n), (this.ae = null);
 }
 static create(e, n) {
  return new Gn(e, n);
 }
 matches(e) {
  return VR(this)
   ? this.filters.find((n) => !n.matches(e)) === void 0
   : this.filters.find((n) => n.matches(e)) !== void 0;
 }
 getFlattenedFilters() {
  return this.ae !== null || (this.ae = this.filters.reduce((e, n) => e.concat(n.getFlattenedFilters()), [])), this.ae;
 }
 getFilters() {
  return Object.assign([], this.filters);
 }
}
function VR(t) {
 return t.op === "and";
}
function UR(t) {
 return aB(t) && VR(t);
}
function aB(t) {
 for (const e of t.filters) if (e instanceof Gn) return !1;
 return !0;
}
function pm(t) {
 if (t instanceof tt) return t.field.canonicalString() + t.op.toString() + xs(t.value);
 if (UR(t)) return t.filters.map((e) => pm(e)).join(",");
 {
  const e = t.filters.map((n) => pm(n)).join(",");
  return `${t.op}(${e})`;
 }
}
function OR(t, e) {
 return t instanceof tt
  ? (function (r, i) {
     return i instanceof tt && r.op === i.op && r.field.isEqual(i.field) && ur(r.value, i.value);
    })(t, e)
  : t instanceof Gn
    ? (function (r, i) {
       return i instanceof Gn && r.op === i.op && r.filters.length === i.filters.length
        ? r.filters.reduce((o, s, a) => o && OR(s, i.filters[a]), !0)
        : !1;
      })(t, e)
    : void ne();
}
function FR(t) {
 return t instanceof tt
  ? (function (n) {
     return `${n.field.canonicalString()} ${n.op} ${xs(n.value)}`;
    })(t)
  : t instanceof Gn
    ? (function (n) {
       return n.op.toString() + " {" + n.getFilters().map(FR).join(" ,") + "}";
      })(t)
    : "Filter";
}
class lB extends tt {
 constructor(e, n, r) {
  super(e, n, r), (this.key = j.fromName(r.referenceValue));
 }
 matches(e) {
  const n = j.comparator(e.key, this.key);
  return this.matchesComparison(n);
 }
}
class uB extends tt {
 constructor(e, n) {
  super(e, "in", n), (this.keys = BR("in", n));
 }
 matches(e) {
  return this.keys.some((n) => n.isEqual(e.key));
 }
}
class cB extends tt {
 constructor(e, n) {
  super(e, "not-in", n), (this.keys = BR("not-in", n));
 }
 matches(e) {
  return !this.keys.some((n) => n.isEqual(e.key));
 }
}
function BR(t, e) {
 var n;
 return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((r) =>
  j.fromName(r.referenceValue)
 );
}
class dB extends tt {
 constructor(e, n) {
  super(e, "array-contains", n);
 }
 matches(e) {
  const n = e.data.field(this.field);
  return Ey(n) && Al(n.arrayValue, this.value);
 }
}
class fB extends tt {
 constructor(e, n) {
  super(e, "in", n);
 }
 matches(e) {
  const n = e.data.field(this.field);
  return n !== null && Al(this.value.arrayValue, n);
 }
}
class hB extends tt {
 constructor(e, n) {
  super(e, "not-in", n);
 }
 matches(e) {
  if (Al(this.value.arrayValue, { nullValue: "NULL_VALUE" })) return !1;
  const n = e.data.field(this.field);
  return n !== null && !Al(this.value.arrayValue, n);
 }
}
class pB extends tt {
 constructor(e, n) {
  super(e, "array-contains-any", n);
 }
 matches(e) {
  const n = e.data.field(this.field);
  return !(!Ey(n) || !n.arrayValue.values) && n.arrayValue.values.some((r) => Al(this.value.arrayValue, r));
 }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class mB {
 constructor(e, n = null, r = [], i = [], o = null, s = null, a = null) {
  (this.path = e),
   (this.collectionGroup = n),
   (this.orderBy = r),
   (this.filters = i),
   (this.limit = o),
   (this.startAt = s),
   (this.endAt = a),
   (this.ue = null);
 }
}
function $0(t, e = null, n = [], r = [], i = null, o = null, s = null) {
 return new mB(t, e, n, r, i, o, s);
}
function Ty(t) {
 const e = re(t);
 if (e.ue === null) {
  let n = e.path.canonicalString();
  e.collectionGroup !== null && (n += "|cg:" + e.collectionGroup),
   (n += "|f:"),
   (n += e.filters.map((r) => pm(r)).join(",")),
   (n += "|ob:"),
   (n += e.orderBy
    .map((r) =>
     (function (o) {
      return o.field.canonicalString() + o.dir;
     })(r)
    )
    .join(",")),
   uf(e.limit) || ((n += "|l:"), (n += e.limit)),
   e.startAt &&
    ((n += "|lb:"), (n += e.startAt.inclusive ? "b:" : "a:"), (n += e.startAt.position.map((r) => xs(r)).join(","))),
   e.endAt &&
    ((n += "|ub:"), (n += e.endAt.inclusive ? "a:" : "b:"), (n += e.endAt.position.map((r) => xs(r)).join(","))),
   (e.ue = n);
 }
 return e.ue;
}
function Iy(t, e) {
 if (t.limit !== e.limit || t.orderBy.length !== e.orderBy.length) return !1;
 for (let n = 0; n < t.orderBy.length; n++) if (!sB(t.orderBy[n], e.orderBy[n])) return !1;
 if (t.filters.length !== e.filters.length) return !1;
 for (let n = 0; n < t.filters.length; n++) if (!OR(t.filters[n], e.filters[n])) return !1;
 return (
  t.collectionGroup === e.collectionGroup &&
  !!t.path.isEqual(e.path) &&
  !!B0(t.startAt, e.startAt) &&
  B0(t.endAt, e.endAt)
 );
}
function mm(t) {
 return j.isDocumentKey(t.path) && t.collectionGroup === null && t.filters.length === 0;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ws {
 constructor(e, n = null, r = [], i = [], o = null, s = "F", a = null, l = null) {
  (this.path = e),
   (this.collectionGroup = n),
   (this.explicitOrderBy = r),
   (this.filters = i),
   (this.limit = o),
   (this.limitType = s),
   (this.startAt = a),
   (this.endAt = l),
   (this.ce = null),
   (this.le = null),
   (this.he = null),
   this.startAt,
   this.endAt;
 }
}
function gB(t, e, n, r, i, o, s, a) {
 return new Ws(t, e, n, r, i, o, s, a);
}
function cf(t) {
 return new Ws(t);
}
function H0(t) {
 return (
  t.filters.length === 0 &&
  t.limit === null &&
  t.startAt == null &&
  t.endAt == null &&
  (t.explicitOrderBy.length === 0 || (t.explicitOrderBy.length === 1 && t.explicitOrderBy[0].field.isKeyField()))
 );
}
function $R(t) {
 return t.collectionGroup !== null;
}
function Ja(t) {
 const e = re(t);
 if (e.ce === null) {
  e.ce = [];
  const n = new Set();
  for (const o of e.explicitOrderBy) e.ce.push(o), n.add(o.field.canonicalString());
  const r = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
  (function (s) {
   let a = new yt(mt.comparator);
   return (
    s.filters.forEach((l) => {
     l.getFlattenedFilters().forEach((u) => {
      u.isInequality() && (a = a.add(u.field));
     });
    }),
    a
   );
  })(e).forEach((o) => {
   n.has(o.canonicalString()) || o.isKeyField() || e.ce.push(new Cl(o, r));
  }),
   n.has(mt.keyField().canonicalString()) || e.ce.push(new Cl(mt.keyField(), r));
 }
 return e.ce;
}
function sr(t) {
 const e = re(t);
 return e.le || (e.le = HR(e, Ja(t))), e.le;
}
function yB(t) {
 const e = re(t);
 return e.he || (e.he = HR(e, t.explicitOrderBy)), e.he;
}
function HR(t, e) {
 if (t.limitType === "F") return $0(t.path, t.collectionGroup, e, t.filters, t.limit, t.startAt, t.endAt);
 {
  e = e.map((i) => {
   const o = i.dir === "desc" ? "asc" : "desc";
   return new Cl(i.field, o);
  });
  const n = t.endAt ? new vd(t.endAt.position, t.endAt.inclusive) : null,
   r = t.startAt ? new vd(t.startAt.position, t.startAt.inclusive) : null;
  return $0(t.path, t.collectionGroup, e, t.filters, t.limit, n, r);
 }
}
function gm(t, e) {
 const n = t.filters.concat([e]);
 return new Ws(t.path, t.collectionGroup, t.explicitOrderBy.slice(), n, t.limit, t.limitType, t.startAt, t.endAt);
}
function _d(t, e, n) {
 return new Ws(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), e, n, t.startAt, t.endAt);
}
function df(t, e) {
 return Iy(sr(t), sr(e)) && t.limitType === e.limitType;
}
function qR(t) {
 return `${Ty(sr(t))}|lt:${t.limitType}`;
}
function Ho(t) {
 return `Query(target=${(function (n) {
  let r = n.path.canonicalString();
  return (
   n.collectionGroup !== null && (r += " collectionGroup=" + n.collectionGroup),
   n.filters.length > 0 && (r += `, filters: [${n.filters.map((i) => FR(i)).join(", ")}]`),
   uf(n.limit) || (r += ", limit: " + n.limit),
   n.orderBy.length > 0 &&
    (r += `, orderBy: [${n.orderBy
     .map((i) =>
      (function (s) {
       return `${s.field.canonicalString()} (${s.dir})`;
      })(i)
     )
     .join(", ")}]`),
   n.startAt &&
    ((r += ", startAt: "),
    (r += n.startAt.inclusive ? "b:" : "a:"),
    (r += n.startAt.position.map((i) => xs(i)).join(","))),
   n.endAt &&
    ((r += ", endAt: "), (r += n.endAt.inclusive ? "a:" : "b:"), (r += n.endAt.position.map((i) => xs(i)).join(","))),
   `Target(${r})`
  );
 })(sr(t))}; limitType=${t.limitType})`;
}
function ff(t, e) {
 return (
  e.isFoundDocument() &&
  (function (r, i) {
   const o = i.key.path;
   return r.collectionGroup !== null
    ? i.key.hasCollectionId(r.collectionGroup) && r.path.isPrefixOf(o)
    : j.isDocumentKey(r.path)
      ? r.path.isEqual(o)
      : r.path.isImmediateParentOf(o);
  })(t, e) &&
  (function (r, i) {
   for (const o of Ja(r)) if (!o.field.isKeyField() && i.data.field(o.field) === null) return !1;
   return !0;
  })(t, e) &&
  (function (r, i) {
   for (const o of r.filters) if (!o.matches(i)) return !1;
   return !0;
  })(t, e) &&
  (function (r, i) {
   return !(
    (r.startAt &&
     !(function (s, a, l) {
      const u = F0(s, a, l);
      return s.inclusive ? u <= 0 : u < 0;
     })(r.startAt, Ja(r), i)) ||
    (r.endAt &&
     !(function (s, a, l) {
      const u = F0(s, a, l);
      return s.inclusive ? u >= 0 : u > 0;
     })(r.endAt, Ja(r), i))
   );
  })(t, e)
 );
}
function vB(t) {
 return t.collectionGroup || (t.path.length % 2 == 1 ? t.path.lastSegment() : t.path.get(t.path.length - 2));
}
function GR(t) {
 return (e, n) => {
  let r = !1;
  for (const i of Ja(t)) {
   const o = _B(i, e, n);
   if (o !== 0) return o;
   r = r || i.field.isKeyField();
  }
  return 0;
 };
}
function _B(t, e, n) {
 const r = t.field.isKeyField()
  ? j.comparator(e.key, n.key)
  : (function (o, s, a) {
     const l = s.data.field(o),
      u = a.data.field(o);
     return l !== null && u !== null ? Ns(l, u) : ne();
    })(t.field, e, n);
 switch (t.dir) {
  case "asc":
   return r;
  case "desc":
   return -1 * r;
  default:
   return ne();
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ks {
 constructor(e, n) {
  (this.mapKeyFn = e), (this.equalsFn = n), (this.inner = {}), (this.innerSize = 0);
 }
 get(e) {
  const n = this.mapKeyFn(e),
   r = this.inner[n];
  if (r !== void 0) {
   for (const [i, o] of r) if (this.equalsFn(i, e)) return o;
  }
 }
 has(e) {
  return this.get(e) !== void 0;
 }
 set(e, n) {
  const r = this.mapKeyFn(e),
   i = this.inner[r];
  if (i === void 0) return (this.inner[r] = [[e, n]]), void this.innerSize++;
  for (let o = 0; o < i.length; o++) if (this.equalsFn(i[o][0], e)) return void (i[o] = [e, n]);
  i.push([e, n]), this.innerSize++;
 }
 delete(e) {
  const n = this.mapKeyFn(e),
   r = this.inner[n];
  if (r === void 0) return !1;
  for (let i = 0; i < r.length; i++)
   if (this.equalsFn(r[i][0], e)) return r.length === 1 ? delete this.inner[n] : r.splice(i, 1), this.innerSize--, !0;
  return !1;
 }
 forEach(e) {
  No(this.inner, (n, r) => {
   for (const [i, o] of r) e(i, o);
  });
 }
 isEmpty() {
  return xR(this.inner);
 }
 size() {
  return this.innerSize;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const wB = new Be(j.comparator);
function Mr() {
 return wB;
}
const zR = new Be(j.comparator);
function Ma(...t) {
 let e = zR;
 for (const n of t) e = e.insert(n.key, n);
 return e;
}
function WR(t) {
 let e = zR;
 return t.forEach((n, r) => (e = e.insert(n, r.overlayedDocument))), e;
}
function eo() {
 return Ya();
}
function KR() {
 return Ya();
}
function Ya() {
 return new Ks(
  (t) => t.toString(),
  (t, e) => t.isEqual(e)
 );
}
const EB = new Be(j.comparator),
 TB = new yt(j.comparator);
function ce(...t) {
 let e = TB;
 for (const n of t) e = e.add(n);
 return e;
}
const IB = new yt(ge);
function SB() {
 return IB;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Sy(t, e) {
 if (t.useProto3Json) {
  if (isNaN(e)) return { doubleValue: "NaN" };
  if (e === 1 / 0) return { doubleValue: "Infinity" };
  if (e === -1 / 0) return { doubleValue: "-Infinity" };
 }
 return { doubleValue: yd(e) ? "-0" : e };
}
function JR(t) {
 return { integerValue: "" + t };
}
function YR(t, e) {
 return eB(e) ? JR(e) : Sy(t, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hf {
 constructor() {
  this._ = void 0;
 }
}
function AB(t, e, n) {
 return t instanceof Rl
  ? (function (i, o) {
     const s = {
      fields: {
       __type__: { stringValue: "server_timestamp" },
       __local_write_time__: { timestampValue: { seconds: i.seconds, nanos: i.nanoseconds } },
      },
     };
     return o && _y(o) && (o = wy(o)), o && (s.fields.__previous_value__ = o), { mapValue: s };
    })(n, e)
  : t instanceof Pl
    ? XR(t, e)
    : t instanceof kl
      ? jR(t, e)
      : (function (i, o) {
         const s = QR(i, o),
          a = q0(s) + q0(i.Pe);
         return hm(s) && hm(i.Pe) ? JR(a) : Sy(i.serializer, a);
        })(t, e);
}
function CB(t, e, n) {
 return t instanceof Pl ? XR(t, e) : t instanceof kl ? jR(t, e) : n;
}
function QR(t, e) {
 return t instanceof bl
  ? (function (r) {
     return (
      hm(r) ||
      (function (o) {
       return !!o && "doubleValue" in o;
      })(r)
     );
    })(e)
    ? e
    : { integerValue: 0 }
  : null;
}
class Rl extends hf {}
class Pl extends hf {
 constructor(e) {
  super(), (this.elements = e);
 }
}
function XR(t, e) {
 const n = ZR(e);
 for (const r of t.elements) n.some((i) => ur(i, r)) || n.push(r);
 return { arrayValue: { values: n } };
}
class kl extends hf {
 constructor(e) {
  super(), (this.elements = e);
 }
}
function jR(t, e) {
 let n = ZR(e);
 for (const r of t.elements) n = n.filter((i) => !ur(i, r));
 return { arrayValue: { values: n } };
}
class bl extends hf {
 constructor(e, n) {
  super(), (this.serializer = e), (this.Pe = n);
 }
}
function q0(t) {
 return Je(t.integerValue || t.doubleValue);
}
function ZR(t) {
 return Ey(t) && t.arrayValue.values ? t.arrayValue.values.slice() : [];
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class eP {
 constructor(e, n) {
  (this.field = e), (this.transform = n);
 }
}
function RB(t, e) {
 return (
  t.field.isEqual(e.field) &&
  (function (r, i) {
   return (r instanceof Pl && i instanceof Pl) || (r instanceof kl && i instanceof kl)
    ? bs(r.elements, i.elements, ur)
    : r instanceof bl && i instanceof bl
      ? ur(r.Pe, i.Pe)
      : r instanceof Rl && i instanceof Rl;
  })(t.transform, e.transform)
 );
}
class PB {
 constructor(e, n) {
  (this.version = e), (this.transformResults = n);
 }
}
class Ht {
 constructor(e, n) {
  (this.updateTime = e), (this.exists = n);
 }
 static none() {
  return new Ht();
 }
 static exists(e) {
  return new Ht(void 0, e);
 }
 static updateTime(e) {
  return new Ht(e);
 }
 get isNone() {
  return this.updateTime === void 0 && this.exists === void 0;
 }
 isEqual(e) {
  return (
   this.exists === e.exists &&
   (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime)
  );
 }
}
function Ac(t, e) {
 return t.updateTime !== void 0
  ? e.isFoundDocument() && e.version.isEqual(t.updateTime)
  : t.exists === void 0 || t.exists === e.isFoundDocument();
}
class pf {}
function tP(t, e) {
 if (!t.hasLocalMutations || (e && e.fields.length === 0)) return null;
 if (e === null) return t.isNoDocument() ? new mf(t.key, Ht.none()) : new Xl(t.key, t.data, Ht.none());
 {
  const n = t.data,
   r = Xt.empty();
  let i = new yt(mt.comparator);
  for (let o of e.fields)
   if (!i.has(o)) {
    let s = n.field(o);
    s === null && o.length > 1 && ((o = o.popLast()), (s = n.field(o))),
     s === null ? r.delete(o) : r.set(o, s),
     (i = i.add(o));
   }
  return new Li(t.key, r, new un(i.toArray()), Ht.none());
 }
}
function kB(t, e, n) {
 t instanceof Xl
  ? (function (i, o, s) {
     const a = i.value.clone(),
      l = z0(i.fieldTransforms, o, s.transformResults);
     a.setAll(l), o.convertToFoundDocument(s.version, a).setHasCommittedMutations();
    })(t, e, n)
  : t instanceof Li
    ? (function (i, o, s) {
       if (!Ac(i.precondition, o)) return void o.convertToUnknownDocument(s.version);
       const a = z0(i.fieldTransforms, o, s.transformResults),
        l = o.data;
       l.setAll(nP(i)), l.setAll(a), o.convertToFoundDocument(s.version, l).setHasCommittedMutations();
      })(t, e, n)
    : (function (i, o, s) {
       o.convertToNoDocument(s.version).setHasCommittedMutations();
      })(0, e, n);
}
function Qa(t, e, n, r) {
 return t instanceof Xl
  ? (function (o, s, a, l) {
     if (!Ac(o.precondition, s)) return a;
     const u = o.value.clone(),
      h = W0(o.fieldTransforms, l, s);
     return u.setAll(h), s.convertToFoundDocument(s.version, u).setHasLocalMutations(), null;
    })(t, e, n, r)
  : t instanceof Li
    ? (function (o, s, a, l) {
       if (!Ac(o.precondition, s)) return a;
       const u = W0(o.fieldTransforms, l, s),
        h = s.data;
       return (
        h.setAll(nP(o)),
        h.setAll(u),
        s.convertToFoundDocument(s.version, h).setHasLocalMutations(),
        a === null ? null : a.unionWith(o.fieldMask.fields).unionWith(o.fieldTransforms.map((p) => p.field))
       );
      })(t, e, n, r)
    : (function (o, s, a) {
       return Ac(o.precondition, s) ? (s.convertToNoDocument(s.version).setHasLocalMutations(), null) : a;
      })(t, e, n);
}
function bB(t, e) {
 let n = null;
 for (const r of t.fieldTransforms) {
  const i = e.data.field(r.field),
   o = QR(r.transform, i || null);
  o != null && (n === null && (n = Xt.empty()), n.set(r.field, o));
 }
 return n || null;
}
function G0(t, e) {
 return (
  t.type === e.type &&
  !!t.key.isEqual(e.key) &&
  !!t.precondition.isEqual(e.precondition) &&
  !!(function (r, i) {
   return (r === void 0 && i === void 0) || (!(!r || !i) && bs(r, i, (o, s) => RB(o, s)));
  })(t.fieldTransforms, e.fieldTransforms) &&
  (t.type === 0
   ? t.value.isEqual(e.value)
   : t.type !== 1 || (t.data.isEqual(e.data) && t.fieldMask.isEqual(e.fieldMask)))
 );
}
class Xl extends pf {
 constructor(e, n, r, i = []) {
  super(), (this.key = e), (this.value = n), (this.precondition = r), (this.fieldTransforms = i), (this.type = 0);
 }
 getFieldMask() {
  return null;
 }
}
class Li extends pf {
 constructor(e, n, r, i, o = []) {
  super(),
   (this.key = e),
   (this.data = n),
   (this.fieldMask = r),
   (this.precondition = i),
   (this.fieldTransforms = o),
   (this.type = 1);
 }
 getFieldMask() {
  return this.fieldMask;
 }
}
function nP(t) {
 const e = new Map();
 return (
  t.fieldMask.fields.forEach((n) => {
   if (!n.isEmpty()) {
    const r = t.data.field(n);
    e.set(n, r);
   }
  }),
  e
 );
}
function z0(t, e, n) {
 const r = new Map();
 we(t.length === n.length);
 for (let i = 0; i < n.length; i++) {
  const o = t[i],
   s = o.transform,
   a = e.data.field(o.field);
  r.set(o.field, CB(s, a, n[i]));
 }
 return r;
}
function W0(t, e, n) {
 const r = new Map();
 for (const i of t) {
  const o = i.transform,
   s = n.data.field(i.field);
  r.set(i.field, AB(o, s, e));
 }
 return r;
}
class mf extends pf {
 constructor(e, n) {
  super(), (this.key = e), (this.precondition = n), (this.type = 2), (this.fieldTransforms = []);
 }
 getFieldMask() {
  return null;
 }
}
class NB extends pf {
 constructor(e, n) {
  super(), (this.key = e), (this.precondition = n), (this.type = 3), (this.fieldTransforms = []);
 }
 getFieldMask() {
  return null;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class xB {
 constructor(e, n, r, i) {
  (this.batchId = e), (this.localWriteTime = n), (this.baseMutations = r), (this.mutations = i);
 }
 applyToRemoteDocument(e, n) {
  const r = n.mutationResults;
  for (let i = 0; i < this.mutations.length; i++) {
   const o = this.mutations[i];
   o.key.isEqual(e.key) && kB(o, e, r[i]);
  }
 }
 applyToLocalView(e, n) {
  for (const r of this.baseMutations) r.key.isEqual(e.key) && (n = Qa(r, e, n, this.localWriteTime));
  for (const r of this.mutations) r.key.isEqual(e.key) && (n = Qa(r, e, n, this.localWriteTime));
  return n;
 }
 applyToLocalDocumentSet(e, n) {
  const r = KR();
  return (
   this.mutations.forEach((i) => {
    const o = e.get(i.key),
     s = o.overlayedDocument;
    let a = this.applyToLocalView(s, o.mutatedFields);
    a = n.has(i.key) ? null : a;
    const l = tP(s, a);
    l !== null && r.set(i.key, l), s.isValidDocument() || s.convertToNoDocument(oe.min());
   }),
   r
  );
 }
 keys() {
  return this.mutations.reduce((e, n) => e.add(n.key), ce());
 }
 isEqual(e) {
  return (
   this.batchId === e.batchId &&
   bs(this.mutations, e.mutations, (n, r) => G0(n, r)) &&
   bs(this.baseMutations, e.baseMutations, (n, r) => G0(n, r))
  );
 }
}
class Ay {
 constructor(e, n, r, i) {
  (this.batch = e), (this.commitVersion = n), (this.mutationResults = r), (this.docVersions = i);
 }
 static from(e, n, r) {
  we(e.mutations.length === r.length);
  let i = (function () {
   return EB;
  })();
  const o = e.mutations;
  for (let s = 0; s < o.length; s++) i = i.insert(o[s].key, r[s].version);
  return new Ay(e, n, r, i);
 }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class MB {
 constructor(e, n) {
  (this.largestBatchId = e), (this.mutation = n);
 }
 getKey() {
  return this.mutation.key;
 }
 isEqual(e) {
  return e !== null && this.mutation === e.mutation;
 }
 toString() {
  return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
 }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class DB {
 constructor(e, n, r) {
  (this.alias = e), (this.aggregateType = n), (this.fieldPath = r);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class LB {
 constructor(e, n) {
  (this.count = e), (this.unchangedNames = n);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Ze, fe;
function VB(t) {
 switch (t) {
  default:
   return ne();
  case B.CANCELLED:
  case B.UNKNOWN:
  case B.DEADLINE_EXCEEDED:
  case B.RESOURCE_EXHAUSTED:
  case B.INTERNAL:
  case B.UNAVAILABLE:
  case B.UNAUTHENTICATED:
   return !1;
  case B.INVALID_ARGUMENT:
  case B.NOT_FOUND:
  case B.ALREADY_EXISTS:
  case B.PERMISSION_DENIED:
  case B.FAILED_PRECONDITION:
  case B.ABORTED:
  case B.OUT_OF_RANGE:
  case B.UNIMPLEMENTED:
  case B.DATA_LOSS:
   return !0;
 }
}
function rP(t) {
 if (t === void 0) return xr("GRPC error has no .code"), B.UNKNOWN;
 switch (t) {
  case Ze.OK:
   return B.OK;
  case Ze.CANCELLED:
   return B.CANCELLED;
  case Ze.UNKNOWN:
   return B.UNKNOWN;
  case Ze.DEADLINE_EXCEEDED:
   return B.DEADLINE_EXCEEDED;
  case Ze.RESOURCE_EXHAUSTED:
   return B.RESOURCE_EXHAUSTED;
  case Ze.INTERNAL:
   return B.INTERNAL;
  case Ze.UNAVAILABLE:
   return B.UNAVAILABLE;
  case Ze.UNAUTHENTICATED:
   return B.UNAUTHENTICATED;
  case Ze.INVALID_ARGUMENT:
   return B.INVALID_ARGUMENT;
  case Ze.NOT_FOUND:
   return B.NOT_FOUND;
  case Ze.ALREADY_EXISTS:
   return B.ALREADY_EXISTS;
  case Ze.PERMISSION_DENIED:
   return B.PERMISSION_DENIED;
  case Ze.FAILED_PRECONDITION:
   return B.FAILED_PRECONDITION;
  case Ze.ABORTED:
   return B.ABORTED;
  case Ze.OUT_OF_RANGE:
   return B.OUT_OF_RANGE;
  case Ze.UNIMPLEMENTED:
   return B.UNIMPLEMENTED;
  case Ze.DATA_LOSS:
   return B.DATA_LOSS;
  default:
   return ne();
 }
}
((fe = Ze || (Ze = {}))[(fe.OK = 0)] = "OK"),
 (fe[(fe.CANCELLED = 1)] = "CANCELLED"),
 (fe[(fe.UNKNOWN = 2)] = "UNKNOWN"),
 (fe[(fe.INVALID_ARGUMENT = 3)] = "INVALID_ARGUMENT"),
 (fe[(fe.DEADLINE_EXCEEDED = 4)] = "DEADLINE_EXCEEDED"),
 (fe[(fe.NOT_FOUND = 5)] = "NOT_FOUND"),
 (fe[(fe.ALREADY_EXISTS = 6)] = "ALREADY_EXISTS"),
 (fe[(fe.PERMISSION_DENIED = 7)] = "PERMISSION_DENIED"),
 (fe[(fe.UNAUTHENTICATED = 16)] = "UNAUTHENTICATED"),
 (fe[(fe.RESOURCE_EXHAUSTED = 8)] = "RESOURCE_EXHAUSTED"),
 (fe[(fe.FAILED_PRECONDITION = 9)] = "FAILED_PRECONDITION"),
 (fe[(fe.ABORTED = 10)] = "ABORTED"),
 (fe[(fe.OUT_OF_RANGE = 11)] = "OUT_OF_RANGE"),
 (fe[(fe.UNIMPLEMENTED = 12)] = "UNIMPLEMENTED"),
 (fe[(fe.INTERNAL = 13)] = "INTERNAL"),
 (fe[(fe.UNAVAILABLE = 14)] = "UNAVAILABLE"),
 (fe[(fe.DATA_LOSS = 15)] = "DATA_LOSS");
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function UB() {
 return new TextEncoder();
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const OB = new oo([4294967295, 4294967295], 0);
function K0(t) {
 const e = UB().encode(t),
  n = new SR();
 return n.update(e), new Uint8Array(n.digest());
}
function J0(t) {
 const e = new DataView(t.buffer),
  n = e.getUint32(0, !0),
  r = e.getUint32(4, !0),
  i = e.getUint32(8, !0),
  o = e.getUint32(12, !0);
 return [new oo([n, r], 0), new oo([i, o], 0)];
}
class Cy {
 constructor(e, n, r) {
  if (((this.bitmap = e), (this.padding = n), (this.hashCount = r), n < 0 || n >= 8))
   throw new Da(`Invalid padding: ${n}`);
  if (r < 0) throw new Da(`Invalid hash count: ${r}`);
  if (e.length > 0 && this.hashCount === 0) throw new Da(`Invalid hash count: ${r}`);
  if (e.length === 0 && n !== 0) throw new Da(`Invalid padding when bitmap length is 0: ${n}`);
  (this.Ie = 8 * e.length - n), (this.Te = oo.fromNumber(this.Ie));
 }
 Ee(e, n, r) {
  let i = e.add(n.multiply(oo.fromNumber(r)));
  return i.compare(OB) === 1 && (i = new oo([i.getBits(0), i.getBits(1)], 0)), i.modulo(this.Te).toNumber();
 }
 de(e) {
  return (this.bitmap[Math.floor(e / 8)] & (1 << e % 8)) != 0;
 }
 mightContain(e) {
  if (this.Ie === 0) return !1;
  const n = K0(e),
   [r, i] = J0(n);
  for (let o = 0; o < this.hashCount; o++) {
   const s = this.Ee(r, i, o);
   if (!this.de(s)) return !1;
  }
  return !0;
 }
 static create(e, n, r) {
  const i = e % 8 == 0 ? 0 : 8 - (e % 8),
   o = new Uint8Array(Math.ceil(e / 8)),
   s = new Cy(o, i, n);
  return r.forEach((a) => s.insert(a)), s;
 }
 insert(e) {
  if (this.Ie === 0) return;
  const n = K0(e),
   [r, i] = J0(n);
  for (let o = 0; o < this.hashCount; o++) {
   const s = this.Ee(r, i, o);
   this.Ae(s);
  }
 }
 Ae(e) {
  const n = Math.floor(e / 8),
   r = e % 8;
  this.bitmap[n] |= 1 << r;
 }
}
class Da extends Error {
 constructor() {
  super(...arguments), (this.name = "BloomFilterError");
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class gf {
 constructor(e, n, r, i, o) {
  (this.snapshotVersion = e),
   (this.targetChanges = n),
   (this.targetMismatches = r),
   (this.documentUpdates = i),
   (this.resolvedLimboDocuments = o);
 }
 static createSynthesizedRemoteEventForCurrentChange(e, n, r) {
  const i = new Map();
  return (
   i.set(e, jl.createSynthesizedTargetChangeForCurrentChange(e, n, r)), new gf(oe.min(), i, new Be(ge), Mr(), ce())
  );
 }
}
class jl {
 constructor(e, n, r, i, o) {
  (this.resumeToken = e),
   (this.current = n),
   (this.addedDocuments = r),
   (this.modifiedDocuments = i),
   (this.removedDocuments = o);
 }
 static createSynthesizedTargetChangeForCurrentChange(e, n, r) {
  return new jl(r, n, ce(), ce(), ce());
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Cc {
 constructor(e, n, r, i) {
  (this.Re = e), (this.removedTargetIds = n), (this.key = r), (this.Ve = i);
 }
}
class iP {
 constructor(e, n) {
  (this.targetId = e), (this.me = n);
 }
}
class oP {
 constructor(e, n, r = _t.EMPTY_BYTE_STRING, i = null) {
  (this.state = e), (this.targetIds = n), (this.resumeToken = r), (this.cause = i);
 }
}
class Y0 {
 constructor() {
  (this.fe = 0), (this.ge = X0()), (this.pe = _t.EMPTY_BYTE_STRING), (this.ye = !1), (this.we = !0);
 }
 get current() {
  return this.ye;
 }
 get resumeToken() {
  return this.pe;
 }
 get Se() {
  return this.fe !== 0;
 }
 get be() {
  return this.we;
 }
 De(e) {
  e.approximateByteSize() > 0 && ((this.we = !0), (this.pe = e));
 }
 ve() {
  let e = ce(),
   n = ce(),
   r = ce();
  return (
   this.ge.forEach((i, o) => {
    switch (o) {
     case 0:
      e = e.add(i);
      break;
     case 2:
      n = n.add(i);
      break;
     case 1:
      r = r.add(i);
      break;
     default:
      ne();
    }
   }),
   new jl(this.pe, this.ye, e, n, r)
  );
 }
 Ce() {
  (this.we = !1), (this.ge = X0());
 }
 Fe(e, n) {
  (this.we = !0), (this.ge = this.ge.insert(e, n));
 }
 Me(e) {
  (this.we = !0), (this.ge = this.ge.remove(e));
 }
 xe() {
  this.fe += 1;
 }
 Oe() {
  (this.fe -= 1), we(this.fe >= 0);
 }
 Ne() {
  (this.we = !0), (this.ye = !0);
 }
}
class FB {
 constructor(e) {
  (this.Le = e), (this.Be = new Map()), (this.ke = Mr()), (this.qe = Q0()), (this.Qe = new Be(ge));
 }
 Ke(e) {
  for (const n of e.Re) e.Ve && e.Ve.isFoundDocument() ? this.$e(n, e.Ve) : this.Ue(n, e.key, e.Ve);
  for (const n of e.removedTargetIds) this.Ue(n, e.key, e.Ve);
 }
 We(e) {
  this.forEachTarget(e, (n) => {
   const r = this.Ge(n);
   switch (e.state) {
    case 0:
     this.ze(n) && r.De(e.resumeToken);
     break;
    case 1:
     r.Oe(), r.Se || r.Ce(), r.De(e.resumeToken);
     break;
    case 2:
     r.Oe(), r.Se || this.removeTarget(n);
     break;
    case 3:
     this.ze(n) && (r.Ne(), r.De(e.resumeToken));
     break;
    case 4:
     this.ze(n) && (this.je(n), r.De(e.resumeToken));
     break;
    default:
     ne();
   }
  });
 }
 forEachTarget(e, n) {
  e.targetIds.length > 0
   ? e.targetIds.forEach(n)
   : this.Be.forEach((r, i) => {
      this.ze(i) && n(i);
     });
 }
 He(e) {
  const n = e.targetId,
   r = e.me.count,
   i = this.Je(n);
  if (i) {
   const o = i.target;
   if (mm(o))
    if (r === 0) {
     const s = new j(o.path);
     this.Ue(n, s, kt.newNoDocument(s, oe.min()));
    } else we(r === 1);
   else {
    const s = this.Ye(n);
    if (s !== r) {
     const a = this.Ze(e),
      l = a ? this.Xe(a, e, s) : 1;
     if (l !== 0) {
      this.je(n);
      const u = l === 2 ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch";
      this.Qe = this.Qe.insert(n, u);
     }
    }
   }
  }
 }
 Ze(e) {
  const n = e.me.unchangedNames;
  if (!n || !n.bits) return null;
  const {
   bits: { bitmap: r = "", padding: i = 0 },
   hashCount: o = 0,
  } = n;
  let s, a;
  try {
   s = yo(r).toUint8Array();
  } catch (l) {
   if (l instanceof MR)
    return (
     ks(
      "Decoding the base64 bloom filter in existence filter failed (" +
       l.message +
       "); ignoring the bloom filter and falling back to full re-query."
     ),
     null
    );
   throw l;
  }
  try {
   a = new Cy(s, i, o);
  } catch (l) {
   return ks(l instanceof Da ? "BloomFilter error: " : "Applying bloom filter failed: ", l), null;
  }
  return a.Ie === 0 ? null : a;
 }
 Xe(e, n, r) {
  return n.me.count === r - this.nt(e, n.targetId) ? 0 : 2;
 }
 nt(e, n) {
  const r = this.Le.getRemoteKeysForTarget(n);
  let i = 0;
  return (
   r.forEach((o) => {
    const s = this.Le.tt(),
     a = `projects/${s.projectId}/databases/${s.database}/documents/${o.path.canonicalString()}`;
    e.mightContain(a) || (this.Ue(n, o, null), i++);
   }),
   i
  );
 }
 rt(e) {
  const n = new Map();
  this.Be.forEach((o, s) => {
   const a = this.Je(s);
   if (a) {
    if (o.current && mm(a.target)) {
     const l = new j(a.target.path);
     this.ke.get(l) !== null || this.it(s, l) || this.Ue(s, l, kt.newNoDocument(l, e));
    }
    o.be && (n.set(s, o.ve()), o.Ce());
   }
  });
  let r = ce();
  this.qe.forEach((o, s) => {
   let a = !0;
   s.forEachWhile((l) => {
    const u = this.Je(l);
    return !u || u.purpose === "TargetPurposeLimboResolution" || ((a = !1), !1);
   }),
    a && (r = r.add(o));
  }),
   this.ke.forEach((o, s) => s.setReadTime(e));
  const i = new gf(e, n, this.Qe, this.ke, r);
  return (this.ke = Mr()), (this.qe = Q0()), (this.Qe = new Be(ge)), i;
 }
 $e(e, n) {
  if (!this.ze(e)) return;
  const r = this.it(e, n.key) ? 2 : 0;
  this.Ge(e).Fe(n.key, r),
   (this.ke = this.ke.insert(n.key, n)),
   (this.qe = this.qe.insert(n.key, this.st(n.key).add(e)));
 }
 Ue(e, n, r) {
  if (!this.ze(e)) return;
  const i = this.Ge(e);
  this.it(e, n) ? i.Fe(n, 1) : i.Me(n),
   (this.qe = this.qe.insert(n, this.st(n).delete(e))),
   r && (this.ke = this.ke.insert(n, r));
 }
 removeTarget(e) {
  this.Be.delete(e);
 }
 Ye(e) {
  const n = this.Ge(e).ve();
  return this.Le.getRemoteKeysForTarget(e).size + n.addedDocuments.size - n.removedDocuments.size;
 }
 xe(e) {
  this.Ge(e).xe();
 }
 Ge(e) {
  let n = this.Be.get(e);
  return n || ((n = new Y0()), this.Be.set(e, n)), n;
 }
 st(e) {
  let n = this.qe.get(e);
  return n || ((n = new yt(ge)), (this.qe = this.qe.insert(e, n))), n;
 }
 ze(e) {
  const n = this.Je(e) !== null;
  return n || Q("WatchChangeAggregator", "Detected inactive target", e), n;
 }
 Je(e) {
  const n = this.Be.get(e);
  return n && n.Se ? null : this.Le.ot(e);
 }
 je(e) {
  this.Be.set(e, new Y0()),
   this.Le.getRemoteKeysForTarget(e).forEach((n) => {
    this.Ue(e, n, null);
   });
 }
 it(e, n) {
  return this.Le.getRemoteKeysForTarget(e).has(n);
 }
}
function Q0() {
 return new Be(j.comparator);
}
function X0() {
 return new Be(j.comparator);
}
const BB = { asc: "ASCENDING", desc: "DESCENDING" },
 $B = {
  "<": "LESS_THAN",
  "<=": "LESS_THAN_OR_EQUAL",
  ">": "GREATER_THAN",
  ">=": "GREATER_THAN_OR_EQUAL",
  "==": "EQUAL",
  "!=": "NOT_EQUAL",
  "array-contains": "ARRAY_CONTAINS",
  in: "IN",
  "not-in": "NOT_IN",
  "array-contains-any": "ARRAY_CONTAINS_ANY",
 },
 HB = { and: "AND", or: "OR" };
class qB {
 constructor(e, n) {
  (this.databaseId = e), (this.useProto3Json = n);
 }
}
function ym(t, e) {
 return t.useProto3Json || uf(e) ? e : { value: e };
}
function wd(t, e) {
 return t.useProto3Json
  ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`
  : { seconds: "" + e.seconds, nanos: e.nanoseconds };
}
function sP(t, e) {
 return t.useProto3Json ? e.toBase64() : e.toUint8Array();
}
function GB(t, e) {
 return wd(t, e.toTimestamp());
}
function ar(t) {
 return (
  we(!!t),
  oe.fromTimestamp(
   (function (n) {
    const r = Ri(n);
    return new st(r.seconds, r.nanos);
   })(t)
  )
 );
}
function Ry(t, e) {
 return vm(t, e).canonicalString();
}
function vm(t, e) {
 const n = (function (i) {
  return new Ne(["projects", i.projectId, "databases", i.database]);
 })(t).child("documents");
 return e === void 0 ? n : n.child(e);
}
function aP(t) {
 const e = Ne.fromString(t);
 return we(hP(e)), e;
}
function _m(t, e) {
 return Ry(t.databaseId, e.path);
}
function Bh(t, e) {
 const n = aP(e);
 if (n.get(1) !== t.databaseId.projectId)
  throw new J(
   B.INVALID_ARGUMENT,
   "Tried to deserialize key from different project: " + n.get(1) + " vs " + t.databaseId.projectId
  );
 if (n.get(3) !== t.databaseId.database)
  throw new J(
   B.INVALID_ARGUMENT,
   "Tried to deserialize key from different database: " + n.get(3) + " vs " + t.databaseId.database
  );
 return new j(uP(n));
}
function lP(t, e) {
 return Ry(t.databaseId, e);
}
function zB(t) {
 const e = aP(t);
 return e.length === 4 ? Ne.emptyPath() : uP(e);
}
function wm(t) {
 return new Ne(["projects", t.databaseId.projectId, "databases", t.databaseId.database]).canonicalString();
}
function uP(t) {
 return we(t.length > 4 && t.get(4) === "documents"), t.popFirst(5);
}
function j0(t, e, n) {
 return { name: _m(t, e), fields: n.value.mapValue.fields };
}
function WB(t, e) {
 let n;
 if ("targetChange" in e) {
  e.targetChange;
  const r = (function (u) {
    return u === "NO_CHANGE"
     ? 0
     : u === "ADD"
       ? 1
       : u === "REMOVE"
         ? 2
         : u === "CURRENT"
           ? 3
           : u === "RESET"
             ? 4
             : ne();
   })(e.targetChange.targetChangeType || "NO_CHANGE"),
   i = e.targetChange.targetIds || [],
   o = (function (u, h) {
    return u.useProto3Json
     ? (we(h === void 0 || typeof h == "string"), _t.fromBase64String(h || ""))
     : (we(h === void 0 || h instanceof Buffer || h instanceof Uint8Array), _t.fromUint8Array(h || new Uint8Array()));
   })(t, e.targetChange.resumeToken),
   s = e.targetChange.cause,
   a =
    s &&
    (function (u) {
     const h = u.code === void 0 ? B.UNKNOWN : rP(u.code);
     return new J(h, u.message || "");
    })(s);
  n = new oP(r, i, o, a || null);
 } else if ("documentChange" in e) {
  e.documentChange;
  const r = e.documentChange;
  r.document, r.document.name, r.document.updateTime;
  const i = Bh(t, r.document.name),
   o = ar(r.document.updateTime),
   s = r.document.createTime ? ar(r.document.createTime) : oe.min(),
   a = new Xt({ mapValue: { fields: r.document.fields } }),
   l = kt.newFoundDocument(i, o, s, a),
   u = r.targetIds || [],
   h = r.removedTargetIds || [];
  n = new Cc(u, h, l.key, l);
 } else if ("documentDelete" in e) {
  e.documentDelete;
  const r = e.documentDelete;
  r.document;
  const i = Bh(t, r.document),
   o = r.readTime ? ar(r.readTime) : oe.min(),
   s = kt.newNoDocument(i, o),
   a = r.removedTargetIds || [];
  n = new Cc([], a, s.key, s);
 } else if ("documentRemove" in e) {
  e.documentRemove;
  const r = e.documentRemove;
  r.document;
  const i = Bh(t, r.document),
   o = r.removedTargetIds || [];
  n = new Cc([], o, i, null);
 } else {
  if (!("filter" in e)) return ne();
  {
   e.filter;
   const r = e.filter;
   r.targetId;
   const { count: i = 0, unchangedNames: o } = r,
    s = new LB(i, o),
    a = r.targetId;
   n = new iP(a, s);
  }
 }
 return n;
}
function KB(t, e) {
 let n;
 if (e instanceof Xl) n = { update: j0(t, e.key, e.value) };
 else if (e instanceof mf) n = { delete: _m(t, e.key) };
 else if (e instanceof Li) n = { update: j0(t, e.key, e.data), updateMask: n4(e.fieldMask) };
 else {
  if (!(e instanceof NB)) return ne();
  n = { verify: _m(t, e.key) };
 }
 return (
  e.fieldTransforms.length > 0 &&
   (n.updateTransforms = e.fieldTransforms.map((r) =>
    (function (o, s) {
     const a = s.transform;
     if (a instanceof Rl) return { fieldPath: s.field.canonicalString(), setToServerValue: "REQUEST_TIME" };
     if (a instanceof Pl)
      return { fieldPath: s.field.canonicalString(), appendMissingElements: { values: a.elements } };
     if (a instanceof kl) return { fieldPath: s.field.canonicalString(), removeAllFromArray: { values: a.elements } };
     if (a instanceof bl) return { fieldPath: s.field.canonicalString(), increment: a.Pe };
     throw ne();
    })(0, r)
   )),
  e.precondition.isNone ||
   (n.currentDocument = (function (i, o) {
    return o.updateTime !== void 0
     ? { updateTime: GB(i, o.updateTime) }
     : o.exists !== void 0
       ? { exists: o.exists }
       : ne();
   })(t, e.precondition)),
  n
 );
}
function JB(t, e) {
 return t && t.length > 0
  ? (we(e !== void 0),
    t.map((n) =>
     (function (i, o) {
      let s = i.updateTime ? ar(i.updateTime) : ar(o);
      return s.isEqual(oe.min()) && (s = ar(o)), new PB(s, i.transformResults || []);
     })(n, e)
    ))
  : [];
}
function YB(t, e) {
 return { documents: [lP(t, e.path)] };
}
function cP(t, e) {
 const n = { structuredQuery: {} },
  r = e.path;
 let i;
 e.collectionGroup !== null
  ? ((i = r), (n.structuredQuery.from = [{ collectionId: e.collectionGroup, allDescendants: !0 }]))
  : ((i = r.popLast()), (n.structuredQuery.from = [{ collectionId: r.lastSegment() }])),
  (n.parent = lP(t, i));
 const o = (function (u) {
  if (u.length !== 0) return fP(Gn.create(u, "and"));
 })(e.filters);
 o && (n.structuredQuery.where = o);
 const s = (function (u) {
  if (u.length !== 0)
   return u.map((h) =>
    (function (m) {
     return { field: ri(m.field), direction: ZB(m.dir) };
    })(h)
   );
 })(e.orderBy);
 s && (n.structuredQuery.orderBy = s);
 const a = ym(t, e.limit);
 return (
  a !== null && (n.structuredQuery.limit = a),
  e.startAt &&
   (n.structuredQuery.startAt = (function (u) {
    return { before: u.inclusive, values: u.position };
   })(e.startAt)),
  e.endAt &&
   (n.structuredQuery.endAt = (function (u) {
    return { before: !u.inclusive, values: u.position };
   })(e.endAt)),
  { _t: n, parent: i }
 );
}
function QB(t, e, n, r) {
 const { _t: i, parent: o } = cP(t, e),
  s = {},
  a = [];
 let l = 0;
 return (
  n.forEach((u) => {
   const h = "aggregate_" + l++;
   (s[h] = u.alias),
    u.aggregateType === "count"
     ? a.push({ alias: h, count: {} })
     : u.aggregateType === "avg"
       ? a.push({ alias: h, avg: { field: ri(u.fieldPath) } })
       : u.aggregateType === "sum" && a.push({ alias: h, sum: { field: ri(u.fieldPath) } });
  }),
  {
   request: { structuredAggregationQuery: { aggregations: a, structuredQuery: i.structuredQuery }, parent: i.parent },
   ut: s,
   parent: o,
  }
 );
}
function XB(t) {
 let e = zB(t.parent);
 const n = t.structuredQuery,
  r = n.from ? n.from.length : 0;
 let i = null;
 if (r > 0) {
  we(r === 1);
  const h = n.from[0];
  h.allDescendants ? (i = h.collectionId) : (e = e.child(h.collectionId));
 }
 let o = [];
 n.where &&
  (o = (function (p) {
   const m = dP(p);
   return m instanceof Gn && UR(m) ? m.getFilters() : [m];
  })(n.where));
 let s = [];
 n.orderBy &&
  (s = (function (p) {
   return p.map((m) =>
    (function (w) {
     return new Cl(
      qo(w.field),
      (function (A) {
       switch (A) {
        case "ASCENDING":
         return "asc";
        case "DESCENDING":
         return "desc";
        default:
         return;
       }
      })(w.direction)
     );
    })(m)
   );
  })(n.orderBy));
 let a = null;
 n.limit &&
  (a = (function (p) {
   let m;
   return (m = typeof p == "object" ? p.value : p), uf(m) ? null : m;
  })(n.limit));
 let l = null;
 n.startAt &&
  (l = (function (p) {
   const m = !!p.before,
    v = p.values || [];
   return new vd(v, m);
  })(n.startAt));
 let u = null;
 return (
  n.endAt &&
   (u = (function (p) {
    const m = !p.before,
     v = p.values || [];
    return new vd(v, m);
   })(n.endAt)),
  gB(e, i, s, o, a, "F", l, u)
 );
}
function jB(t, e) {
 const n = (function (i) {
  switch (i) {
   case "TargetPurposeListen":
    return null;
   case "TargetPurposeExistenceFilterMismatch":
    return "existence-filter-mismatch";
   case "TargetPurposeExistenceFilterMismatchBloom":
    return "existence-filter-mismatch-bloom";
   case "TargetPurposeLimboResolution":
    return "limbo-document";
   default:
    return ne();
  }
 })(e.purpose);
 return n == null ? null : { "goog-listen-tags": n };
}
function dP(t) {
 return t.unaryFilter !== void 0
  ? (function (n) {
     switch (n.unaryFilter.op) {
      case "IS_NAN":
       const r = qo(n.unaryFilter.field);
       return tt.create(r, "==", { doubleValue: NaN });
      case "IS_NULL":
       const i = qo(n.unaryFilter.field);
       return tt.create(i, "==", { nullValue: "NULL_VALUE" });
      case "IS_NOT_NAN":
       const o = qo(n.unaryFilter.field);
       return tt.create(o, "!=", { doubleValue: NaN });
      case "IS_NOT_NULL":
       const s = qo(n.unaryFilter.field);
       return tt.create(s, "!=", { nullValue: "NULL_VALUE" });
      default:
       return ne();
     }
    })(t)
  : t.fieldFilter !== void 0
    ? (function (n) {
       return tt.create(
        qo(n.fieldFilter.field),
        (function (i) {
         switch (i) {
          case "EQUAL":
           return "==";
          case "NOT_EQUAL":
           return "!=";
          case "GREATER_THAN":
           return ">";
          case "GREATER_THAN_OR_EQUAL":
           return ">=";
          case "LESS_THAN":
           return "<";
          case "LESS_THAN_OR_EQUAL":
           return "<=";
          case "ARRAY_CONTAINS":
           return "array-contains";
          case "IN":
           return "in";
          case "NOT_IN":
           return "not-in";
          case "ARRAY_CONTAINS_ANY":
           return "array-contains-any";
          default:
           return ne();
         }
        })(n.fieldFilter.op),
        n.fieldFilter.value
       );
      })(t)
    : t.compositeFilter !== void 0
      ? (function (n) {
         return Gn.create(
          n.compositeFilter.filters.map((r) => dP(r)),
          (function (i) {
           switch (i) {
            case "AND":
             return "and";
            case "OR":
             return "or";
            default:
             return ne();
           }
          })(n.compositeFilter.op)
         );
        })(t)
      : ne();
}
function ZB(t) {
 return BB[t];
}
function e4(t) {
 return $B[t];
}
function t4(t) {
 return HB[t];
}
function ri(t) {
 return { fieldPath: t.canonicalString() };
}
function qo(t) {
 return mt.fromServerFormat(t.fieldPath);
}
function fP(t) {
 return t instanceof tt
  ? (function (n) {
     if (n.op === "==") {
      if (O0(n.value)) return { unaryFilter: { field: ri(n.field), op: "IS_NAN" } };
      if (U0(n.value)) return { unaryFilter: { field: ri(n.field), op: "IS_NULL" } };
     } else if (n.op === "!=") {
      if (O0(n.value)) return { unaryFilter: { field: ri(n.field), op: "IS_NOT_NAN" } };
      if (U0(n.value)) return { unaryFilter: { field: ri(n.field), op: "IS_NOT_NULL" } };
     }
     return { fieldFilter: { field: ri(n.field), op: e4(n.op), value: n.value } };
    })(t)
  : t instanceof Gn
    ? (function (n) {
       const r = n.getFilters().map((i) => fP(i));
       return r.length === 1 ? r[0] : { compositeFilter: { op: t4(n.op), filters: r } };
      })(t)
    : ne();
}
function n4(t) {
 const e = [];
 return t.fields.forEach((n) => e.push(n.canonicalString())), { fieldPaths: e };
}
function hP(t) {
 return t.length >= 4 && t.get(0) === "projects" && t.get(2) === "databases";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class di {
 constructor(e, n, r, i, o = oe.min(), s = oe.min(), a = _t.EMPTY_BYTE_STRING, l = null) {
  (this.target = e),
   (this.targetId = n),
   (this.purpose = r),
   (this.sequenceNumber = i),
   (this.snapshotVersion = o),
   (this.lastLimboFreeSnapshotVersion = s),
   (this.resumeToken = a),
   (this.expectedCount = l);
 }
 withSequenceNumber(e) {
  return new di(
   this.target,
   this.targetId,
   this.purpose,
   e,
   this.snapshotVersion,
   this.lastLimboFreeSnapshotVersion,
   this.resumeToken,
   this.expectedCount
  );
 }
 withResumeToken(e, n) {
  return new di(
   this.target,
   this.targetId,
   this.purpose,
   this.sequenceNumber,
   n,
   this.lastLimboFreeSnapshotVersion,
   e,
   null
  );
 }
 withExpectedCount(e) {
  return new di(
   this.target,
   this.targetId,
   this.purpose,
   this.sequenceNumber,
   this.snapshotVersion,
   this.lastLimboFreeSnapshotVersion,
   this.resumeToken,
   e
  );
 }
 withLastLimboFreeSnapshotVersion(e) {
  return new di(
   this.target,
   this.targetId,
   this.purpose,
   this.sequenceNumber,
   this.snapshotVersion,
   e,
   this.resumeToken,
   this.expectedCount
  );
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class r4 {
 constructor(e) {
  this.ct = e;
 }
}
function i4(t) {
 const e = XB({ parent: t.parent, structuredQuery: t.structuredQuery });
 return t.limitType === "LAST" ? _d(e, e.limit, "L") : e;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class o4 {
 constructor() {
  this.un = new s4();
 }
 addToCollectionParentIndex(e, n) {
  return this.un.add(n), $.resolve();
 }
 getCollectionParents(e, n) {
  return $.resolve(this.un.getEntries(n));
 }
 addFieldIndex(e, n) {
  return $.resolve();
 }
 deleteFieldIndex(e, n) {
  return $.resolve();
 }
 deleteAllFieldIndexes(e) {
  return $.resolve();
 }
 createTargetIndexes(e, n) {
  return $.resolve();
 }
 getDocumentsMatchingTarget(e, n) {
  return $.resolve(null);
 }
 getIndexType(e, n) {
  return $.resolve(0);
 }
 getFieldIndexes(e, n) {
  return $.resolve([]);
 }
 getNextCollectionGroupToUpdate(e) {
  return $.resolve(null);
 }
 getMinOffset(e, n) {
  return $.resolve(Ci.min());
 }
 getMinOffsetFromCollectionGroup(e, n) {
  return $.resolve(Ci.min());
 }
 updateCollectionGroup(e, n, r) {
  return $.resolve();
 }
 updateIndexEntries(e, n) {
  return $.resolve();
 }
}
class s4 {
 constructor() {
  this.index = {};
 }
 add(e) {
  const n = e.lastSegment(),
   r = e.popLast(),
   i = this.index[n] || new yt(Ne.comparator),
   o = !i.has(r);
  return (this.index[n] = i.add(r)), o;
 }
 has(e) {
  const n = e.lastSegment(),
   r = e.popLast(),
   i = this.index[n];
  return i && i.has(r);
 }
 getEntries(e) {
  return (this.index[e] || new yt(Ne.comparator)).toArray();
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ms {
 constructor(e) {
  this.Ln = e;
 }
 next() {
  return (this.Ln += 2), this.Ln;
 }
 static Bn() {
  return new Ms(0);
 }
 static kn() {
  return new Ms(-1);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class a4 {
 constructor() {
  (this.changes = new Ks(
   (e) => e.toString(),
   (e, n) => e.isEqual(n)
  )),
   (this.changesApplied = !1);
 }
 addEntry(e) {
  this.assertNotApplied(), this.changes.set(e.key, e);
 }
 removeEntry(e, n) {
  this.assertNotApplied(), this.changes.set(e, kt.newInvalidDocument(e).setReadTime(n));
 }
 getEntry(e, n) {
  this.assertNotApplied();
  const r = this.changes.get(n);
  return r !== void 0 ? $.resolve(r) : this.getFromCache(e, n);
 }
 getEntries(e, n) {
  return this.getAllFromCache(e, n);
 }
 apply(e) {
  return this.assertNotApplied(), (this.changesApplied = !0), this.applyChanges(e);
 }
 assertNotApplied() {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class l4 {
 constructor(e, n) {
  (this.overlayedDocument = e), (this.mutatedFields = n);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class u4 {
 constructor(e, n, r, i) {
  (this.remoteDocumentCache = e), (this.mutationQueue = n), (this.documentOverlayCache = r), (this.indexManager = i);
 }
 getDocument(e, n) {
  let r = null;
  return this.documentOverlayCache
   .getOverlay(e, n)
   .next((i) => ((r = i), this.remoteDocumentCache.getEntry(e, n)))
   .next((i) => (r !== null && Qa(r.mutation, i, un.empty(), st.now()), i));
 }
 getDocuments(e, n) {
  return this.remoteDocumentCache.getEntries(e, n).next((r) => this.getLocalViewOfDocuments(e, r, ce()).next(() => r));
 }
 getLocalViewOfDocuments(e, n, r = ce()) {
  const i = eo();
  return this.populateOverlays(e, i, n).next(() =>
   this.computeViews(e, n, i, r).next((o) => {
    let s = Ma();
    return (
     o.forEach((a, l) => {
      s = s.insert(a, l.overlayedDocument);
     }),
     s
    );
   })
  );
 }
 getOverlayedDocuments(e, n) {
  const r = eo();
  return this.populateOverlays(e, r, n).next(() => this.computeViews(e, n, r, ce()));
 }
 populateOverlays(e, n, r) {
  const i = [];
  return (
   r.forEach((o) => {
    n.has(o) || i.push(o);
   }),
   this.documentOverlayCache.getOverlays(e, i).next((o) => {
    o.forEach((s, a) => {
     n.set(s, a);
    });
   })
  );
 }
 computeViews(e, n, r, i) {
  let o = Mr();
  const s = Ya(),
   a = (function () {
    return Ya();
   })();
  return (
   n.forEach((l, u) => {
    const h = r.get(u.key);
    i.has(u.key) && (h === void 0 || h.mutation instanceof Li)
     ? (o = o.insert(u.key, u))
     : h !== void 0
       ? (s.set(u.key, h.mutation.getFieldMask()), Qa(h.mutation, u, h.mutation.getFieldMask(), st.now()))
       : s.set(u.key, un.empty());
   }),
   this.recalculateAndSaveOverlays(e, o).next(
    (l) => (
     l.forEach((u, h) => s.set(u, h)),
     n.forEach((u, h) => {
      var p;
      return a.set(u, new l4(h, (p = s.get(u)) !== null && p !== void 0 ? p : null));
     }),
     a
    )
   )
  );
 }
 recalculateAndSaveOverlays(e, n) {
  const r = Ya();
  let i = new Be((s, a) => s - a),
   o = ce();
  return this.mutationQueue
   .getAllMutationBatchesAffectingDocumentKeys(e, n)
   .next((s) => {
    for (const a of s)
     a.keys().forEach((l) => {
      const u = n.get(l);
      if (u === null) return;
      let h = r.get(l) || un.empty();
      (h = a.applyToLocalView(u, h)), r.set(l, h);
      const p = (i.get(a.batchId) || ce()).add(l);
      i = i.insert(a.batchId, p);
     });
   })
   .next(() => {
    const s = [],
     a = i.getReverseIterator();
    for (; a.hasNext(); ) {
     const l = a.getNext(),
      u = l.key,
      h = l.value,
      p = KR();
     h.forEach((m) => {
      if (!o.has(m)) {
       const v = tP(n.get(m), r.get(m));
       v !== null && p.set(m, v), (o = o.add(m));
      }
     }),
      s.push(this.documentOverlayCache.saveOverlays(e, u, p));
    }
    return $.waitFor(s);
   })
   .next(() => r);
 }
 recalculateAndSaveOverlaysForDocumentKeys(e, n) {
  return this.remoteDocumentCache.getEntries(e, n).next((r) => this.recalculateAndSaveOverlays(e, r));
 }
 getDocumentsMatchingQuery(e, n, r, i) {
  return (function (s) {
   return j.isDocumentKey(s.path) && s.collectionGroup === null && s.filters.length === 0;
  })(n)
   ? this.getDocumentsMatchingDocumentQuery(e, n.path)
   : $R(n)
     ? this.getDocumentsMatchingCollectionGroupQuery(e, n, r, i)
     : this.getDocumentsMatchingCollectionQuery(e, n, r, i);
 }
 getNextDocuments(e, n, r, i) {
  return this.remoteDocumentCache.getAllFromCollectionGroup(e, n, r, i).next((o) => {
   const s =
    i - o.size > 0
     ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, n, r.largestBatchId, i - o.size)
     : $.resolve(eo());
   let a = -1,
    l = o;
   return s.next((u) =>
    $.forEach(
     u,
     (h, p) => (
      a < p.largestBatchId && (a = p.largestBatchId),
      o.get(h)
       ? $.resolve()
       : this.remoteDocumentCache.getEntry(e, h).next((m) => {
          l = l.insert(h, m);
         })
     )
    )
     .next(() => this.populateOverlays(e, u, o))
     .next(() => this.computeViews(e, l, u, ce()))
     .next((h) => ({ batchId: a, changes: WR(h) }))
   );
  });
 }
 getDocumentsMatchingDocumentQuery(e, n) {
  return this.getDocument(e, new j(n)).next((r) => {
   let i = Ma();
   return r.isFoundDocument() && (i = i.insert(r.key, r)), i;
  });
 }
 getDocumentsMatchingCollectionGroupQuery(e, n, r, i) {
  const o = n.collectionGroup;
  let s = Ma();
  return this.indexManager.getCollectionParents(e, o).next((a) =>
   $.forEach(a, (l) => {
    const u = (function (p, m) {
     return new Ws(m, null, p.explicitOrderBy.slice(), p.filters.slice(), p.limit, p.limitType, p.startAt, p.endAt);
    })(n, l.child(o));
    return this.getDocumentsMatchingCollectionQuery(e, u, r, i).next((h) => {
     h.forEach((p, m) => {
      s = s.insert(p, m);
     });
    });
   }).next(() => s)
  );
 }
 getDocumentsMatchingCollectionQuery(e, n, r, i) {
  let o;
  return this.documentOverlayCache
   .getOverlaysForCollection(e, n.path, r.largestBatchId)
   .next((s) => ((o = s), this.remoteDocumentCache.getDocumentsMatchingQuery(e, n, r, o, i)))
   .next((s) => {
    o.forEach((l, u) => {
     const h = u.getKey();
     s.get(h) === null && (s = s.insert(h, kt.newInvalidDocument(h)));
    });
    let a = Ma();
    return (
     s.forEach((l, u) => {
      const h = o.get(l);
      h !== void 0 && Qa(h.mutation, u, un.empty(), st.now()), ff(n, u) && (a = a.insert(l, u));
     }),
     a
    );
   });
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class c4 {
 constructor(e) {
  (this.serializer = e), (this.hr = new Map()), (this.Pr = new Map());
 }
 getBundleMetadata(e, n) {
  return $.resolve(this.hr.get(n));
 }
 saveBundleMetadata(e, n) {
  return (
   this.hr.set(
    n.id,
    (function (i) {
     return { id: i.id, version: i.version, createTime: ar(i.createTime) };
    })(n)
   ),
   $.resolve()
  );
 }
 getNamedQuery(e, n) {
  return $.resolve(this.Pr.get(n));
 }
 saveNamedQuery(e, n) {
  return (
   this.Pr.set(
    n.name,
    (function (i) {
     return { name: i.name, query: i4(i.bundledQuery), readTime: ar(i.readTime) };
    })(n)
   ),
   $.resolve()
  );
 }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class d4 {
 constructor() {
  (this.overlays = new Be(j.comparator)), (this.Ir = new Map());
 }
 getOverlay(e, n) {
  return $.resolve(this.overlays.get(n));
 }
 getOverlays(e, n) {
  const r = eo();
  return $.forEach(n, (i) =>
   this.getOverlay(e, i).next((o) => {
    o !== null && r.set(i, o);
   })
  ).next(() => r);
 }
 saveOverlays(e, n, r) {
  return (
   r.forEach((i, o) => {
    this.ht(e, n, o);
   }),
   $.resolve()
  );
 }
 removeOverlaysForBatchId(e, n, r) {
  const i = this.Ir.get(r);
  return i !== void 0 && (i.forEach((o) => (this.overlays = this.overlays.remove(o))), this.Ir.delete(r)), $.resolve();
 }
 getOverlaysForCollection(e, n, r) {
  const i = eo(),
   o = n.length + 1,
   s = new j(n.child("")),
   a = this.overlays.getIteratorFrom(s);
  for (; a.hasNext(); ) {
   const l = a.getNext().value,
    u = l.getKey();
   if (!n.isPrefixOf(u.path)) break;
   u.path.length === o && l.largestBatchId > r && i.set(l.getKey(), l);
  }
  return $.resolve(i);
 }
 getOverlaysForCollectionGroup(e, n, r, i) {
  let o = new Be((u, h) => u - h);
  const s = this.overlays.getIterator();
  for (; s.hasNext(); ) {
   const u = s.getNext().value;
   if (u.getKey().getCollectionGroup() === n && u.largestBatchId > r) {
    let h = o.get(u.largestBatchId);
    h === null && ((h = eo()), (o = o.insert(u.largestBatchId, h))), h.set(u.getKey(), u);
   }
  }
  const a = eo(),
   l = o.getIterator();
  for (; l.hasNext() && (l.getNext().value.forEach((u, h) => a.set(u, h)), !(a.size() >= i)); );
  return $.resolve(a);
 }
 ht(e, n, r) {
  const i = this.overlays.get(r.key);
  if (i !== null) {
   const s = this.Ir.get(i.largestBatchId).delete(r.key);
   this.Ir.set(i.largestBatchId, s);
  }
  this.overlays = this.overlays.insert(r.key, new MB(n, r));
  let o = this.Ir.get(n);
  o === void 0 && ((o = ce()), this.Ir.set(n, o)), this.Ir.set(n, o.add(r.key));
 }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class f4 {
 constructor() {
  this.sessionToken = _t.EMPTY_BYTE_STRING;
 }
 getSessionToken(e) {
  return $.resolve(this.sessionToken);
 }
 setSessionToken(e, n) {
  return (this.sessionToken = n), $.resolve();
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Py {
 constructor() {
  (this.Tr = new yt(at.Er)), (this.dr = new yt(at.Ar));
 }
 isEmpty() {
  return this.Tr.isEmpty();
 }
 addReference(e, n) {
  const r = new at(e, n);
  (this.Tr = this.Tr.add(r)), (this.dr = this.dr.add(r));
 }
 Rr(e, n) {
  e.forEach((r) => this.addReference(r, n));
 }
 removeReference(e, n) {
  this.Vr(new at(e, n));
 }
 mr(e, n) {
  e.forEach((r) => this.removeReference(r, n));
 }
 gr(e) {
  const n = new j(new Ne([])),
   r = new at(n, e),
   i = new at(n, e + 1),
   o = [];
  return (
   this.dr.forEachInRange([r, i], (s) => {
    this.Vr(s), o.push(s.key);
   }),
   o
  );
 }
 pr() {
  this.Tr.forEach((e) => this.Vr(e));
 }
 Vr(e) {
  (this.Tr = this.Tr.delete(e)), (this.dr = this.dr.delete(e));
 }
 yr(e) {
  const n = new j(new Ne([])),
   r = new at(n, e),
   i = new at(n, e + 1);
  let o = ce();
  return (
   this.dr.forEachInRange([r, i], (s) => {
    o = o.add(s.key);
   }),
   o
  );
 }
 containsKey(e) {
  const n = new at(e, 0),
   r = this.Tr.firstAfterOrEqual(n);
  return r !== null && e.isEqual(r.key);
 }
}
class at {
 constructor(e, n) {
  (this.key = e), (this.wr = n);
 }
 static Er(e, n) {
  return j.comparator(e.key, n.key) || ge(e.wr, n.wr);
 }
 static Ar(e, n) {
  return ge(e.wr, n.wr) || j.comparator(e.key, n.key);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class h4 {
 constructor(e, n) {
  (this.indexManager = e),
   (this.referenceDelegate = n),
   (this.mutationQueue = []),
   (this.Sr = 1),
   (this.br = new yt(at.Er));
 }
 checkEmpty(e) {
  return $.resolve(this.mutationQueue.length === 0);
 }
 addMutationBatch(e, n, r, i) {
  const o = this.Sr;
  this.Sr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
  const s = new xB(o, n, r, i);
  this.mutationQueue.push(s);
  for (const a of i)
   (this.br = this.br.add(new at(a.key, o))), this.indexManager.addToCollectionParentIndex(e, a.key.path.popLast());
  return $.resolve(s);
 }
 lookupMutationBatch(e, n) {
  return $.resolve(this.Dr(n));
 }
 getNextMutationBatchAfterBatchId(e, n) {
  const r = n + 1,
   i = this.vr(r),
   o = i < 0 ? 0 : i;
  return $.resolve(this.mutationQueue.length > o ? this.mutationQueue[o] : null);
 }
 getHighestUnacknowledgedBatchId() {
  return $.resolve(this.mutationQueue.length === 0 ? -1 : this.Sr - 1);
 }
 getAllMutationBatches(e) {
  return $.resolve(this.mutationQueue.slice());
 }
 getAllMutationBatchesAffectingDocumentKey(e, n) {
  const r = new at(n, 0),
   i = new at(n, Number.POSITIVE_INFINITY),
   o = [];
  return (
   this.br.forEachInRange([r, i], (s) => {
    const a = this.Dr(s.wr);
    o.push(a);
   }),
   $.resolve(o)
  );
 }
 getAllMutationBatchesAffectingDocumentKeys(e, n) {
  let r = new yt(ge);
  return (
   n.forEach((i) => {
    const o = new at(i, 0),
     s = new at(i, Number.POSITIVE_INFINITY);
    this.br.forEachInRange([o, s], (a) => {
     r = r.add(a.wr);
    });
   }),
   $.resolve(this.Cr(r))
  );
 }
 getAllMutationBatchesAffectingQuery(e, n) {
  const r = n.path,
   i = r.length + 1;
  let o = r;
  j.isDocumentKey(o) || (o = o.child(""));
  const s = new at(new j(o), 0);
  let a = new yt(ge);
  return (
   this.br.forEachWhile((l) => {
    const u = l.key.path;
    return !!r.isPrefixOf(u) && (u.length === i && (a = a.add(l.wr)), !0);
   }, s),
   $.resolve(this.Cr(a))
  );
 }
 Cr(e) {
  const n = [];
  return (
   e.forEach((r) => {
    const i = this.Dr(r);
    i !== null && n.push(i);
   }),
   n
  );
 }
 removeMutationBatch(e, n) {
  we(this.Fr(n.batchId, "removed") === 0), this.mutationQueue.shift();
  let r = this.br;
  return $.forEach(n.mutations, (i) => {
   const o = new at(i.key, n.batchId);
   return (r = r.delete(o)), this.referenceDelegate.markPotentiallyOrphaned(e, i.key);
  }).next(() => {
   this.br = r;
  });
 }
 On(e) {}
 containsKey(e, n) {
  const r = new at(n, 0),
   i = this.br.firstAfterOrEqual(r);
  return $.resolve(n.isEqual(i && i.key));
 }
 performConsistencyCheck(e) {
  return this.mutationQueue.length, $.resolve();
 }
 Fr(e, n) {
  return this.vr(e);
 }
 vr(e) {
  return this.mutationQueue.length === 0 ? 0 : e - this.mutationQueue[0].batchId;
 }
 Dr(e) {
  const n = this.vr(e);
  return n < 0 || n >= this.mutationQueue.length ? null : this.mutationQueue[n];
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class p4 {
 constructor(e) {
  (this.Mr = e),
   (this.docs = (function () {
    return new Be(j.comparator);
   })()),
   (this.size = 0);
 }
 setIndexManager(e) {
  this.indexManager = e;
 }
 addEntry(e, n) {
  const r = n.key,
   i = this.docs.get(r),
   o = i ? i.size : 0,
   s = this.Mr(n);
  return (
   (this.docs = this.docs.insert(r, { document: n.mutableCopy(), size: s })),
   (this.size += s - o),
   this.indexManager.addToCollectionParentIndex(e, r.path.popLast())
  );
 }
 removeEntry(e) {
  const n = this.docs.get(e);
  n && ((this.docs = this.docs.remove(e)), (this.size -= n.size));
 }
 getEntry(e, n) {
  const r = this.docs.get(n);
  return $.resolve(r ? r.document.mutableCopy() : kt.newInvalidDocument(n));
 }
 getEntries(e, n) {
  let r = Mr();
  return (
   n.forEach((i) => {
    const o = this.docs.get(i);
    r = r.insert(i, o ? o.document.mutableCopy() : kt.newInvalidDocument(i));
   }),
   $.resolve(r)
  );
 }
 getDocumentsMatchingQuery(e, n, r, i) {
  let o = Mr();
  const s = n.path,
   a = new j(s.child("")),
   l = this.docs.getIteratorFrom(a);
  for (; l.hasNext(); ) {
   const {
    key: u,
    value: { document: h },
   } = l.getNext();
   if (!s.isPrefixOf(u.path)) break;
   u.path.length > s.length + 1 ||
    QF(YF(h), r) <= 0 ||
    ((i.has(h.key) || ff(n, h)) && (o = o.insert(h.key, h.mutableCopy())));
  }
  return $.resolve(o);
 }
 getAllFromCollectionGroup(e, n, r, i) {
  ne();
 }
 Or(e, n) {
  return $.forEach(this.docs, (r) => n(r));
 }
 newChangeBuffer(e) {
  return new m4(this);
 }
 getSize(e) {
  return $.resolve(this.size);
 }
}
class m4 extends a4 {
 constructor(e) {
  super(), (this.cr = e);
 }
 applyChanges(e) {
  const n = [];
  return (
   this.changes.forEach((r, i) => {
    i.isValidDocument() ? n.push(this.cr.addEntry(e, i)) : this.cr.removeEntry(r);
   }),
   $.waitFor(n)
  );
 }
 getFromCache(e, n) {
  return this.cr.getEntry(e, n);
 }
 getAllFromCache(e, n) {
  return this.cr.getEntries(e, n);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class g4 {
 constructor(e) {
  (this.persistence = e),
   (this.Nr = new Ks((n) => Ty(n), Iy)),
   (this.lastRemoteSnapshotVersion = oe.min()),
   (this.highestTargetId = 0),
   (this.Lr = 0),
   (this.Br = new Py()),
   (this.targetCount = 0),
   (this.kr = Ms.Bn());
 }
 forEachTarget(e, n) {
  return this.Nr.forEach((r, i) => n(i)), $.resolve();
 }
 getLastRemoteSnapshotVersion(e) {
  return $.resolve(this.lastRemoteSnapshotVersion);
 }
 getHighestSequenceNumber(e) {
  return $.resolve(this.Lr);
 }
 allocateTargetId(e) {
  return (this.highestTargetId = this.kr.next()), $.resolve(this.highestTargetId);
 }
 setTargetsMetadata(e, n, r) {
  return r && (this.lastRemoteSnapshotVersion = r), n > this.Lr && (this.Lr = n), $.resolve();
 }
 Kn(e) {
  this.Nr.set(e.target, e);
  const n = e.targetId;
  n > this.highestTargetId && ((this.kr = new Ms(n)), (this.highestTargetId = n)),
   e.sequenceNumber > this.Lr && (this.Lr = e.sequenceNumber);
 }
 addTargetData(e, n) {
  return this.Kn(n), (this.targetCount += 1), $.resolve();
 }
 updateTargetData(e, n) {
  return this.Kn(n), $.resolve();
 }
 removeTargetData(e, n) {
  return this.Nr.delete(n.target), this.Br.gr(n.targetId), (this.targetCount -= 1), $.resolve();
 }
 removeTargets(e, n, r) {
  let i = 0;
  const o = [];
  return (
   this.Nr.forEach((s, a) => {
    a.sequenceNumber <= n &&
     r.get(a.targetId) === null &&
     (this.Nr.delete(s), o.push(this.removeMatchingKeysForTargetId(e, a.targetId)), i++);
   }),
   $.waitFor(o).next(() => i)
  );
 }
 getTargetCount(e) {
  return $.resolve(this.targetCount);
 }
 getTargetData(e, n) {
  const r = this.Nr.get(n) || null;
  return $.resolve(r);
 }
 addMatchingKeys(e, n, r) {
  return this.Br.Rr(n, r), $.resolve();
 }
 removeMatchingKeys(e, n, r) {
  this.Br.mr(n, r);
  const i = this.persistence.referenceDelegate,
   o = [];
  return (
   i &&
    n.forEach((s) => {
     o.push(i.markPotentiallyOrphaned(e, s));
    }),
   $.waitFor(o)
  );
 }
 removeMatchingKeysForTargetId(e, n) {
  return this.Br.gr(n), $.resolve();
 }
 getMatchingKeysForTargetId(e, n) {
  const r = this.Br.yr(n);
  return $.resolve(r);
 }
 containsKey(e, n) {
  return $.resolve(this.Br.containsKey(n));
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class y4 {
 constructor(e, n) {
  (this.qr = {}),
   (this.overlays = {}),
   (this.Qr = new vy(0)),
   (this.Kr = !1),
   (this.Kr = !0),
   (this.$r = new f4()),
   (this.referenceDelegate = e(this)),
   (this.Ur = new g4(this)),
   (this.indexManager = new o4()),
   (this.remoteDocumentCache = (function (i) {
    return new p4(i);
   })((r) => this.referenceDelegate.Wr(r))),
   (this.serializer = new r4(n)),
   (this.Gr = new c4(this.serializer));
 }
 start() {
  return Promise.resolve();
 }
 shutdown() {
  return (this.Kr = !1), Promise.resolve();
 }
 get started() {
  return this.Kr;
 }
 setDatabaseDeletedListener() {}
 setNetworkEnabled() {}
 getIndexManager(e) {
  return this.indexManager;
 }
 getDocumentOverlayCache(e) {
  let n = this.overlays[e.toKey()];
  return n || ((n = new d4()), (this.overlays[e.toKey()] = n)), n;
 }
 getMutationQueue(e, n) {
  let r = this.qr[e.toKey()];
  return r || ((r = new h4(n, this.referenceDelegate)), (this.qr[e.toKey()] = r)), r;
 }
 getGlobalsCache() {
  return this.$r;
 }
 getTargetCache() {
  return this.Ur;
 }
 getRemoteDocumentCache() {
  return this.remoteDocumentCache;
 }
 getBundleCache() {
  return this.Gr;
 }
 runTransaction(e, n, r) {
  Q("MemoryPersistence", "Starting transaction:", e);
  const i = new v4(this.Qr.next());
  return (
   this.referenceDelegate.zr(),
   r(i)
    .next((o) => this.referenceDelegate.jr(i).next(() => o))
    .toPromise()
    .then((o) => (i.raiseOnCommittedEvent(), o))
  );
 }
 Hr(e, n) {
  return $.or(Object.values(this.qr).map((r) => () => r.containsKey(e, n)));
 }
}
class v4 extends jF {
 constructor(e) {
  super(), (this.currentSequenceNumber = e);
 }
}
class ky {
 constructor(e) {
  (this.persistence = e), (this.Jr = new Py()), (this.Yr = null);
 }
 static Zr(e) {
  return new ky(e);
 }
 get Xr() {
  if (this.Yr) return this.Yr;
  throw ne();
 }
 addReference(e, n, r) {
  return this.Jr.addReference(r, n), this.Xr.delete(r.toString()), $.resolve();
 }
 removeReference(e, n, r) {
  return this.Jr.removeReference(r, n), this.Xr.add(r.toString()), $.resolve();
 }
 markPotentiallyOrphaned(e, n) {
  return this.Xr.add(n.toString()), $.resolve();
 }
 removeTarget(e, n) {
  this.Jr.gr(n.targetId).forEach((i) => this.Xr.add(i.toString()));
  const r = this.persistence.getTargetCache();
  return r
   .getMatchingKeysForTargetId(e, n.targetId)
   .next((i) => {
    i.forEach((o) => this.Xr.add(o.toString()));
   })
   .next(() => r.removeTargetData(e, n));
 }
 zr() {
  this.Yr = new Set();
 }
 jr(e) {
  const n = this.persistence.getRemoteDocumentCache().newChangeBuffer();
  return $.forEach(this.Xr, (r) => {
   const i = j.fromPath(r);
   return this.ei(e, i).next((o) => {
    o || n.removeEntry(i, oe.min());
   });
  }).next(() => ((this.Yr = null), n.apply(e)));
 }
 updateLimboDocument(e, n) {
  return this.ei(e, n).next((r) => {
   r ? this.Xr.delete(n.toString()) : this.Xr.add(n.toString());
  });
 }
 Wr(e) {
  return 0;
 }
 ei(e, n) {
  return $.or([
   () => $.resolve(this.Jr.containsKey(n)),
   () => this.persistence.getTargetCache().containsKey(e, n),
   () => this.persistence.Hr(e, n),
  ]);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class by {
 constructor(e, n, r, i) {
  (this.targetId = e), (this.fromCache = n), (this.$i = r), (this.Ui = i);
 }
 static Wi(e, n) {
  let r = ce(),
   i = ce();
  for (const o of n.docChanges)
   switch (o.type) {
    case 0:
     r = r.add(o.doc.key);
     break;
    case 1:
     i = i.add(o.doc.key);
   }
  return new by(e, n.fromCache, r, i);
 }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _4 {
 constructor() {
  this._documentReadCount = 0;
 }
 get documentReadCount() {
  return this._documentReadCount;
 }
 incrementDocumentReadCount(e) {
  this._documentReadCount += e;
 }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class w4 {
 constructor() {
  (this.Gi = !1),
   (this.zi = !1),
   (this.ji = 100),
   (this.Hi = (function () {
    return sV() ? 8 : ZF(Lt()) > 0 ? 6 : 4;
   })());
 }
 initialize(e, n) {
  (this.Ji = e), (this.indexManager = n), (this.Gi = !0);
 }
 getDocumentsMatchingQuery(e, n, r, i) {
  const o = { result: null };
  return this.Yi(e, n)
   .next((s) => {
    o.result = s;
   })
   .next(() => {
    if (!o.result)
     return this.Zi(e, n, i, r).next((s) => {
      o.result = s;
     });
   })
   .next(() => {
    if (o.result) return;
    const s = new _4();
    return this.Xi(e, n, s).next((a) => {
     if (((o.result = a), this.zi)) return this.es(e, n, s, a.size);
    });
   })
   .next(() => o.result);
 }
 es(e, n, r, i) {
  return r.documentReadCount < this.ji
   ? (wa() <= de.DEBUG &&
      Q(
       "QueryEngine",
       "SDK will not create cache indexes for query:",
       Ho(n),
       "since it only creates cache indexes for collection contains",
       "more than or equal to",
       this.ji,
       "documents"
      ),
     $.resolve())
   : (wa() <= de.DEBUG &&
      Q(
       "QueryEngine",
       "Query:",
       Ho(n),
       "scans",
       r.documentReadCount,
       "local documents and returns",
       i,
       "documents as results."
      ),
     r.documentReadCount > this.Hi * i
      ? (wa() <= de.DEBUG &&
         Q(
          "QueryEngine",
          "The SDK decides to create cache indexes for query:",
          Ho(n),
          "as using cache indexes may help improve performance."
         ),
        this.indexManager.createTargetIndexes(e, sr(n)))
      : $.resolve());
 }
 Yi(e, n) {
  if (H0(n)) return $.resolve(null);
  let r = sr(n);
  return this.indexManager.getIndexType(e, r).next((i) =>
   i === 0
    ? null
    : (n.limit !== null && i === 1 && ((n = _d(n, null, "F")), (r = sr(n))),
      this.indexManager.getDocumentsMatchingTarget(e, r).next((o) => {
       const s = ce(...o);
       return this.Ji.getDocuments(e, s).next((a) =>
        this.indexManager.getMinOffset(e, r).next((l) => {
         const u = this.ts(n, a);
         return this.ns(n, u, s, l.readTime) ? this.Yi(e, _d(n, null, "F")) : this.rs(e, u, n, l);
        })
       );
      }))
  );
 }
 Zi(e, n, r, i) {
  return H0(n) || i.isEqual(oe.min())
   ? $.resolve(null)
   : this.Ji.getDocuments(e, r).next((o) => {
      const s = this.ts(n, o);
      return this.ns(n, s, r, i)
       ? $.resolve(null)
       : (wa() <= de.DEBUG &&
          Q("QueryEngine", "Re-using previous result from %s to execute query: %s", i.toString(), Ho(n)),
         this.rs(e, s, n, JF(i, -1)).next((a) => a));
     });
 }
 ts(e, n) {
  let r = new yt(GR(e));
  return (
   n.forEach((i, o) => {
    ff(e, o) && (r = r.add(o));
   }),
   r
  );
 }
 ns(e, n, r, i) {
  if (e.limit === null) return !1;
  if (r.size !== n.size) return !0;
  const o = e.limitType === "F" ? n.last() : n.first();
  return !!o && (o.hasPendingWrites || o.version.compareTo(i) > 0);
 }
 Xi(e, n, r) {
  return (
   wa() <= de.DEBUG && Q("QueryEngine", "Using full collection scan to execute query:", Ho(n)),
   this.Ji.getDocumentsMatchingQuery(e, n, Ci.min(), r)
  );
 }
 rs(e, n, r, i) {
  return this.Ji.getDocumentsMatchingQuery(e, r, i).next(
   (o) => (
    n.forEach((s) => {
     o = o.insert(s.key, s);
    }),
    o
   )
  );
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class E4 {
 constructor(e, n, r, i) {
  (this.persistence = e),
   (this.ss = n),
   (this.serializer = i),
   (this.os = new Be(ge)),
   (this._s = new Ks((o) => Ty(o), Iy)),
   (this.us = new Map()),
   (this.cs = e.getRemoteDocumentCache()),
   (this.Ur = e.getTargetCache()),
   (this.Gr = e.getBundleCache()),
   this.ls(r);
 }
 ls(e) {
  (this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e)),
   (this.indexManager = this.persistence.getIndexManager(e)),
   (this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager)),
   (this.localDocuments = new u4(this.cs, this.mutationQueue, this.documentOverlayCache, this.indexManager)),
   this.cs.setIndexManager(this.indexManager),
   this.ss.initialize(this.localDocuments, this.indexManager);
 }
 collectGarbage(e) {
  return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (n) => e.collect(n, this.os));
 }
}
function T4(t, e, n, r) {
 return new E4(t, e, n, r);
}
async function pP(t, e) {
 const n = re(t);
 return await n.persistence.runTransaction("Handle user change", "readonly", (r) => {
  let i;
  return n.mutationQueue
   .getAllMutationBatches(r)
   .next((o) => ((i = o), n.ls(e), n.mutationQueue.getAllMutationBatches(r)))
   .next((o) => {
    const s = [],
     a = [];
    let l = ce();
    for (const u of i) {
     s.push(u.batchId);
     for (const h of u.mutations) l = l.add(h.key);
    }
    for (const u of o) {
     a.push(u.batchId);
     for (const h of u.mutations) l = l.add(h.key);
    }
    return n.localDocuments.getDocuments(r, l).next((u) => ({ hs: u, removedBatchIds: s, addedBatchIds: a }));
   });
 });
}
function I4(t, e) {
 const n = re(t);
 return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (r) => {
  const i = e.batch.keys(),
   o = n.cs.newChangeBuffer({ trackRemovals: !0 });
  return (function (a, l, u, h) {
   const p = u.batch,
    m = p.keys();
   let v = $.resolve();
   return (
    m.forEach((w) => {
     v = v
      .next(() => h.getEntry(l, w))
      .next((C) => {
       const A = u.docVersions.get(w);
       we(A !== null),
        C.version.compareTo(A) < 0 &&
         (p.applyToRemoteDocument(C, u), C.isValidDocument() && (C.setReadTime(u.commitVersion), h.addEntry(C)));
      });
    }),
    v.next(() => a.mutationQueue.removeMutationBatch(l, p))
   );
  })(n, r, e, o)
   .next(() => o.apply(r))
   .next(() => n.mutationQueue.performConsistencyCheck(r))
   .next(() => n.documentOverlayCache.removeOverlaysForBatchId(r, i, e.batch.batchId))
   .next(() =>
    n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(
     r,
     (function (a) {
      let l = ce();
      for (let u = 0; u < a.mutationResults.length; ++u)
       a.mutationResults[u].transformResults.length > 0 && (l = l.add(a.batch.mutations[u].key));
      return l;
     })(e)
    )
   )
   .next(() => n.localDocuments.getDocuments(r, i));
 });
}
function mP(t) {
 const e = re(t);
 return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (n) =>
  e.Ur.getLastRemoteSnapshotVersion(n)
 );
}
function S4(t, e) {
 const n = re(t),
  r = e.snapshotVersion;
 let i = n.os;
 return n.persistence
  .runTransaction("Apply remote event", "readwrite-primary", (o) => {
   const s = n.cs.newChangeBuffer({ trackRemovals: !0 });
   i = n.os;
   const a = [];
   e.targetChanges.forEach((h, p) => {
    const m = i.get(p);
    if (!m) return;
    a.push(n.Ur.removeMatchingKeys(o, h.removedDocuments, p).next(() => n.Ur.addMatchingKeys(o, h.addedDocuments, p)));
    let v = m.withSequenceNumber(o.currentSequenceNumber);
    e.targetMismatches.get(p) !== null
     ? (v = v.withResumeToken(_t.EMPTY_BYTE_STRING, oe.min()).withLastLimboFreeSnapshotVersion(oe.min()))
     : h.resumeToken.approximateByteSize() > 0 && (v = v.withResumeToken(h.resumeToken, r)),
     (i = i.insert(p, v)),
     (function (C, A, T) {
      return C.resumeToken.approximateByteSize() === 0 ||
       A.snapshotVersion.toMicroseconds() - C.snapshotVersion.toMicroseconds() >= 3e8
       ? !0
       : T.addedDocuments.size + T.modifiedDocuments.size + T.removedDocuments.size > 0;
     })(m, v, h) && a.push(n.Ur.updateTargetData(o, v));
   });
   let l = Mr(),
    u = ce();
   if (
    (e.documentUpdates.forEach((h) => {
     e.resolvedLimboDocuments.has(h) && a.push(n.persistence.referenceDelegate.updateLimboDocument(o, h));
    }),
    a.push(
     A4(o, s, e.documentUpdates).next((h) => {
      (l = h.Ps), (u = h.Is);
     })
    ),
    !r.isEqual(oe.min()))
   ) {
    const h = n.Ur.getLastRemoteSnapshotVersion(o).next((p) => n.Ur.setTargetsMetadata(o, o.currentSequenceNumber, r));
    a.push(h);
   }
   return $.waitFor(a)
    .next(() => s.apply(o))
    .next(() => n.localDocuments.getLocalViewOfDocuments(o, l, u))
    .next(() => l);
  })
  .then((o) => ((n.os = i), o));
}
function A4(t, e, n) {
 let r = ce(),
  i = ce();
 return (
  n.forEach((o) => (r = r.add(o))),
  e.getEntries(t, r).next((o) => {
   let s = Mr();
   return (
    n.forEach((a, l) => {
     const u = o.get(a);
     l.isFoundDocument() !== u.isFoundDocument() && (i = i.add(a)),
      l.isNoDocument() && l.version.isEqual(oe.min())
       ? (e.removeEntry(a, l.readTime), (s = s.insert(a, l)))
       : !u.isValidDocument() ||
           l.version.compareTo(u.version) > 0 ||
           (l.version.compareTo(u.version) === 0 && u.hasPendingWrites)
         ? (e.addEntry(l), (s = s.insert(a, l)))
         : Q(
            "LocalStore",
            "Ignoring outdated watch update for ",
            a,
            ". Current version:",
            u.version,
            " Watch version:",
            l.version
           );
    }),
    { Ps: s, Is: i }
   );
  })
 );
}
function C4(t, e) {
 const n = re(t);
 return n.persistence.runTransaction(
  "Get next mutation batch",
  "readonly",
  (r) => (e === void 0 && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(r, e))
 );
}
function R4(t, e) {
 const n = re(t);
 return n.persistence
  .runTransaction("Allocate target", "readwrite", (r) => {
   let i;
   return n.Ur.getTargetData(r, e).next((o) =>
    o
     ? ((i = o), $.resolve(i))
     : n.Ur.allocateTargetId(r).next(
        (s) => (
         (i = new di(e, s, "TargetPurposeListen", r.currentSequenceNumber)), n.Ur.addTargetData(r, i).next(() => i)
        )
       )
   );
  })
  .then((r) => {
   const i = n.os.get(r.targetId);
   return (
    (i === null || r.snapshotVersion.compareTo(i.snapshotVersion) > 0) &&
     ((n.os = n.os.insert(r.targetId, r)), n._s.set(e, r.targetId)),
    r
   );
  });
}
async function Em(t, e, n) {
 const r = re(t),
  i = r.os.get(e),
  o = n ? "readwrite" : "readwrite-primary";
 try {
  n ||
   (await r.persistence.runTransaction("Release target", o, (s) => r.persistence.referenceDelegate.removeTarget(s, i)));
 } catch (s) {
  if (!Ql(s)) throw s;
  Q("LocalStore", `Failed to update sequence numbers for target ${e}: ${s}`);
 }
 (r.os = r.os.remove(e)), r._s.delete(i.target);
}
function Z0(t, e, n) {
 const r = re(t);
 let i = oe.min(),
  o = ce();
 return r.persistence.runTransaction("Execute query", "readwrite", (s) =>
  (function (l, u, h) {
   const p = re(l),
    m = p._s.get(h);
   return m !== void 0 ? $.resolve(p.os.get(m)) : p.Ur.getTargetData(u, h);
  })(r, s, sr(e))
   .next((a) => {
    if (a)
     return (
      (i = a.lastLimboFreeSnapshotVersion),
      r.Ur.getMatchingKeysForTargetId(s, a.targetId).next((l) => {
       o = l;
      })
     );
   })
   .next(() => r.ss.getDocumentsMatchingQuery(s, e, n ? i : oe.min(), n ? o : ce()))
   .next((a) => (P4(r, vB(e), a), { documents: a, Ts: o }))
 );
}
function P4(t, e, n) {
 let r = t.us.get(e) || oe.min();
 n.forEach((i, o) => {
  o.readTime.compareTo(r) > 0 && (r = o.readTime);
 }),
  t.us.set(e, r);
}
class eE {
 constructor() {
  this.activeTargetIds = SB();
 }
 fs(e) {
  this.activeTargetIds = this.activeTargetIds.add(e);
 }
 gs(e) {
  this.activeTargetIds = this.activeTargetIds.delete(e);
 }
 Vs() {
  const e = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() };
  return JSON.stringify(e);
 }
}
class k4 {
 constructor() {
  (this.so = new eE()), (this.oo = {}), (this.onlineStateHandler = null), (this.sequenceNumberHandler = null);
 }
 addPendingMutation(e) {}
 updateMutationState(e, n, r) {}
 addLocalQueryTarget(e, n = !0) {
  return n && this.so.fs(e), this.oo[e] || "not-current";
 }
 updateQueryState(e, n, r) {
  this.oo[e] = n;
 }
 removeLocalQueryTarget(e) {
  this.so.gs(e);
 }
 isLocalQueryTarget(e) {
  return this.so.activeTargetIds.has(e);
 }
 clearQueryState(e) {
  delete this.oo[e];
 }
 getAllActiveQueryTargets() {
  return this.so.activeTargetIds;
 }
 isActiveQueryTarget(e) {
  return this.so.activeTargetIds.has(e);
 }
 start() {
  return (this.so = new eE()), Promise.resolve();
 }
 handleUserChange(e, n, r) {}
 setOnlineState(e) {}
 shutdown() {}
 writeSequenceNumber(e) {}
 notifyBundleLoaded(e) {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class b4 {
 _o(e) {}
 shutdown() {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class tE {
 constructor() {
  (this.ao = () => this.uo()), (this.co = () => this.lo()), (this.ho = []), this.Po();
 }
 _o(e) {
  this.ho.push(e);
 }
 shutdown() {
  window.removeEventListener("online", this.ao), window.removeEventListener("offline", this.co);
 }
 Po() {
  window.addEventListener("online", this.ao), window.addEventListener("offline", this.co);
 }
 uo() {
  Q("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
  for (const e of this.ho) e(0);
 }
 lo() {
  Q("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
  for (const e of this.ho) e(1);
 }
 static D() {
  return typeof window < "u" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
 }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Ju = null;
function $h() {
 return (
  Ju === null
   ? (Ju = (function () {
      return 268435456 + Math.round(2147483648 * Math.random());
     })())
   : Ju++,
  "0x" + Ju.toString(16)
 );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const N4 = {
 BatchGetDocuments: "batchGet",
 Commit: "commit",
 RunQuery: "runQuery",
 RunAggregationQuery: "runAggregationQuery",
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class x4 {
 constructor(e) {
  (this.Io = e.Io), (this.To = e.To);
 }
 Eo(e) {
  this.Ao = e;
 }
 Ro(e) {
  this.Vo = e;
 }
 mo(e) {
  this.fo = e;
 }
 onMessage(e) {
  this.po = e;
 }
 close() {
  this.To();
 }
 send(e) {
  this.Io(e);
 }
 yo() {
  this.Ao();
 }
 wo() {
  this.Vo();
 }
 So(e) {
  this.fo(e);
 }
 bo(e) {
  this.po(e);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const At = "WebChannelConnection";
class M4 extends class {
 constructor(n) {
  (this.databaseInfo = n), (this.databaseId = n.databaseId);
  const r = n.ssl ? "https" : "http",
   i = encodeURIComponent(this.databaseId.projectId),
   o = encodeURIComponent(this.databaseId.database);
  (this.Do = r + "://" + n.host),
   (this.vo = `projects/${i}/databases/${o}`),
   (this.Co = this.databaseId.database === "(default)" ? `project_id=${i}` : `project_id=${i}&database_id=${o}`);
 }
 get Fo() {
  return !1;
 }
 Mo(n, r, i, o, s) {
  const a = $h(),
   l = this.xo(n, r.toUriEncodedString());
  Q("RestConnection", `Sending RPC '${n}' ${a}:`, l, i);
  const u = { "google-cloud-resource-prefix": this.vo, "x-goog-request-params": this.Co };
  return (
   this.Oo(u, o, s),
   this.No(n, l, u, i).then(
    (h) => (Q("RestConnection", `Received RPC '${n}' ${a}: `, h), h),
    (h) => {
     throw (ks("RestConnection", `RPC '${n}' ${a} failed with error: `, h, "url: ", l, "request:", i), h);
    }
   )
  );
 }
 Lo(n, r, i, o, s, a) {
  return this.Mo(n, r, i, o, s);
 }
 Oo(n, r, i) {
  (n["X-Goog-Api-Client"] = (function () {
   return "gl-js/ fire/" + zs;
  })()),
   (n["Content-Type"] = "text/plain"),
   this.databaseInfo.appId && (n["X-Firebase-GMPID"] = this.databaseInfo.appId),
   r && r.headers.forEach((o, s) => (n[s] = o)),
   i && i.headers.forEach((o, s) => (n[s] = o));
 }
 xo(n, r) {
  const i = N4[n];
  return `${this.Do}/v1/${r}:${i}`;
 }
 terminate() {}
} {
 constructor(e) {
  super(e),
   (this.forceLongPolling = e.forceLongPolling),
   (this.autoDetectLongPolling = e.autoDetectLongPolling),
   (this.useFetchStreams = e.useFetchStreams),
   (this.longPollingOptions = e.longPollingOptions);
 }
 No(e, n, r, i) {
  const o = $h();
  return new Promise((s, a) => {
   const l = new AR();
   l.setWithCredentials(!0),
    l.listenOnce(CR.COMPLETE, () => {
     try {
      switch (l.getLastErrorCode()) {
       case Ic.NO_ERROR:
        const h = l.getResponseJson();
        Q(At, `XHR for RPC '${e}' ${o} received:`, JSON.stringify(h)), s(h);
        break;
       case Ic.TIMEOUT:
        Q(At, `RPC '${e}' ${o} timed out`), a(new J(B.DEADLINE_EXCEEDED, "Request time out"));
        break;
       case Ic.HTTP_ERROR:
        const p = l.getStatus();
        if ((Q(At, `RPC '${e}' ${o} failed with status:`, p, "response text:", l.getResponseText()), p > 0)) {
         let m = l.getResponseJson();
         Array.isArray(m) && (m = m[0]);
         const v = m == null ? void 0 : m.error;
         if (v && v.status && v.message) {
          const w = (function (A) {
           const T = A.toLowerCase().replace(/_/g, "-");
           return Object.values(B).indexOf(T) >= 0 ? T : B.UNKNOWN;
          })(v.status);
          a(new J(w, v.message));
         } else a(new J(B.UNKNOWN, "Server responded with status " + l.getStatus()));
        } else a(new J(B.UNAVAILABLE, "Connection failed."));
        break;
       default:
        ne();
      }
     } finally {
      Q(At, `RPC '${e}' ${o} completed.`);
     }
    });
   const u = JSON.stringify(i);
   Q(At, `RPC '${e}' ${o} sending request:`, i), l.send(n, "POST", u, r, 15);
  });
 }
 Bo(e, n, r) {
  const i = $h(),
   o = [this.Do, "/", "google.firestore.v1.Firestore", "/", e, "/channel"],
   s = kR(),
   a = PR(),
   l = {
    httpSessionIdParam: "gsessionid",
    initMessageHeaders: {},
    messageUrlParams: { database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}` },
    sendRawJson: !0,
    supportsCrossDomainXhr: !0,
    internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 },
    forceLongPolling: this.forceLongPolling,
    detectBufferingProxy: this.autoDetectLongPolling,
   },
   u = this.longPollingOptions.timeoutSeconds;
  u !== void 0 && (l.longPollingTimeout = Math.round(1e3 * u)),
   this.useFetchStreams && (l.useFetchStreams = !0),
   this.Oo(l.initMessageHeaders, n, r),
   (l.encodeInitMessageHeaders = !0);
  const h = o.join("");
  Q(At, `Creating RPC '${e}' stream ${i}: ${h}`, l);
  const p = s.createWebChannel(h, l);
  let m = !1,
   v = !1;
  const w = new x4({
    Io: (A) => {
     v
      ? Q(At, `Not sending because RPC '${e}' stream ${i} is closed:`, A)
      : (m || (Q(At, `Opening RPC '${e}' stream ${i} transport.`), p.open(), (m = !0)),
        Q(At, `RPC '${e}' stream ${i} sending:`, A),
        p.send(A));
    },
    To: () => p.close(),
   }),
   C = (A, T, _) => {
    A.listen(T, (E) => {
     try {
      _(E);
     } catch (N) {
      setTimeout(() => {
       throw N;
      }, 0);
     }
    });
   };
  return (
   C(p, xa.EventType.OPEN, () => {
    v || (Q(At, `RPC '${e}' stream ${i} transport opened.`), w.yo());
   }),
   C(p, xa.EventType.CLOSE, () => {
    v || ((v = !0), Q(At, `RPC '${e}' stream ${i} transport closed`), w.So());
   }),
   C(p, xa.EventType.ERROR, (A) => {
    v ||
     ((v = !0),
     ks(At, `RPC '${e}' stream ${i} transport errored:`, A),
     w.So(new J(B.UNAVAILABLE, "The operation could not be completed")));
   }),
   C(p, xa.EventType.MESSAGE, (A) => {
    var T;
    if (!v) {
     const _ = A.data[0];
     we(!!_);
     const E = _,
      N = E.error || ((T = E[0]) === null || T === void 0 ? void 0 : T.error);
     if (N) {
      Q(At, `RPC '${e}' stream ${i} received error:`, N);
      const M = N.status;
      let F = (function (R) {
        const k = Ze[R];
        if (k !== void 0) return rP(k);
       })(M),
       P = N.message;
      F === void 0 && ((F = B.INTERNAL), (P = "Unknown error status: " + M + " with message " + N.message)),
       (v = !0),
       w.So(new J(F, P)),
       p.close();
     } else Q(At, `RPC '${e}' stream ${i} received:`, _), w.bo(_);
    }
   }),
   C(a, RR.STAT_EVENT, (A) => {
    A.stat === dm.PROXY
     ? Q(At, `RPC '${e}' stream ${i} detected buffering proxy`)
     : A.stat === dm.NOPROXY && Q(At, `RPC '${e}' stream ${i} detected no buffering proxy`);
   }),
   setTimeout(() => {
    w.wo();
   }, 0),
   w
  );
 }
}
function Hh() {
 return typeof document < "u" ? document : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function yf(t) {
 return new qB(t, !0);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class gP {
 constructor(e, n, r = 1e3, i = 1.5, o = 6e4) {
  (this.ui = e),
   (this.timerId = n),
   (this.ko = r),
   (this.qo = i),
   (this.Qo = o),
   (this.Ko = 0),
   (this.$o = null),
   (this.Uo = Date.now()),
   this.reset();
 }
 reset() {
  this.Ko = 0;
 }
 Wo() {
  this.Ko = this.Qo;
 }
 Go(e) {
  this.cancel();
  const n = Math.floor(this.Ko + this.zo()),
   r = Math.max(0, Date.now() - this.Uo),
   i = Math.max(0, n - r);
  i > 0 &&
   Q(
    "ExponentialBackoff",
    `Backing off for ${i} ms (base delay: ${this.Ko} ms, delay with jitter: ${n} ms, last attempt: ${r} ms ago)`
   ),
   (this.$o = this.ui.enqueueAfterDelay(this.timerId, i, () => ((this.Uo = Date.now()), e()))),
   (this.Ko *= this.qo),
   this.Ko < this.ko && (this.Ko = this.ko),
   this.Ko > this.Qo && (this.Ko = this.Qo);
 }
 jo() {
  this.$o !== null && (this.$o.skipDelay(), (this.$o = null));
 }
 cancel() {
  this.$o !== null && (this.$o.cancel(), (this.$o = null));
 }
 zo() {
  return (Math.random() - 0.5) * this.Ko;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class yP {
 constructor(e, n, r, i, o, s, a, l) {
  (this.ui = e),
   (this.Ho = r),
   (this.Jo = i),
   (this.connection = o),
   (this.authCredentialsProvider = s),
   (this.appCheckCredentialsProvider = a),
   (this.listener = l),
   (this.state = 0),
   (this.Yo = 0),
   (this.Zo = null),
   (this.Xo = null),
   (this.stream = null),
   (this.e_ = 0),
   (this.t_ = new gP(e, n));
 }
 n_() {
  return this.state === 1 || this.state === 5 || this.r_();
 }
 r_() {
  return this.state === 2 || this.state === 3;
 }
 start() {
  (this.e_ = 0), this.state !== 4 ? this.auth() : this.i_();
 }
 async stop() {
  this.n_() && (await this.close(0));
 }
 s_() {
  (this.state = 0), this.t_.reset();
 }
 o_() {
  this.r_() && this.Zo === null && (this.Zo = this.ui.enqueueAfterDelay(this.Ho, 6e4, () => this.__()));
 }
 a_(e) {
  this.u_(), this.stream.send(e);
 }
 async __() {
  if (this.r_()) return this.close(0);
 }
 u_() {
  this.Zo && (this.Zo.cancel(), (this.Zo = null));
 }
 c_() {
  this.Xo && (this.Xo.cancel(), (this.Xo = null));
 }
 async close(e, n) {
  this.u_(),
   this.c_(),
   this.t_.cancel(),
   this.Yo++,
   e !== 4
    ? this.t_.reset()
    : n && n.code === B.RESOURCE_EXHAUSTED
      ? (xr(n.toString()), xr("Using maximum backoff delay to prevent overloading the backend."), this.t_.Wo())
      : n &&
        n.code === B.UNAUTHENTICATED &&
        this.state !== 3 &&
        (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()),
   this.stream !== null && (this.l_(), this.stream.close(), (this.stream = null)),
   (this.state = e),
   await this.listener.mo(n);
 }
 l_() {}
 auth() {
  this.state = 1;
  const e = this.h_(this.Yo),
   n = this.Yo;
  Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(
   ([r, i]) => {
    this.Yo === n && this.P_(r, i);
   },
   (r) => {
    e(() => {
     const i = new J(B.UNKNOWN, "Fetching auth token failed: " + r.message);
     return this.I_(i);
    });
   }
  );
 }
 P_(e, n) {
  const r = this.h_(this.Yo);
  (this.stream = this.T_(e, n)),
   this.stream.Eo(() => {
    r(() => this.listener.Eo());
   }),
   this.stream.Ro(() => {
    r(
     () => (
      (this.state = 2),
      (this.Xo = this.ui.enqueueAfterDelay(this.Jo, 1e4, () => (this.r_() && (this.state = 3), Promise.resolve()))),
      this.listener.Ro()
     )
    );
   }),
   this.stream.mo((i) => {
    r(() => this.I_(i));
   }),
   this.stream.onMessage((i) => {
    r(() => (++this.e_ == 1 ? this.E_(i) : this.onNext(i)));
   });
 }
 i_() {
  (this.state = 5),
   this.t_.Go(async () => {
    (this.state = 0), this.start();
   });
 }
 I_(e) {
  return Q("PersistentStream", `close with error: ${e}`), (this.stream = null), this.close(4, e);
 }
 h_(e) {
  return (n) => {
   this.ui.enqueueAndForget(() =>
    this.Yo === e
     ? n()
     : (Q("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve())
   );
  };
 }
}
class D4 extends yP {
 constructor(e, n, r, i, o, s) {
  super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", n, r, i, s),
   (this.serializer = o);
 }
 T_(e, n) {
  return this.connection.Bo("Listen", e, n);
 }
 E_(e) {
  return this.onNext(e);
 }
 onNext(e) {
  this.t_.reset();
  const n = WB(this.serializer, e),
   r = (function (o) {
    if (!("targetChange" in o)) return oe.min();
    const s = o.targetChange;
    return s.targetIds && s.targetIds.length ? oe.min() : s.readTime ? ar(s.readTime) : oe.min();
   })(e);
  return this.listener.d_(n, r);
 }
 A_(e) {
  const n = {};
  (n.database = wm(this.serializer)),
   (n.addTarget = (function (o, s) {
    let a;
    const l = s.target;
    if (
     ((a = mm(l) ? { documents: YB(o, l) } : { query: cP(o, l)._t }),
     (a.targetId = s.targetId),
     s.resumeToken.approximateByteSize() > 0)
    ) {
     a.resumeToken = sP(o, s.resumeToken);
     const u = ym(o, s.expectedCount);
     u !== null && (a.expectedCount = u);
    } else if (s.snapshotVersion.compareTo(oe.min()) > 0) {
     a.readTime = wd(o, s.snapshotVersion.toTimestamp());
     const u = ym(o, s.expectedCount);
     u !== null && (a.expectedCount = u);
    }
    return a;
   })(this.serializer, e));
  const r = jB(this.serializer, e);
  r && (n.labels = r), this.a_(n);
 }
 R_(e) {
  const n = {};
  (n.database = wm(this.serializer)), (n.removeTarget = e), this.a_(n);
 }
}
class L4 extends yP {
 constructor(e, n, r, i, o, s) {
  super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", n, r, i, s),
   (this.serializer = o);
 }
 get V_() {
  return this.e_ > 0;
 }
 start() {
  (this.lastStreamToken = void 0), super.start();
 }
 l_() {
  this.V_ && this.m_([]);
 }
 T_(e, n) {
  return this.connection.Bo("Write", e, n);
 }
 E_(e) {
  return (
   we(!!e.streamToken),
   (this.lastStreamToken = e.streamToken),
   we(!e.writeResults || e.writeResults.length === 0),
   this.listener.f_()
  );
 }
 onNext(e) {
  we(!!e.streamToken), (this.lastStreamToken = e.streamToken), this.t_.reset();
  const n = JB(e.writeResults, e.commitTime),
   r = ar(e.commitTime);
  return this.listener.g_(r, n);
 }
 p_() {
  const e = {};
  (e.database = wm(this.serializer)), this.a_(e);
 }
 m_(e) {
  const n = { streamToken: this.lastStreamToken, writes: e.map((r) => KB(this.serializer, r)) };
  this.a_(n);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class V4 extends class {} {
 constructor(e, n, r, i) {
  super(),
   (this.authCredentials = e),
   (this.appCheckCredentials = n),
   (this.connection = r),
   (this.serializer = i),
   (this.y_ = !1);
 }
 w_() {
  if (this.y_) throw new J(B.FAILED_PRECONDITION, "The client has already been terminated.");
 }
 Mo(e, n, r, i) {
  return (
   this.w_(),
   Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
    .then(([o, s]) => this.connection.Mo(e, vm(n, r), i, o, s))
    .catch((o) => {
     throw o.name === "FirebaseError"
      ? (o.code === B.UNAUTHENTICATED &&
         (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()),
        o)
      : new J(B.UNKNOWN, o.toString());
    })
  );
 }
 Lo(e, n, r, i, o) {
  return (
   this.w_(),
   Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
    .then(([s, a]) => this.connection.Lo(e, vm(n, r), i, s, a, o))
    .catch((s) => {
     throw s.name === "FirebaseError"
      ? (s.code === B.UNAUTHENTICATED &&
         (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()),
        s)
      : new J(B.UNKNOWN, s.toString());
    })
  );
 }
 terminate() {
  (this.y_ = !0), this.connection.terminate();
 }
}
class U4 {
 constructor(e, n) {
  (this.asyncQueue = e),
   (this.onlineStateHandler = n),
   (this.state = "Unknown"),
   (this.S_ = 0),
   (this.b_ = null),
   (this.D_ = !0);
 }
 v_() {
  this.S_ === 0 &&
   (this.C_("Unknown"),
   (this.b_ = this.asyncQueue.enqueueAfterDelay(
    "online_state_timeout",
    1e4,
    () => (
     (this.b_ = null), this.F_("Backend didn't respond within 10 seconds."), this.C_("Offline"), Promise.resolve()
    )
   )));
 }
 M_(e) {
  this.state === "Online"
   ? this.C_("Unknown")
   : (this.S_++,
     this.S_ >= 1 &&
      (this.x_(), this.F_(`Connection failed 1 times. Most recent error: ${e.toString()}`), this.C_("Offline")));
 }
 set(e) {
  this.x_(), (this.S_ = 0), e === "Online" && (this.D_ = !1), this.C_(e);
 }
 C_(e) {
  e !== this.state && ((this.state = e), this.onlineStateHandler(e));
 }
 F_(e) {
  const n = `Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
  this.D_ ? (xr(n), (this.D_ = !1)) : Q("OnlineStateTracker", n);
 }
 x_() {
  this.b_ !== null && (this.b_.cancel(), (this.b_ = null));
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class O4 {
 constructor(e, n, r, i, o) {
  (this.localStore = e),
   (this.datastore = n),
   (this.asyncQueue = r),
   (this.remoteSyncer = {}),
   (this.O_ = []),
   (this.N_ = new Map()),
   (this.L_ = new Set()),
   (this.B_ = []),
   (this.k_ = o),
   this.k_._o((s) => {
    r.enqueueAndForget(async () => {
     xo(this) &&
      (Q("RemoteStore", "Restarting streams for network reachability change."),
      await (async function (l) {
       const u = re(l);
       u.L_.add(4), await Zl(u), u.q_.set("Unknown"), u.L_.delete(4), await vf(u);
      })(this));
    });
   }),
   (this.q_ = new U4(r, i));
 }
}
async function vf(t) {
 if (xo(t)) for (const e of t.B_) await e(!0);
}
async function Zl(t) {
 for (const e of t.B_) await e(!1);
}
function vP(t, e) {
 const n = re(t);
 n.N_.has(e.targetId) || (n.N_.set(e.targetId, e), Dy(n) ? My(n) : Js(n).r_() && xy(n, e));
}
function Ny(t, e) {
 const n = re(t),
  r = Js(n);
 n.N_.delete(e), r.r_() && _P(n, e), n.N_.size === 0 && (r.r_() ? r.o_() : xo(n) && n.q_.set("Unknown"));
}
function xy(t, e) {
 if ((t.Q_.xe(e.targetId), e.resumeToken.approximateByteSize() > 0 || e.snapshotVersion.compareTo(oe.min()) > 0)) {
  const n = t.remoteSyncer.getRemoteKeysForTarget(e.targetId).size;
  e = e.withExpectedCount(n);
 }
 Js(t).A_(e);
}
function _P(t, e) {
 t.Q_.xe(e), Js(t).R_(e);
}
function My(t) {
 (t.Q_ = new FB({
  getRemoteKeysForTarget: (e) => t.remoteSyncer.getRemoteKeysForTarget(e),
  ot: (e) => t.N_.get(e) || null,
  tt: () => t.datastore.serializer.databaseId,
 })),
  Js(t).start(),
  t.q_.v_();
}
function Dy(t) {
 return xo(t) && !Js(t).n_() && t.N_.size > 0;
}
function xo(t) {
 return re(t).L_.size === 0;
}
function wP(t) {
 t.Q_ = void 0;
}
async function F4(t) {
 t.q_.set("Online");
}
async function B4(t) {
 t.N_.forEach((e, n) => {
  xy(t, e);
 });
}
async function $4(t, e) {
 wP(t), Dy(t) ? (t.q_.M_(e), My(t)) : t.q_.set("Unknown");
}
async function H4(t, e, n) {
 if ((t.q_.set("Online"), e instanceof oP && e.state === 2 && e.cause))
  try {
   await (async function (i, o) {
    const s = o.cause;
    for (const a of o.targetIds)
     i.N_.has(a) && (await i.remoteSyncer.rejectListen(a, s), i.N_.delete(a), i.Q_.removeTarget(a));
   })(t, e);
  } catch (r) {
   Q("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), r), await Ed(t, r);
  }
 else if ((e instanceof Cc ? t.Q_.Ke(e) : e instanceof iP ? t.Q_.He(e) : t.Q_.We(e), !n.isEqual(oe.min())))
  try {
   const r = await mP(t.localStore);
   n.compareTo(r) >= 0 &&
    (await (function (o, s) {
     const a = o.Q_.rt(s);
     return (
      a.targetChanges.forEach((l, u) => {
       if (l.resumeToken.approximateByteSize() > 0) {
        const h = o.N_.get(u);
        h && o.N_.set(u, h.withResumeToken(l.resumeToken, s));
       }
      }),
      a.targetMismatches.forEach((l, u) => {
       const h = o.N_.get(l);
       if (!h) return;
       o.N_.set(l, h.withResumeToken(_t.EMPTY_BYTE_STRING, h.snapshotVersion)), _P(o, l);
       const p = new di(h.target, l, u, h.sequenceNumber);
       xy(o, p);
      }),
      o.remoteSyncer.applyRemoteEvent(a)
     );
    })(t, n));
  } catch (r) {
   Q("RemoteStore", "Failed to raise snapshot:", r), await Ed(t, r);
  }
}
async function Ed(t, e, n) {
 if (!Ql(e)) throw e;
 t.L_.add(1),
  await Zl(t),
  t.q_.set("Offline"),
  n || (n = () => mP(t.localStore)),
  t.asyncQueue.enqueueRetryable(async () => {
   Q("RemoteStore", "Retrying IndexedDB access"), await n(), t.L_.delete(1), await vf(t);
  });
}
function EP(t, e) {
 return e().catch((n) => Ed(t, n, e));
}
async function _f(t) {
 const e = re(t),
  n = Pi(e);
 let r = e.O_.length > 0 ? e.O_[e.O_.length - 1].batchId : -1;
 for (; q4(e); )
  try {
   const i = await C4(e.localStore, r);
   if (i === null) {
    e.O_.length === 0 && n.o_();
    break;
   }
   (r = i.batchId), G4(e, i);
  } catch (i) {
   await Ed(e, i);
  }
 TP(e) && IP(e);
}
function q4(t) {
 return xo(t) && t.O_.length < 10;
}
function G4(t, e) {
 t.O_.push(e);
 const n = Pi(t);
 n.r_() && n.V_ && n.m_(e.mutations);
}
function TP(t) {
 return xo(t) && !Pi(t).n_() && t.O_.length > 0;
}
function IP(t) {
 Pi(t).start();
}
async function z4(t) {
 Pi(t).p_();
}
async function W4(t) {
 const e = Pi(t);
 for (const n of t.O_) e.m_(n.mutations);
}
async function K4(t, e, n) {
 const r = t.O_.shift(),
  i = Ay.from(r, e, n);
 await EP(t, () => t.remoteSyncer.applySuccessfulWrite(i)), await _f(t);
}
async function J4(t, e) {
 e &&
  Pi(t).V_ &&
  (await (async function (r, i) {
   if (
    (function (s) {
     return VB(s) && s !== B.ABORTED;
    })(i.code)
   ) {
    const o = r.O_.shift();
    Pi(r).s_(), await EP(r, () => r.remoteSyncer.rejectFailedWrite(o.batchId, i)), await _f(r);
   }
  })(t, e)),
  TP(t) && IP(t);
}
async function nE(t, e) {
 const n = re(t);
 n.asyncQueue.verifyOperationInProgress(), Q("RemoteStore", "RemoteStore received new credentials");
 const r = xo(n);
 n.L_.add(3),
  await Zl(n),
  r && n.q_.set("Unknown"),
  await n.remoteSyncer.handleCredentialChange(e),
  n.L_.delete(3),
  await vf(n);
}
async function Y4(t, e) {
 const n = re(t);
 e ? (n.L_.delete(2), await vf(n)) : e || (n.L_.add(2), await Zl(n), n.q_.set("Unknown"));
}
function Js(t) {
 return (
  t.K_ ||
   ((t.K_ = (function (n, r, i) {
    const o = re(n);
    return o.w_(), new D4(r, o.connection, o.authCredentials, o.appCheckCredentials, o.serializer, i);
   })(t.datastore, t.asyncQueue, {
    Eo: F4.bind(null, t),
    Ro: B4.bind(null, t),
    mo: $4.bind(null, t),
    d_: H4.bind(null, t),
   })),
   t.B_.push(async (e) => {
    e ? (t.K_.s_(), Dy(t) ? My(t) : t.q_.set("Unknown")) : (await t.K_.stop(), wP(t));
   })),
  t.K_
 );
}
function Pi(t) {
 return (
  t.U_ ||
   ((t.U_ = (function (n, r, i) {
    const o = re(n);
    return o.w_(), new L4(r, o.connection, o.authCredentials, o.appCheckCredentials, o.serializer, i);
   })(t.datastore, t.asyncQueue, {
    Eo: () => Promise.resolve(),
    Ro: z4.bind(null, t),
    mo: J4.bind(null, t),
    f_: W4.bind(null, t),
    g_: K4.bind(null, t),
   })),
   t.B_.push(async (e) => {
    e
     ? (t.U_.s_(), await _f(t))
     : (await t.U_.stop(),
       t.O_.length > 0 && (Q("RemoteStore", `Stopping write stream with ${t.O_.length} pending writes`), (t.O_ = [])));
   })),
  t.U_
 );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ly {
 constructor(e, n, r, i, o) {
  (this.asyncQueue = e),
   (this.timerId = n),
   (this.targetTimeMs = r),
   (this.op = i),
   (this.removalCallback = o),
   (this.deferred = new or()),
   (this.then = this.deferred.promise.then.bind(this.deferred.promise)),
   this.deferred.promise.catch((s) => {});
 }
 get promise() {
  return this.deferred.promise;
 }
 static createAndSchedule(e, n, r, i, o) {
  const s = Date.now() + r,
   a = new Ly(e, n, s, i, o);
  return a.start(r), a;
 }
 start(e) {
  this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e);
 }
 skipDelay() {
  return this.handleDelayElapsed();
 }
 cancel(e) {
  this.timerHandle !== null &&
   (this.clearTimeout(), this.deferred.reject(new J(B.CANCELLED, "Operation cancelled" + (e ? ": " + e : ""))));
 }
 handleDelayElapsed() {
  this.asyncQueue.enqueueAndForget(() =>
   this.timerHandle !== null
    ? (this.clearTimeout(), this.op().then((e) => this.deferred.resolve(e)))
    : Promise.resolve()
  );
 }
 clearTimeout() {
  this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), (this.timerHandle = null));
 }
}
function Vy(t, e) {
 if ((xr("AsyncQueue", `${e}: ${t}`), Ql(t))) return new J(B.UNAVAILABLE, `${e}: ${t}`);
 throw t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class gs {
 constructor(e) {
  (this.comparator = e ? (n, r) => e(n, r) || j.comparator(n.key, r.key) : (n, r) => j.comparator(n.key, r.key)),
   (this.keyedMap = Ma()),
   (this.sortedSet = new Be(this.comparator));
 }
 static emptySet(e) {
  return new gs(e.comparator);
 }
 has(e) {
  return this.keyedMap.get(e) != null;
 }
 get(e) {
  return this.keyedMap.get(e);
 }
 first() {
  return this.sortedSet.minKey();
 }
 last() {
  return this.sortedSet.maxKey();
 }
 isEmpty() {
  return this.sortedSet.isEmpty();
 }
 indexOf(e) {
  const n = this.keyedMap.get(e);
  return n ? this.sortedSet.indexOf(n) : -1;
 }
 get size() {
  return this.sortedSet.size;
 }
 forEach(e) {
  this.sortedSet.inorderTraversal((n, r) => (e(n), !1));
 }
 add(e) {
  const n = this.delete(e.key);
  return n.copy(n.keyedMap.insert(e.key, e), n.sortedSet.insert(e, null));
 }
 delete(e) {
  const n = this.get(e);
  return n ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(n)) : this;
 }
 isEqual(e) {
  if (!(e instanceof gs) || this.size !== e.size) return !1;
  const n = this.sortedSet.getIterator(),
   r = e.sortedSet.getIterator();
  for (; n.hasNext(); ) {
   const i = n.getNext().key,
    o = r.getNext().key;
   if (!i.isEqual(o)) return !1;
  }
  return !0;
 }
 toString() {
  const e = [];
  return (
   this.forEach((n) => {
    e.push(n.toString());
   }),
   e.length === 0
    ? "DocumentSet ()"
    : `DocumentSet (
  ` +
      e.join(`  
`) +
      `
)`
  );
 }
 copy(e, n) {
  const r = new gs();
  return (r.comparator = this.comparator), (r.keyedMap = e), (r.sortedSet = n), r;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class rE {
 constructor() {
  this.W_ = new Be(j.comparator);
 }
 track(e) {
  const n = e.doc.key,
   r = this.W_.get(n);
  r
   ? e.type !== 0 && r.type === 3
     ? (this.W_ = this.W_.insert(n, e))
     : e.type === 3 && r.type !== 1
       ? (this.W_ = this.W_.insert(n, { type: r.type, doc: e.doc }))
       : e.type === 2 && r.type === 2
         ? (this.W_ = this.W_.insert(n, { type: 2, doc: e.doc }))
         : e.type === 2 && r.type === 0
           ? (this.W_ = this.W_.insert(n, { type: 0, doc: e.doc }))
           : e.type === 1 && r.type === 0
             ? (this.W_ = this.W_.remove(n))
             : e.type === 1 && r.type === 2
               ? (this.W_ = this.W_.insert(n, { type: 1, doc: r.doc }))
               : e.type === 0 && r.type === 1
                 ? (this.W_ = this.W_.insert(n, { type: 2, doc: e.doc }))
                 : ne()
   : (this.W_ = this.W_.insert(n, e));
 }
 G_() {
  const e = [];
  return (
   this.W_.inorderTraversal((n, r) => {
    e.push(r);
   }),
   e
  );
 }
}
class Ds {
 constructor(e, n, r, i, o, s, a, l, u) {
  (this.query = e),
   (this.docs = n),
   (this.oldDocs = r),
   (this.docChanges = i),
   (this.mutatedKeys = o),
   (this.fromCache = s),
   (this.syncStateChanged = a),
   (this.excludesMetadataChanges = l),
   (this.hasCachedResults = u);
 }
 static fromInitialDocuments(e, n, r, i, o) {
  const s = [];
  return (
   n.forEach((a) => {
    s.push({ type: 0, doc: a });
   }),
   new Ds(e, n, gs.emptySet(n), s, r, i, !0, !1, o)
  );
 }
 get hasPendingWrites() {
  return !this.mutatedKeys.isEmpty();
 }
 isEqual(e) {
  if (
   !(
    this.fromCache === e.fromCache &&
    this.hasCachedResults === e.hasCachedResults &&
    this.syncStateChanged === e.syncStateChanged &&
    this.mutatedKeys.isEqual(e.mutatedKeys) &&
    df(this.query, e.query) &&
    this.docs.isEqual(e.docs) &&
    this.oldDocs.isEqual(e.oldDocs)
   )
  )
   return !1;
  const n = this.docChanges,
   r = e.docChanges;
  if (n.length !== r.length) return !1;
  for (let i = 0; i < n.length; i++) if (n[i].type !== r[i].type || !n[i].doc.isEqual(r[i].doc)) return !1;
  return !0;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Q4 {
 constructor() {
  (this.z_ = void 0), (this.j_ = []);
 }
 H_() {
  return this.j_.some((e) => e.J_());
 }
}
class X4 {
 constructor() {
  (this.queries = iE()), (this.onlineState = "Unknown"), (this.Y_ = new Set());
 }
 terminate() {
  (function (n, r) {
   const i = re(n),
    o = i.queries;
   (i.queries = iE()),
    o.forEach((s, a) => {
     for (const l of a.j_) l.onError(r);
    });
  })(this, new J(B.ABORTED, "Firestore shutting down"));
 }
}
function iE() {
 return new Ks((t) => qR(t), df);
}
async function Uy(t, e) {
 const n = re(t);
 let r = 3;
 const i = e.query;
 let o = n.queries.get(i);
 o ? !o.H_() && e.J_() && (r = 2) : ((o = new Q4()), (r = e.J_() ? 0 : 1));
 try {
  switch (r) {
   case 0:
    o.z_ = await n.onListen(i, !0);
    break;
   case 1:
    o.z_ = await n.onListen(i, !1);
    break;
   case 2:
    await n.onFirstRemoteStoreListen(i);
  }
 } catch (s) {
  const a = Vy(s, `Initialization of query '${Ho(e.query)}' failed`);
  return void e.onError(a);
 }
 n.queries.set(i, o), o.j_.push(e), e.Z_(n.onlineState), o.z_ && e.X_(o.z_) && Fy(n);
}
async function Oy(t, e) {
 const n = re(t),
  r = e.query;
 let i = 3;
 const o = n.queries.get(r);
 if (o) {
  const s = o.j_.indexOf(e);
  s >= 0 && (o.j_.splice(s, 1), o.j_.length === 0 ? (i = e.J_() ? 0 : 1) : !o.H_() && e.J_() && (i = 2));
 }
 switch (i) {
  case 0:
   return n.queries.delete(r), n.onUnlisten(r, !0);
  case 1:
   return n.queries.delete(r), n.onUnlisten(r, !1);
  case 2:
   return n.onLastRemoteStoreUnlisten(r);
  default:
   return;
 }
}
function j4(t, e) {
 const n = re(t);
 let r = !1;
 for (const i of e) {
  const o = i.query,
   s = n.queries.get(o);
  if (s) {
   for (const a of s.j_) a.X_(i) && (r = !0);
   s.z_ = i;
  }
 }
 r && Fy(n);
}
function Z4(t, e, n) {
 const r = re(t),
  i = r.queries.get(e);
 if (i) for (const o of i.j_) o.onError(n);
 r.queries.delete(e);
}
function Fy(t) {
 t.Y_.forEach((e) => {
  e.next();
 });
}
var Tm, oE;
((oE = Tm || (Tm = {})).ea = "default"), (oE.Cache = "cache");
class By {
 constructor(e, n, r) {
  (this.query = e),
   (this.ta = n),
   (this.na = !1),
   (this.ra = null),
   (this.onlineState = "Unknown"),
   (this.options = r || {});
 }
 X_(e) {
  if (!this.options.includeMetadataChanges) {
   const r = [];
   for (const i of e.docChanges) i.type !== 3 && r.push(i);
   e = new Ds(e.query, e.docs, e.oldDocs, r, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults);
  }
  let n = !1;
  return (
   this.na ? this.ia(e) && (this.ta.next(e), (n = !0)) : this.sa(e, this.onlineState) && (this.oa(e), (n = !0)),
   (this.ra = e),
   n
  );
 }
 onError(e) {
  this.ta.error(e);
 }
 Z_(e) {
  this.onlineState = e;
  let n = !1;
  return this.ra && !this.na && this.sa(this.ra, e) && (this.oa(this.ra), (n = !0)), n;
 }
 sa(e, n) {
  if (!e.fromCache || !this.J_()) return !0;
  const r = n !== "Offline";
  return (!this.options._a || !r) && (!e.docs.isEmpty() || e.hasCachedResults || n === "Offline");
 }
 ia(e) {
  if (e.docChanges.length > 0) return !0;
  const n = this.ra && this.ra.hasPendingWrites !== e.hasPendingWrites;
  return !(!e.syncStateChanged && !n) && this.options.includeMetadataChanges === !0;
 }
 oa(e) {
  (e = Ds.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults)),
   (this.na = !0),
   this.ta.next(e);
 }
 J_() {
  return this.options.source !== Tm.Cache;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class SP {
 constructor(e) {
  this.key = e;
 }
}
class AP {
 constructor(e) {
  this.key = e;
 }
}
class e$ {
 constructor(e, n) {
  (this.query = e),
   (this.Ta = n),
   (this.Ea = null),
   (this.hasCachedResults = !1),
   (this.current = !1),
   (this.da = ce()),
   (this.mutatedKeys = ce()),
   (this.Aa = GR(e)),
   (this.Ra = new gs(this.Aa));
 }
 get Va() {
  return this.Ta;
 }
 ma(e, n) {
  const r = n ? n.fa : new rE(),
   i = n ? n.Ra : this.Ra;
  let o = n ? n.mutatedKeys : this.mutatedKeys,
   s = i,
   a = !1;
  const l = this.query.limitType === "F" && i.size === this.query.limit ? i.last() : null,
   u = this.query.limitType === "L" && i.size === this.query.limit ? i.first() : null;
  if (
   (e.inorderTraversal((h, p) => {
    const m = i.get(h),
     v = ff(this.query, p) ? p : null,
     w = !!m && this.mutatedKeys.has(m.key),
     C = !!v && (v.hasLocalMutations || (this.mutatedKeys.has(v.key) && v.hasCommittedMutations));
    let A = !1;
    m && v
     ? m.data.isEqual(v.data)
       ? w !== C && (r.track({ type: 3, doc: v }), (A = !0))
       : this.ga(m, v) ||
         (r.track({ type: 2, doc: v }), (A = !0), ((l && this.Aa(v, l) > 0) || (u && this.Aa(v, u) < 0)) && (a = !0))
     : !m && v
       ? (r.track({ type: 0, doc: v }), (A = !0))
       : m && !v && (r.track({ type: 1, doc: m }), (A = !0), (l || u) && (a = !0)),
     A && (v ? ((s = s.add(v)), (o = C ? o.add(h) : o.delete(h))) : ((s = s.delete(h)), (o = o.delete(h))));
   }),
   this.query.limit !== null)
  )
   for (; s.size > this.query.limit; ) {
    const h = this.query.limitType === "F" ? s.last() : s.first();
    (s = s.delete(h.key)), (o = o.delete(h.key)), r.track({ type: 1, doc: h });
   }
  return { Ra: s, fa: r, ns: a, mutatedKeys: o };
 }
 ga(e, n) {
  return e.hasLocalMutations && n.hasCommittedMutations && !n.hasLocalMutations;
 }
 applyChanges(e, n, r, i) {
  const o = this.Ra;
  (this.Ra = e.Ra), (this.mutatedKeys = e.mutatedKeys);
  const s = e.fa.G_();
  s.sort(
   (h, p) =>
    (function (v, w) {
     const C = (A) => {
      switch (A) {
       case 0:
        return 1;
       case 2:
       case 3:
        return 2;
       case 1:
        return 0;
       default:
        return ne();
      }
     };
     return C(v) - C(w);
    })(h.type, p.type) || this.Aa(h.doc, p.doc)
  ),
   this.pa(r),
   (i = i != null && i);
  const a = n && !i ? this.ya() : [],
   l = this.da.size === 0 && this.current && !i ? 1 : 0,
   u = l !== this.Ea;
  return (
   (this.Ea = l),
   s.length !== 0 || u
    ? {
       snapshot: new Ds(
        this.query,
        e.Ra,
        o,
        s,
        e.mutatedKeys,
        l === 0,
        u,
        !1,
        !!r && r.resumeToken.approximateByteSize() > 0
       ),
       wa: a,
      }
    : { wa: a }
  );
 }
 Z_(e) {
  return this.current && e === "Offline"
   ? ((this.current = !1), this.applyChanges({ Ra: this.Ra, fa: new rE(), mutatedKeys: this.mutatedKeys, ns: !1 }, !1))
   : { wa: [] };
 }
 Sa(e) {
  return !this.Ta.has(e) && !!this.Ra.has(e) && !this.Ra.get(e).hasLocalMutations;
 }
 pa(e) {
  e &&
   (e.addedDocuments.forEach((n) => (this.Ta = this.Ta.add(n))),
   e.modifiedDocuments.forEach((n) => {}),
   e.removedDocuments.forEach((n) => (this.Ta = this.Ta.delete(n))),
   (this.current = e.current));
 }
 ya() {
  if (!this.current) return [];
  const e = this.da;
  (this.da = ce()),
   this.Ra.forEach((r) => {
    this.Sa(r.key) && (this.da = this.da.add(r.key));
   });
  const n = [];
  return (
   e.forEach((r) => {
    this.da.has(r) || n.push(new AP(r));
   }),
   this.da.forEach((r) => {
    e.has(r) || n.push(new SP(r));
   }),
   n
  );
 }
 ba(e) {
  (this.Ta = e.Ts), (this.da = ce());
  const n = this.ma(e.documents);
  return this.applyChanges(n, !0);
 }
 Da() {
  return Ds.fromInitialDocuments(this.query, this.Ra, this.mutatedKeys, this.Ea === 0, this.hasCachedResults);
 }
}
class t$ {
 constructor(e, n, r) {
  (this.query = e), (this.targetId = n), (this.view = r);
 }
}
class n$ {
 constructor(e) {
  (this.key = e), (this.va = !1);
 }
}
class r$ {
 constructor(e, n, r, i, o, s) {
  (this.localStore = e),
   (this.remoteStore = n),
   (this.eventManager = r),
   (this.sharedClientState = i),
   (this.currentUser = o),
   (this.maxConcurrentLimboResolutions = s),
   (this.Ca = {}),
   (this.Fa = new Ks((a) => qR(a), df)),
   (this.Ma = new Map()),
   (this.xa = new Set()),
   (this.Oa = new Be(j.comparator)),
   (this.Na = new Map()),
   (this.La = new Py()),
   (this.Ba = {}),
   (this.ka = new Map()),
   (this.qa = Ms.kn()),
   (this.onlineState = "Unknown"),
   (this.Qa = void 0);
 }
 get isPrimaryClient() {
  return this.Qa === !0;
 }
}
async function i$(t, e, n = !0) {
 const r = NP(t);
 let i;
 const o = r.Fa.get(e);
 return o ? (r.sharedClientState.addLocalQueryTarget(o.targetId), (i = o.view.Da())) : (i = await CP(r, e, n, !0)), i;
}
async function o$(t, e) {
 const n = NP(t);
 await CP(n, e, !0, !1);
}
async function CP(t, e, n, r) {
 const i = await R4(t.localStore, sr(e)),
  o = i.targetId,
  s = t.sharedClientState.addLocalQueryTarget(o, n);
 let a;
 return r && (a = await s$(t, e, o, s === "current", i.resumeToken)), t.isPrimaryClient && n && vP(t.remoteStore, i), a;
}
async function s$(t, e, n, r, i) {
 t.Ka = (p, m, v) =>
  (async function (C, A, T, _) {
   let E = A.view.ma(T);
   E.ns && (E = await Z0(C.localStore, A.query, !1).then(({ documents: P }) => A.view.ma(P, E)));
   const N = _ && _.targetChanges.get(A.targetId),
    M = _ && _.targetMismatches.get(A.targetId) != null,
    F = A.view.applyChanges(E, C.isPrimaryClient, N, M);
   return aE(C, A.targetId, F.wa), F.snapshot;
  })(t, p, m, v);
 const o = await Z0(t.localStore, e, !0),
  s = new e$(e, o.Ts),
  a = s.ma(o.documents),
  l = jl.createSynthesizedTargetChangeForCurrentChange(n, r && t.onlineState !== "Offline", i),
  u = s.applyChanges(a, t.isPrimaryClient, l);
 aE(t, n, u.wa);
 const h = new t$(e, n, s);
 return t.Fa.set(e, h), t.Ma.has(n) ? t.Ma.get(n).push(e) : t.Ma.set(n, [e]), u.snapshot;
}
async function a$(t, e, n) {
 const r = re(t),
  i = r.Fa.get(e),
  o = r.Ma.get(i.targetId);
 if (o.length > 1)
  return (
   r.Ma.set(
    i.targetId,
    o.filter((s) => !df(s, e))
   ),
   void r.Fa.delete(e)
  );
 r.isPrimaryClient
  ? (r.sharedClientState.removeLocalQueryTarget(i.targetId),
    r.sharedClientState.isActiveQueryTarget(i.targetId) ||
     (await Em(r.localStore, i.targetId, !1)
      .then(() => {
       r.sharedClientState.clearQueryState(i.targetId), n && Ny(r.remoteStore, i.targetId), Im(r, i.targetId);
      })
      .catch(Yl)))
  : (Im(r, i.targetId), await Em(r.localStore, i.targetId, !0));
}
async function l$(t, e) {
 const n = re(t),
  r = n.Fa.get(e),
  i = n.Ma.get(r.targetId);
 n.isPrimaryClient &&
  i.length === 1 &&
  (n.sharedClientState.removeLocalQueryTarget(r.targetId), Ny(n.remoteStore, r.targetId));
}
async function u$(t, e, n) {
 const r = g$(t);
 try {
  const i = await (function (s, a) {
   const l = re(s),
    u = st.now(),
    h = a.reduce((v, w) => v.add(w.key), ce());
   let p, m;
   return l.persistence
    .runTransaction("Locally write mutations", "readwrite", (v) => {
     let w = Mr(),
      C = ce();
     return l.cs
      .getEntries(v, h)
      .next((A) => {
       (w = A),
        w.forEach((T, _) => {
         _.isValidDocument() || (C = C.add(T));
        });
      })
      .next(() => l.localDocuments.getOverlayedDocuments(v, w))
      .next((A) => {
       p = A;
       const T = [];
       for (const _ of a) {
        const E = bB(_, p.get(_.key).overlayedDocument);
        E != null && T.push(new Li(_.key, E, DR(E.value.mapValue), Ht.exists(!0)));
       }
       return l.mutationQueue.addMutationBatch(v, u, T, a);
      })
      .next((A) => {
       m = A;
       const T = A.applyToLocalDocumentSet(p, C);
       return l.documentOverlayCache.saveOverlays(v, A.batchId, T);
      });
    })
    .then(() => ({ batchId: m.batchId, changes: WR(p) }));
  })(r.localStore, e);
  r.sharedClientState.addPendingMutation(i.batchId),
   (function (s, a, l) {
    let u = s.Ba[s.currentUser.toKey()];
    u || (u = new Be(ge)), (u = u.insert(a, l)), (s.Ba[s.currentUser.toKey()] = u);
   })(r, i.batchId, n),
   await eu(r, i.changes),
   await _f(r.remoteStore);
 } catch (i) {
  const o = Vy(i, "Failed to persist write");
  n.reject(o);
 }
}
async function RP(t, e) {
 const n = re(t);
 try {
  const r = await S4(n.localStore, e);
  e.targetChanges.forEach((i, o) => {
   const s = n.Na.get(o);
   s &&
    (we(i.addedDocuments.size + i.modifiedDocuments.size + i.removedDocuments.size <= 1),
    i.addedDocuments.size > 0
     ? (s.va = !0)
     : i.modifiedDocuments.size > 0
       ? we(s.va)
       : i.removedDocuments.size > 0 && (we(s.va), (s.va = !1)));
  }),
   await eu(n, r, e);
 } catch (r) {
  await Yl(r);
 }
}
function sE(t, e, n) {
 const r = re(t);
 if ((r.isPrimaryClient && n === 0) || (!r.isPrimaryClient && n === 1)) {
  const i = [];
  r.Fa.forEach((o, s) => {
   const a = s.view.Z_(e);
   a.snapshot && i.push(a.snapshot);
  }),
   (function (s, a) {
    const l = re(s);
    l.onlineState = a;
    let u = !1;
    l.queries.forEach((h, p) => {
     for (const m of p.j_) m.Z_(a) && (u = !0);
    }),
     u && Fy(l);
   })(r.eventManager, e),
   i.length && r.Ca.d_(i),
   (r.onlineState = e),
   r.isPrimaryClient && r.sharedClientState.setOnlineState(e);
 }
}
async function c$(t, e, n) {
 const r = re(t);
 r.sharedClientState.updateQueryState(e, "rejected", n);
 const i = r.Na.get(e),
  o = i && i.key;
 if (o) {
  let s = new Be(j.comparator);
  s = s.insert(o, kt.newNoDocument(o, oe.min()));
  const a = ce().add(o),
   l = new gf(oe.min(), new Map(), new Be(ge), s, a);
  await RP(r, l), (r.Oa = r.Oa.remove(o)), r.Na.delete(e), $y(r);
 } else
  await Em(r.localStore, e, !1)
   .then(() => Im(r, e, n))
   .catch(Yl);
}
async function d$(t, e) {
 const n = re(t),
  r = e.batch.batchId;
 try {
  const i = await I4(n.localStore, e);
  kP(n, r, null), PP(n, r), n.sharedClientState.updateMutationState(r, "acknowledged"), await eu(n, i);
 } catch (i) {
  await Yl(i);
 }
}
async function f$(t, e, n) {
 const r = re(t);
 try {
  const i = await (function (s, a) {
   const l = re(s);
   return l.persistence.runTransaction("Reject batch", "readwrite-primary", (u) => {
    let h;
    return l.mutationQueue
     .lookupMutationBatch(u, a)
     .next((p) => (we(p !== null), (h = p.keys()), l.mutationQueue.removeMutationBatch(u, p)))
     .next(() => l.mutationQueue.performConsistencyCheck(u))
     .next(() => l.documentOverlayCache.removeOverlaysForBatchId(u, h, a))
     .next(() => l.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(u, h))
     .next(() => l.localDocuments.getDocuments(u, h));
   });
  })(r.localStore, e);
  kP(r, e, n), PP(r, e), r.sharedClientState.updateMutationState(e, "rejected", n), await eu(r, i);
 } catch (i) {
  await Yl(i);
 }
}
function PP(t, e) {
 (t.ka.get(e) || []).forEach((n) => {
  n.resolve();
 }),
  t.ka.delete(e);
}
function kP(t, e, n) {
 const r = re(t);
 let i = r.Ba[r.currentUser.toKey()];
 if (i) {
  const o = i.get(e);
  o && (n ? o.reject(n) : o.resolve(), (i = i.remove(e))), (r.Ba[r.currentUser.toKey()] = i);
 }
}
function Im(t, e, n = null) {
 t.sharedClientState.removeLocalQueryTarget(e);
 for (const r of t.Ma.get(e)) t.Fa.delete(r), n && t.Ca.$a(r, n);
 t.Ma.delete(e),
  t.isPrimaryClient &&
   t.La.gr(e).forEach((r) => {
    t.La.containsKey(r) || bP(t, r);
   });
}
function bP(t, e) {
 t.xa.delete(e.path.canonicalString());
 const n = t.Oa.get(e);
 n !== null && (Ny(t.remoteStore, n), (t.Oa = t.Oa.remove(e)), t.Na.delete(n), $y(t));
}
function aE(t, e, n) {
 for (const r of n)
  r instanceof SP
   ? (t.La.addReference(r.key, e), h$(t, r))
   : r instanceof AP
     ? (Q("SyncEngine", "Document no longer in limbo: " + r.key),
       t.La.removeReference(r.key, e),
       t.La.containsKey(r.key) || bP(t, r.key))
     : ne();
}
function h$(t, e) {
 const n = e.key,
  r = n.path.canonicalString();
 t.Oa.get(n) || t.xa.has(r) || (Q("SyncEngine", "New document in limbo: " + n), t.xa.add(r), $y(t));
}
function $y(t) {
 for (; t.xa.size > 0 && t.Oa.size < t.maxConcurrentLimboResolutions; ) {
  const e = t.xa.values().next().value;
  t.xa.delete(e);
  const n = new j(Ne.fromString(e)),
   r = t.qa.next();
  t.Na.set(r, new n$(n)),
   (t.Oa = t.Oa.insert(n, r)),
   vP(t.remoteStore, new di(sr(cf(n.path)), r, "TargetPurposeLimboResolution", vy.oe));
 }
}
async function eu(t, e, n) {
 const r = re(t),
  i = [],
  o = [],
  s = [];
 r.Fa.isEmpty() ||
  (r.Fa.forEach((a, l) => {
   s.push(
    r.Ka(l, e, n).then((u) => {
     var h;
     if ((u || n) && r.isPrimaryClient) {
      const p = u
       ? !u.fromCache
       : (h = n == null ? void 0 : n.targetChanges.get(l.targetId)) === null || h === void 0
         ? void 0
         : h.current;
      r.sharedClientState.updateQueryState(l.targetId, p ? "current" : "not-current");
     }
     if (u) {
      i.push(u);
      const p = by.Wi(l.targetId, u);
      o.push(p);
     }
    })
   );
  }),
  await Promise.all(s),
  r.Ca.d_(i),
  await (async function (l, u) {
   const h = re(l);
   try {
    await h.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (p) =>
     $.forEach(u, (m) =>
      $.forEach(m.$i, (v) => h.persistence.referenceDelegate.addReference(p, m.targetId, v)).next(() =>
       $.forEach(m.Ui, (v) => h.persistence.referenceDelegate.removeReference(p, m.targetId, v))
      )
     )
    );
   } catch (p) {
    if (!Ql(p)) throw p;
    Q("LocalStore", "Failed to update sequence numbers: " + p);
   }
   for (const p of u) {
    const m = p.targetId;
    if (!p.fromCache) {
     const v = h.os.get(m),
      w = v.snapshotVersion,
      C = v.withLastLimboFreeSnapshotVersion(w);
     h.os = h.os.insert(m, C);
    }
   }
  })(r.localStore, o));
}
async function p$(t, e) {
 const n = re(t);
 if (!n.currentUser.isEqual(e)) {
  Q("SyncEngine", "User change. New user:", e.toKey());
  const r = await pP(n.localStore, e);
  (n.currentUser = e),
   (function (o, s) {
    o.ka.forEach((a) => {
     a.forEach((l) => {
      l.reject(new J(B.CANCELLED, s));
     });
    }),
     o.ka.clear();
   })(n, "'waitForPendingWrites' promise is rejected due to a user change."),
   n.sharedClientState.handleUserChange(e, r.removedBatchIds, r.addedBatchIds),
   await eu(n, r.hs);
 }
}
function m$(t, e) {
 const n = re(t),
  r = n.Na.get(e);
 if (r && r.va) return ce().add(r.key);
 {
  let i = ce();
  const o = n.Ma.get(e);
  if (!o) return i;
  for (const s of o) {
   const a = n.Fa.get(s);
   i = i.unionWith(a.view.Va);
  }
  return i;
 }
}
function NP(t) {
 const e = re(t);
 return (
  (e.remoteStore.remoteSyncer.applyRemoteEvent = RP.bind(null, e)),
  (e.remoteStore.remoteSyncer.getRemoteKeysForTarget = m$.bind(null, e)),
  (e.remoteStore.remoteSyncer.rejectListen = c$.bind(null, e)),
  (e.Ca.d_ = j4.bind(null, e.eventManager)),
  (e.Ca.$a = Z4.bind(null, e.eventManager)),
  e
 );
}
function g$(t) {
 const e = re(t);
 return (
  (e.remoteStore.remoteSyncer.applySuccessfulWrite = d$.bind(null, e)),
  (e.remoteStore.remoteSyncer.rejectFailedWrite = f$.bind(null, e)),
  e
 );
}
class Td {
 constructor() {
  (this.kind = "memory"), (this.synchronizeTabs = !1);
 }
 async initialize(e) {
  (this.serializer = yf(e.databaseInfo.databaseId)),
   (this.sharedClientState = this.Wa(e)),
   (this.persistence = this.Ga(e)),
   await this.persistence.start(),
   (this.localStore = this.za(e)),
   (this.gcScheduler = this.ja(e, this.localStore)),
   (this.indexBackfillerScheduler = this.Ha(e, this.localStore));
 }
 ja(e, n) {
  return null;
 }
 Ha(e, n) {
  return null;
 }
 za(e) {
  return T4(this.persistence, new w4(), e.initialUser, this.serializer);
 }
 Ga(e) {
  return new y4(ky.Zr, this.serializer);
 }
 Wa(e) {
  return new k4();
 }
 async terminate() {
  var e, n;
  (e = this.gcScheduler) === null || e === void 0 || e.stop(),
   (n = this.indexBackfillerScheduler) === null || n === void 0 || n.stop(),
   this.sharedClientState.shutdown(),
   await this.persistence.shutdown();
 }
}
Td.provider = { build: () => new Td() };
class Sm {
 async initialize(e, n) {
  this.localStore ||
   ((this.localStore = e.localStore),
   (this.sharedClientState = e.sharedClientState),
   (this.datastore = this.createDatastore(n)),
   (this.remoteStore = this.createRemoteStore(n)),
   (this.eventManager = this.createEventManager(n)),
   (this.syncEngine = this.createSyncEngine(n, !e.synchronizeTabs)),
   (this.sharedClientState.onlineStateHandler = (r) => sE(this.syncEngine, r, 1)),
   (this.remoteStore.remoteSyncer.handleCredentialChange = p$.bind(null, this.syncEngine)),
   await Y4(this.remoteStore, this.syncEngine.isPrimaryClient));
 }
 createEventManager(e) {
  return (function () {
   return new X4();
  })();
 }
 createDatastore(e) {
  const n = yf(e.databaseInfo.databaseId),
   r = (function (o) {
    return new M4(o);
   })(e.databaseInfo);
  return (function (o, s, a, l) {
   return new V4(o, s, a, l);
  })(e.authCredentials, e.appCheckCredentials, r, n);
 }
 createRemoteStore(e) {
  return (function (r, i, o, s, a) {
   return new O4(r, i, o, s, a);
  })(
   this.localStore,
   this.datastore,
   e.asyncQueue,
   (n) => sE(this.syncEngine, n, 0),
   (function () {
    return tE.D() ? new tE() : new b4();
   })()
  );
 }
 createSyncEngine(e, n) {
  return (function (i, o, s, a, l, u, h) {
   const p = new r$(i, o, s, a, l, u);
   return h && (p.Qa = !0), p;
  })(
   this.localStore,
   this.remoteStore,
   this.eventManager,
   this.sharedClientState,
   e.initialUser,
   e.maxConcurrentLimboResolutions,
   n
  );
 }
 async terminate() {
  var e, n;
  await (async function (i) {
   const o = re(i);
   Q("RemoteStore", "RemoteStore shutting down."), o.L_.add(5), await Zl(o), o.k_.shutdown(), o.q_.set("Unknown");
  })(this.remoteStore),
   (e = this.datastore) === null || e === void 0 || e.terminate(),
   (n = this.eventManager) === null || n === void 0 || n.terminate();
 }
}
Sm.provider = { build: () => new Sm() };
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Hy {
 constructor(e) {
  (this.observer = e), (this.muted = !1);
 }
 next(e) {
  this.muted || (this.observer.next && this.Ya(this.observer.next, e));
 }
 error(e) {
  this.muted ||
   (this.observer.error ? this.Ya(this.observer.error, e) : xr("Uncaught Error in snapshot listener:", e.toString()));
 }
 Za() {
  this.muted = !0;
 }
 Ya(e, n) {
  setTimeout(() => {
   this.muted || e(n);
  }, 0);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class y$ {
 constructor(e, n, r, i, o) {
  (this.authCredentials = e),
   (this.appCheckCredentials = n),
   (this.asyncQueue = r),
   (this.databaseInfo = i),
   (this.user = Ct.UNAUTHENTICATED),
   (this.clientId = NR.newId()),
   (this.authCredentialListener = () => Promise.resolve()),
   (this.appCheckCredentialListener = () => Promise.resolve()),
   (this._uninitializedComponentsProvider = o),
   this.authCredentials.start(r, async (s) => {
    Q("FirestoreClient", "Received user=", s.uid), await this.authCredentialListener(s), (this.user = s);
   }),
   this.appCheckCredentials.start(
    r,
    (s) => (Q("FirestoreClient", "Received new app check token=", s), this.appCheckCredentialListener(s, this.user))
   );
 }
 get configuration() {
  return {
   asyncQueue: this.asyncQueue,
   databaseInfo: this.databaseInfo,
   clientId: this.clientId,
   authCredentials: this.authCredentials,
   appCheckCredentials: this.appCheckCredentials,
   initialUser: this.user,
   maxConcurrentLimboResolutions: 100,
  };
 }
 setCredentialChangeListener(e) {
  this.authCredentialListener = e;
 }
 setAppCheckTokenChangeListener(e) {
  this.appCheckCredentialListener = e;
 }
 terminate() {
  this.asyncQueue.enterRestrictedMode();
  const e = new or();
  return (
   this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
     this._onlineComponents && (await this._onlineComponents.terminate()),
      this._offlineComponents && (await this._offlineComponents.terminate()),
      this.authCredentials.shutdown(),
      this.appCheckCredentials.shutdown(),
      e.resolve();
    } catch (n) {
     const r = Vy(n, "Failed to shutdown persistence");
     e.reject(r);
    }
   }),
   e.promise
  );
 }
}
async function qh(t, e) {
 t.asyncQueue.verifyOperationInProgress(), Q("FirestoreClient", "Initializing OfflineComponentProvider");
 const n = t.configuration;
 await e.initialize(n);
 let r = n.initialUser;
 t.setCredentialChangeListener(async (i) => {
  r.isEqual(i) || (await pP(e.localStore, i), (r = i));
 }),
  e.persistence.setDatabaseDeletedListener(() => t.terminate()),
  (t._offlineComponents = e);
}
async function lE(t, e) {
 t.asyncQueue.verifyOperationInProgress();
 const n = await v$(t);
 Q("FirestoreClient", "Initializing OnlineComponentProvider"),
  await e.initialize(n, t.configuration),
  t.setCredentialChangeListener((r) => nE(e.remoteStore, r)),
  t.setAppCheckTokenChangeListener((r, i) => nE(e.remoteStore, i)),
  (t._onlineComponents = e);
}
async function v$(t) {
 if (!t._offlineComponents)
  if (t._uninitializedComponentsProvider) {
   Q("FirestoreClient", "Using user provided OfflineComponentProvider");
   try {
    await qh(t, t._uninitializedComponentsProvider._offline);
   } catch (e) {
    const n = e;
    if (
     !(function (i) {
      return i.name === "FirebaseError"
       ? i.code === B.FAILED_PRECONDITION || i.code === B.UNIMPLEMENTED
       : !(typeof DOMException < "u" && i instanceof DOMException) || i.code === 22 || i.code === 20 || i.code === 11;
     })(n)
    )
     throw n;
    ks("Error using user provided cache. Falling back to memory cache: " + n), await qh(t, new Td());
   }
  } else Q("FirestoreClient", "Using default OfflineComponentProvider"), await qh(t, new Td());
 return t._offlineComponents;
}
async function qy(t) {
 return (
  t._onlineComponents ||
   (t._uninitializedComponentsProvider
    ? (Q("FirestoreClient", "Using user provided OnlineComponentProvider"),
      await lE(t, t._uninitializedComponentsProvider._online))
    : (Q("FirestoreClient", "Using default OnlineComponentProvider"), await lE(t, new Sm()))),
  t._onlineComponents
 );
}
function _$(t) {
 return qy(t).then((e) => e.syncEngine);
}
function w$(t) {
 return qy(t).then((e) => e.datastore);
}
async function Id(t) {
 const e = await qy(t),
  n = e.eventManager;
 return (
  (n.onListen = i$.bind(null, e.syncEngine)),
  (n.onUnlisten = a$.bind(null, e.syncEngine)),
  (n.onFirstRemoteStoreListen = o$.bind(null, e.syncEngine)),
  (n.onLastRemoteStoreUnlisten = l$.bind(null, e.syncEngine)),
  n
 );
}
function E$(t, e, n = {}) {
 const r = new or();
 return (
  t.asyncQueue.enqueueAndForget(async () =>
   (function (o, s, a, l, u) {
    const h = new Hy({
      next: (m) => {
       h.Za(), s.enqueueAndForget(() => Oy(o, p));
       const v = m.docs.has(a);
       !v && m.fromCache
        ? u.reject(new J(B.UNAVAILABLE, "Failed to get document because the client is offline."))
        : v && m.fromCache && l && l.source === "server"
          ? u.reject(
             new J(
              B.UNAVAILABLE,
              'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)'
             )
            )
          : u.resolve(m);
      },
      error: (m) => u.reject(m),
     }),
     p = new By(cf(a.path), h, { includeMetadataChanges: !0, _a: !0 });
    return Uy(o, p);
   })(await Id(t), t.asyncQueue, e, n, r)
  ),
  r.promise
 );
}
function T$(t, e, n = {}) {
 const r = new or();
 return (
  t.asyncQueue.enqueueAndForget(async () =>
   (function (o, s, a, l, u) {
    const h = new Hy({
      next: (m) => {
       h.Za(),
        s.enqueueAndForget(() => Oy(o, p)),
        m.fromCache && l.source === "server"
         ? u.reject(
            new J(
             B.UNAVAILABLE,
             'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)'
            )
           )
         : u.resolve(m);
      },
      error: (m) => u.reject(m),
     }),
     p = new By(a, h, { includeMetadataChanges: !0, _a: !0 });
    return Uy(o, p);
   })(await Id(t), t.asyncQueue, e, n, r)
  ),
  r.promise
 );
}
function I$(t, e, n) {
 const r = new or();
 return (
  t.asyncQueue.enqueueAndForget(async () => {
   try {
    const i = await w$(t);
    r.resolve(
     (async function (s, a, l) {
      var u;
      const h = re(s),
       { request: p, ut: m, parent: v } = QB(h.serializer, yB(a), l);
      h.connection.Fo || delete p.parent;
      const w = (await h.Lo("RunAggregationQuery", h.serializer.databaseId, v, p, 1)).filter((A) => !!A.result);
      we(w.length === 1);
      const C = (u = w[0].result) === null || u === void 0 ? void 0 : u.aggregateFields;
      return Object.keys(C).reduce((A, T) => ((A[m[T]] = C[T]), A), {});
     })(i, e, n)
    );
   } catch (i) {
    r.reject(i);
   }
  }),
  r.promise
 );
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function xP(t) {
 const e = {};
 return t.timeoutSeconds !== void 0 && (e.timeoutSeconds = t.timeoutSeconds), e;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const uE = new Map();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function MP(t, e, n) {
 if (!n) throw new J(B.INVALID_ARGUMENT, `Function ${t}() cannot be called with an empty ${e}.`);
}
function S$(t, e, n, r) {
 if (e === !0 && r === !0) throw new J(B.INVALID_ARGUMENT, `${t} and ${n} cannot be used together.`);
}
function cE(t) {
 if (!j.isDocumentKey(t))
  throw new J(
   B.INVALID_ARGUMENT,
   `Invalid document reference. Document references must have an even number of segments, but ${t} has ${t.length}.`
  );
}
function dE(t) {
 if (j.isDocumentKey(t))
  throw new J(
   B.INVALID_ARGUMENT,
   `Invalid collection reference. Collection references must have an odd number of segments, but ${t} has ${t.length}.`
  );
}
function wf(t) {
 if (t === void 0) return "undefined";
 if (t === null) return "null";
 if (typeof t == "string") return t.length > 20 && (t = `${t.substring(0, 20)}...`), JSON.stringify(t);
 if (typeof t == "number" || typeof t == "boolean") return "" + t;
 if (typeof t == "object") {
  if (t instanceof Array) return "an array";
  {
   const e = (function (r) {
    return r.constructor ? r.constructor.name : null;
   })(t);
   return e ? `a custom ${e} object` : "an object";
  }
 }
 return typeof t == "function" ? "a function" : ne();
}
function Nt(t, e) {
 if (("_delegate" in t && (t = t._delegate), !(t instanceof e))) {
  if (e.name === t.constructor.name)
   throw new J(
    B.INVALID_ARGUMENT,
    "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"
   );
  {
   const n = wf(t);
   throw new J(B.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
  }
 }
 return t;
}
function A$(t, e) {
 if (e <= 0) throw new J(B.INVALID_ARGUMENT, `Function ${t}() requires a positive number, but it was: ${e}.`);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class fE {
 constructor(e) {
  var n, r;
  if (e.host === void 0) {
   if (e.ssl !== void 0) throw new J(B.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
   (this.host = "firestore.googleapis.com"), (this.ssl = !0);
  } else (this.host = e.host), (this.ssl = (n = e.ssl) === null || n === void 0 || n);
  if (
   ((this.credentials = e.credentials),
   (this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties),
   (this.localCache = e.localCache),
   e.cacheSizeBytes === void 0)
  )
   this.cacheSizeBytes = 41943040;
  else {
   if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
    throw new J(B.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
   this.cacheSizeBytes = e.cacheSizeBytes;
  }
  S$(
   "experimentalForceLongPolling",
   e.experimentalForceLongPolling,
   "experimentalAutoDetectLongPolling",
   e.experimentalAutoDetectLongPolling
  ),
   (this.experimentalForceLongPolling = !!e.experimentalForceLongPolling),
   this.experimentalForceLongPolling
    ? (this.experimentalAutoDetectLongPolling = !1)
    : e.experimentalAutoDetectLongPolling === void 0
      ? (this.experimentalAutoDetectLongPolling = !0)
      : (this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling),
   (this.experimentalLongPollingOptions = xP((r = e.experimentalLongPollingOptions) !== null && r !== void 0 ? r : {})),
   (function (o) {
    if (o.timeoutSeconds !== void 0) {
     if (isNaN(o.timeoutSeconds))
      throw new J(B.INVALID_ARGUMENT, `invalid long polling timeout: ${o.timeoutSeconds} (must not be NaN)`);
     if (o.timeoutSeconds < 5)
      throw new J(B.INVALID_ARGUMENT, `invalid long polling timeout: ${o.timeoutSeconds} (minimum allowed value is 5)`);
     if (o.timeoutSeconds > 30)
      throw new J(
       B.INVALID_ARGUMENT,
       `invalid long polling timeout: ${o.timeoutSeconds} (maximum allowed value is 30)`
      );
    }
   })(this.experimentalLongPollingOptions),
   (this.useFetchStreams = !!e.useFetchStreams);
 }
 isEqual(e) {
  return (
   this.host === e.host &&
   this.ssl === e.ssl &&
   this.credentials === e.credentials &&
   this.cacheSizeBytes === e.cacheSizeBytes &&
   this.experimentalForceLongPolling === e.experimentalForceLongPolling &&
   this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling &&
   (function (r, i) {
    return r.timeoutSeconds === i.timeoutSeconds;
   })(this.experimentalLongPollingOptions, e.experimentalLongPollingOptions) &&
   this.ignoreUndefinedProperties === e.ignoreUndefinedProperties &&
   this.useFetchStreams === e.useFetchStreams
  );
 }
}
class Ef {
 constructor(e, n, r, i) {
  (this._authCredentials = e),
   (this._appCheckCredentials = n),
   (this._databaseId = r),
   (this._app = i),
   (this.type = "firestore-lite"),
   (this._persistenceKey = "(lite)"),
   (this._settings = new fE({})),
   (this._settingsFrozen = !1),
   (this._terminateTask = "notTerminated");
 }
 get app() {
  if (!this._app)
   throw new J(B.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
  return this._app;
 }
 get _initialized() {
  return this._settingsFrozen;
 }
 get _terminated() {
  return this._terminateTask !== "notTerminated";
 }
 _setSettings(e) {
  if (this._settingsFrozen)
   throw new J(
    B.FAILED_PRECONDITION,
    "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object."
   );
  (this._settings = new fE(e)),
   e.credentials !== void 0 &&
    (this._authCredentials = (function (r) {
     if (!r) return new FF();
     switch (r.type) {
      case "firstParty":
       return new qF(r.sessionIndex || "0", r.iamToken || null, r.authTokenFactory || null);
      case "provider":
       return r.client;
      default:
       throw new J(B.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
     }
    })(e.credentials));
 }
 _getSettings() {
  return this._settings;
 }
 _freezeSettings() {
  return (this._settingsFrozen = !0), this._settings;
 }
 _delete() {
  return this._terminateTask === "notTerminated" && (this._terminateTask = this._terminate()), this._terminateTask;
 }
 async _restart() {
  this._terminateTask === "notTerminated" ? await this._terminate() : (this._terminateTask = "notTerminated");
 }
 toJSON() {
  return { app: this._app, databaseId: this._databaseId, settings: this._settings };
 }
 _terminate() {
  return (
   (function (n) {
    const r = uE.get(n);
    r && (Q("ComponentProvider", "Removing Datastore"), uE.delete(n), r.terminate());
   })(this),
   Promise.resolve()
  );
 }
}
function C$(t, e, n, r = {}) {
 var i;
 const o = (t = Nt(t, Ef))._getSettings(),
  s = `${e}:${n}`;
 if (
  (o.host !== "firestore.googleapis.com" &&
   o.host !== s &&
   ks("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."),
  t._setSettings(Object.assign(Object.assign({}, o), { host: s, ssl: !1 })),
  r.mockUserToken)
 ) {
  let a, l;
  if (typeof r.mockUserToken == "string") (a = r.mockUserToken), (l = Ct.MOCK_USER);
  else {
   a = VC(r.mockUserToken, (i = t._app) === null || i === void 0 ? void 0 : i.options.projectId);
   const u = r.mockUserToken.sub || r.mockUserToken.user_id;
   if (!u) throw new J(B.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
   l = new Ct(u);
  }
  t._authCredentials = new BF(new bR(a, l));
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Or {
 constructor(e, n, r) {
  (this.converter = n), (this._query = r), (this.type = "query"), (this.firestore = e);
 }
 withConverter(e) {
  return new Or(this.firestore, e, this._query);
 }
}
class xt {
 constructor(e, n, r) {
  (this.converter = n), (this._key = r), (this.type = "document"), (this.firestore = e);
 }
 get _path() {
  return this._key.path;
 }
 get id() {
  return this._key.path.lastSegment();
 }
 get path() {
  return this._key.path.canonicalString();
 }
 get parent() {
  return new Ii(this.firestore, this.converter, this._key.path.popLast());
 }
 withConverter(e) {
  return new xt(this.firestore, e, this._key);
 }
}
class Ii extends Or {
 constructor(e, n, r) {
  super(e, n, cf(r)), (this._path = r), (this.type = "collection");
 }
 get id() {
  return this._query.path.lastSegment();
 }
 get path() {
  return this._query.path.canonicalString();
 }
 get parent() {
  const e = this._path.popLast();
  return e.isEmpty() ? null : new xt(this.firestore, null, new j(e));
 }
 withConverter(e) {
  return new Ii(this.firestore, e, this._path);
 }
}
function le(t, e, ...n) {
 if (((t = Se(t)), MP("collection", "path", e), t instanceof Ef)) {
  const r = Ne.fromString(e, ...n);
  return dE(r), new Ii(t, null, r);
 }
 {
  if (!(t instanceof xt || t instanceof Ii))
   throw new J(
    B.INVALID_ARGUMENT,
    "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"
   );
  const r = t._path.child(Ne.fromString(e, ...n));
  return dE(r), new Ii(t.firestore, null, r);
 }
}
function ee(t, e, ...n) {
 if (((t = Se(t)), arguments.length === 1 && (e = NR.newId()), MP("doc", "path", e), t instanceof Ef)) {
  const r = Ne.fromString(e, ...n);
  return cE(r), new xt(t, null, new j(r));
 }
 {
  if (!(t instanceof xt || t instanceof Ii))
   throw new J(
    B.INVALID_ARGUMENT,
    "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"
   );
  const r = t._path.child(Ne.fromString(e, ...n));
  return cE(r), new xt(t.firestore, t instanceof Ii ? t.converter : null, new j(r));
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hE {
 constructor(e = Promise.resolve()) {
  (this.Pu = []),
   (this.Iu = !1),
   (this.Tu = []),
   (this.Eu = null),
   (this.du = !1),
   (this.Au = !1),
   (this.Ru = []),
   (this.t_ = new gP(this, "async_queue_retry")),
   (this.Vu = () => {
    const r = Hh();
    r && Q("AsyncQueue", "Visibility state changed to " + r.visibilityState), this.t_.jo();
   }),
   (this.mu = e);
  const n = Hh();
  n && typeof n.addEventListener == "function" && n.addEventListener("visibilitychange", this.Vu);
 }
 get isShuttingDown() {
  return this.Iu;
 }
 enqueueAndForget(e) {
  this.enqueue(e);
 }
 enqueueAndForgetEvenWhileRestricted(e) {
  this.fu(), this.gu(e);
 }
 enterRestrictedMode(e) {
  if (!this.Iu) {
   (this.Iu = !0), (this.Au = e || !1);
   const n = Hh();
   n && typeof n.removeEventListener == "function" && n.removeEventListener("visibilitychange", this.Vu);
  }
 }
 enqueue(e) {
  if ((this.fu(), this.Iu)) return new Promise(() => {});
  const n = new or();
  return this.gu(() => (this.Iu && this.Au ? Promise.resolve() : (e().then(n.resolve, n.reject), n.promise))).then(
   () => n.promise
  );
 }
 enqueueRetryable(e) {
  this.enqueueAndForget(() => (this.Pu.push(e), this.pu()));
 }
 async pu() {
  if (this.Pu.length !== 0) {
   try {
    await this.Pu[0](), this.Pu.shift(), this.t_.reset();
   } catch (e) {
    if (!Ql(e)) throw e;
    Q("AsyncQueue", "Operation failed with retryable error: " + e);
   }
   this.Pu.length > 0 && this.t_.Go(() => this.pu());
  }
 }
 gu(e) {
  const n = this.mu.then(
   () => (
    (this.du = !0),
    e()
     .catch((r) => {
      (this.Eu = r), (this.du = !1);
      const i = (function (s) {
       let a = s.message || "";
       return (
        s.stack &&
         (a = s.stack.includes(s.message)
          ? s.stack
          : s.message +
            `
` +
            s.stack),
        a
       );
      })(r);
      throw (xr("INTERNAL UNHANDLED ERROR: ", i), r);
     })
     .then((r) => ((this.du = !1), r))
   )
  );
  return (this.mu = n), n;
 }
 enqueueAfterDelay(e, n, r) {
  this.fu(), this.Ru.indexOf(e) > -1 && (n = 0);
  const i = Ly.createAndSchedule(this, e, n, r, (o) => this.yu(o));
  return this.Tu.push(i), i;
 }
 fu() {
  this.Eu && ne();
 }
 verifyOperationInProgress() {}
 async wu() {
  let e;
  do (e = this.mu), await e;
  while (e !== this.mu);
 }
 Su(e) {
  for (const n of this.Tu) if (n.timerId === e) return !0;
  return !1;
 }
 bu(e) {
  return this.wu().then(() => {
   this.Tu.sort((n, r) => n.targetTimeMs - r.targetTimeMs);
   for (const n of this.Tu) if ((n.skipDelay(), e !== "all" && n.timerId === e)) break;
   return this.wu();
  });
 }
 Du(e) {
  this.Ru.push(e);
 }
 yu(e) {
  const n = this.Tu.indexOf(e);
  this.Tu.splice(n, 1);
 }
}
function pE(t) {
 return (function (n, r) {
  if (typeof n != "object" || n === null) return !1;
  const i = n;
  for (const o of r) if (o in i && typeof i[o] == "function") return !0;
  return !1;
 })(t, ["next", "error", "complete"]);
}
class zn extends Ef {
 constructor(e, n, r, i) {
  super(e, n, r, i),
   (this.type = "firestore"),
   (this._queue = new hE()),
   (this._persistenceKey = (i == null ? void 0 : i.name) || "[DEFAULT]");
 }
 async _terminate() {
  if (this._firestoreClient) {
   const e = this._firestoreClient.terminate();
   (this._queue = new hE(e)), (this._firestoreClient = void 0), await e;
  }
 }
}
function R$(t, e) {
 const n = typeof t == "object" ? t : Gl(),
  r = typeof t == "string" ? t : "(default)",
  i = Mi(n, "firestore").getImmediate({ identifier: r });
 if (!i._initialized) {
  const o = MC("firestore");
  o && C$(i, ...o);
 }
 return i;
}
function Ys(t) {
 if (t._terminated) throw new J(B.FAILED_PRECONDITION, "The client has already been terminated.");
 return t._firestoreClient || P$(t), t._firestoreClient;
}
function P$(t) {
 var e, n, r;
 const i = t._freezeSettings(),
  o = (function (a, l, u, h) {
   return new rB(
    a,
    l,
    u,
    h.host,
    h.ssl,
    h.experimentalForceLongPolling,
    h.experimentalAutoDetectLongPolling,
    xP(h.experimentalLongPollingOptions),
    h.useFetchStreams
   );
  })(t._databaseId, ((e = t._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t._persistenceKey, i);
 t._componentsProvider ||
  (!((n = i.localCache) === null || n === void 0) &&
   n._offlineComponentProvider &&
   !((r = i.localCache) === null || r === void 0) &&
   r._onlineComponentProvider &&
   (t._componentsProvider = {
    _offline: i.localCache._offlineComponentProvider,
    _online: i.localCache._onlineComponentProvider,
   })),
  (t._firestoreClient = new y$(
   t._authCredentials,
   t._appCheckCredentials,
   t._queue,
   o,
   t._componentsProvider &&
    (function (a) {
     const l = a == null ? void 0 : a._online.build();
     return { _offline: a == null ? void 0 : a._offline.build(l), _online: l };
    })(t._componentsProvider)
  ));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class k$ {
 constructor(e = "count", n) {
  (this._internalFieldPath = n), (this.type = "AggregateField"), (this.aggregateType = e);
 }
}
class b$ {
 constructor(e, n, r) {
  (this._userDataWriter = n), (this._data = r), (this.type = "AggregateQuerySnapshot"), (this.query = e);
 }
 data() {
  return this._userDataWriter.convertObjectMap(this._data);
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ls {
 constructor(e) {
  this._byteString = e;
 }
 static fromBase64String(e) {
  try {
   return new Ls(_t.fromBase64String(e));
  } catch (n) {
   throw new J(B.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + n);
  }
 }
 static fromUint8Array(e) {
  return new Ls(_t.fromUint8Array(e));
 }
 toBase64() {
  return this._byteString.toBase64();
 }
 toUint8Array() {
  return this._byteString.toUint8Array();
 }
 toString() {
  return "Bytes(base64: " + this.toBase64() + ")";
 }
 isEqual(e) {
  return this._byteString.isEqual(e._byteString);
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class tu {
 constructor(...e) {
  for (let n = 0; n < e.length; ++n)
   if (e[n].length === 0)
    throw new J(B.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
  this._internalPath = new mt(e);
 }
 isEqual(e) {
  return this._internalPath.isEqual(e._internalPath);
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class nu {
 constructor(e) {
  this._methodName = e;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Gy {
 constructor(e, n) {
  if (!isFinite(e) || e < -90 || e > 90)
   throw new J(B.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e);
  if (!isFinite(n) || n < -180 || n > 180)
   throw new J(B.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + n);
  (this._lat = e), (this._long = n);
 }
 get latitude() {
  return this._lat;
 }
 get longitude() {
  return this._long;
 }
 isEqual(e) {
  return this._lat === e._lat && this._long === e._long;
 }
 toJSON() {
  return { latitude: this._lat, longitude: this._long };
 }
 _compareTo(e) {
  return ge(this._lat, e._lat) || ge(this._long, e._long);
 }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class zy {
 constructor(e) {
  this._values = (e || []).map((n) => n);
 }
 toArray() {
  return this._values.map((e) => e);
 }
 isEqual(e) {
  return (function (r, i) {
   if (r.length !== i.length) return !1;
   for (let o = 0; o < r.length; ++o) if (r[o] !== i[o]) return !1;
   return !0;
  })(this._values, e._values);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const N$ = /^__.*__$/;
class x$ {
 constructor(e, n, r) {
  (this.data = e), (this.fieldMask = n), (this.fieldTransforms = r);
 }
 toMutation(e, n) {
  return this.fieldMask !== null
   ? new Li(e, this.data, this.fieldMask, n, this.fieldTransforms)
   : new Xl(e, this.data, n, this.fieldTransforms);
 }
}
class DP {
 constructor(e, n, r) {
  (this.data = e), (this.fieldMask = n), (this.fieldTransforms = r);
 }
 toMutation(e, n) {
  return new Li(e, this.data, this.fieldMask, n, this.fieldTransforms);
 }
}
function LP(t) {
 switch (t) {
  case 0:
  case 2:
  case 1:
   return !0;
  case 3:
  case 4:
   return !1;
  default:
   throw ne();
 }
}
class Wy {
 constructor(e, n, r, i, o, s) {
  (this.settings = e),
   (this.databaseId = n),
   (this.serializer = r),
   (this.ignoreUndefinedProperties = i),
   o === void 0 && this.vu(),
   (this.fieldTransforms = o || []),
   (this.fieldMask = s || []);
 }
 get path() {
  return this.settings.path;
 }
 get Cu() {
  return this.settings.Cu;
 }
 Fu(e) {
  return new Wy(
   Object.assign(Object.assign({}, this.settings), e),
   this.databaseId,
   this.serializer,
   this.ignoreUndefinedProperties,
   this.fieldTransforms,
   this.fieldMask
  );
 }
 Mu(e) {
  var n;
  const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(e),
   i = this.Fu({ path: r, xu: !1 });
  return i.Ou(e), i;
 }
 Nu(e) {
  var n;
  const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(e),
   i = this.Fu({ path: r, xu: !1 });
  return i.vu(), i;
 }
 Lu(e) {
  return this.Fu({ path: void 0, xu: !0 });
 }
 Bu(e) {
  return Sd(e, this.settings.methodName, this.settings.ku || !1, this.path, this.settings.qu);
 }
 contains(e) {
  return (
   this.fieldMask.find((n) => e.isPrefixOf(n)) !== void 0 ||
   this.fieldTransforms.find((n) => e.isPrefixOf(n.field)) !== void 0
  );
 }
 vu() {
  if (this.path) for (let e = 0; e < this.path.length; e++) this.Ou(this.path.get(e));
 }
 Ou(e) {
  if (e.length === 0) throw this.Bu("Document fields must not be empty");
  if (LP(this.Cu) && N$.test(e)) throw this.Bu('Document fields cannot begin and end with "__"');
 }
}
class M$ {
 constructor(e, n, r) {
  (this.databaseId = e), (this.ignoreUndefinedProperties = n), (this.serializer = r || yf(e));
 }
 Qu(e, n, r, i = !1) {
  return new Wy(
   { Cu: e, methodName: n, qu: r, path: mt.emptyPath(), xu: !1, ku: i },
   this.databaseId,
   this.serializer,
   this.ignoreUndefinedProperties
  );
 }
}
function ru(t) {
 const e = t._freezeSettings(),
  n = yf(t._databaseId);
 return new M$(t._databaseId, !!e.ignoreUndefinedProperties, n);
}
function Ky(t, e, n, r, i, o = {}) {
 const s = t.Qu(o.merge || o.mergeFields ? 2 : 0, e, n, i);
 Qy("Data must be an object, but it was:", s, r);
 const a = OP(r, s);
 let l, u;
 if (o.merge) (l = new un(s.fieldMask)), (u = s.fieldTransforms);
 else if (o.mergeFields) {
  const h = [];
  for (const p of o.mergeFields) {
   const m = Am(e, p, n);
   if (!s.contains(m))
    throw new J(B.INVALID_ARGUMENT, `Field '${m}' is specified in your field mask but missing from your input data.`);
   BP(h, m) || h.push(m);
  }
  (l = new un(h)), (u = s.fieldTransforms.filter((p) => l.covers(p.field)));
 } else (l = null), (u = s.fieldTransforms);
 return new x$(new Xt(a), l, u);
}
class Tf extends nu {
 _toFieldTransform(e) {
  if (e.Cu !== 2)
   throw e.Cu === 1
    ? e.Bu(`${this._methodName}() can only appear at the top level of your update data`)
    : e.Bu(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
  return e.fieldMask.push(e.path), null;
 }
 isEqual(e) {
  return e instanceof Tf;
 }
}
class Jy extends nu {
 _toFieldTransform(e) {
  return new eP(e.path, new Rl());
 }
 isEqual(e) {
  return e instanceof Jy;
 }
}
class Yy extends nu {
 constructor(e, n) {
  super(e), (this.$u = n);
 }
 _toFieldTransform(e) {
  const n = new bl(e.serializer, YR(e.serializer, this.$u));
  return new eP(e.path, n);
 }
 isEqual(e) {
  return e instanceof Yy && this.$u === e.$u;
 }
}
function VP(t, e, n, r) {
 const i = t.Qu(1, e, n);
 Qy("Data must be an object, but it was:", i, r);
 const o = [],
  s = Xt.empty();
 No(r, (l, u) => {
  const h = Xy(e, l, n);
  u = Se(u);
  const p = i.Nu(h);
  if (u instanceof Tf) o.push(h);
  else {
   const m = iu(u, p);
   m != null && (o.push(h), s.set(h, m));
  }
 });
 const a = new un(o);
 return new DP(s, a, i.fieldTransforms);
}
function UP(t, e, n, r, i, o) {
 const s = t.Qu(1, e, n),
  a = [Am(e, r, n)],
  l = [i];
 if (o.length % 2 != 0)
  throw new J(
   B.INVALID_ARGUMENT,
   `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`
  );
 for (let m = 0; m < o.length; m += 2) a.push(Am(e, o[m])), l.push(o[m + 1]);
 const u = [],
  h = Xt.empty();
 for (let m = a.length - 1; m >= 0; --m)
  if (!BP(u, a[m])) {
   const v = a[m];
   let w = l[m];
   w = Se(w);
   const C = s.Nu(v);
   if (w instanceof Tf) u.push(v);
   else {
    const A = iu(w, C);
    A != null && (u.push(v), h.set(v, A));
   }
  }
 const p = new un(u);
 return new DP(h, p, s.fieldTransforms);
}
function D$(t, e, n, r = !1) {
 return iu(n, t.Qu(r ? 4 : 3, e));
}
function iu(t, e) {
 if (FP((t = Se(t)))) return Qy("Unsupported field value:", e, t), OP(t, e);
 if (t instanceof nu)
  return (
   (function (r, i) {
    if (!LP(i.Cu)) throw i.Bu(`${r._methodName}() can only be used with update() and set()`);
    if (!i.path) throw i.Bu(`${r._methodName}() is not currently supported inside arrays`);
    const o = r._toFieldTransform(i);
    o && i.fieldTransforms.push(o);
   })(t, e),
   null
  );
 if (t === void 0 && e.ignoreUndefinedProperties) return null;
 if ((e.path && e.fieldMask.push(e.path), t instanceof Array)) {
  if (e.settings.xu && e.Cu !== 4) throw e.Bu("Nested arrays are not supported");
  return (function (r, i) {
   const o = [];
   let s = 0;
   for (const a of r) {
    let l = iu(a, i.Lu(s));
    l == null && (l = { nullValue: "NULL_VALUE" }), o.push(l), s++;
   }
   return { arrayValue: { values: o } };
  })(t, e);
 }
 return (function (r, i) {
  if ((r = Se(r)) === null) return { nullValue: "NULL_VALUE" };
  if (typeof r == "number") return YR(i.serializer, r);
  if (typeof r == "boolean") return { booleanValue: r };
  if (typeof r == "string") return { stringValue: r };
  if (r instanceof Date) {
   const o = st.fromDate(r);
   return { timestampValue: wd(i.serializer, o) };
  }
  if (r instanceof st) {
   const o = new st(r.seconds, 1e3 * Math.floor(r.nanoseconds / 1e3));
   return { timestampValue: wd(i.serializer, o) };
  }
  if (r instanceof Gy) return { geoPointValue: { latitude: r.latitude, longitude: r.longitude } };
  if (r instanceof Ls) return { bytesValue: sP(i.serializer, r._byteString) };
  if (r instanceof xt) {
   const o = i.databaseId,
    s = r.firestore._databaseId;
   if (!s.isEqual(o))
    throw i.Bu(
     `Document reference is for database ${s.projectId}/${s.database} but should be for database ${o.projectId}/${o.database}`
    );
   return { referenceValue: Ry(r.firestore._databaseId || i.databaseId, r._key.path) };
  }
  if (r instanceof zy)
   return (function (s, a) {
    return {
     mapValue: {
      fields: {
       __type__: { stringValue: "__vector__" },
       value: {
        arrayValue: {
         values: s.toArray().map((l) => {
          if (typeof l != "number") throw a.Bu("VectorValues must only contain numeric values.");
          return Sy(a.serializer, l);
         }),
        },
       },
      },
     },
    };
   })(r, i);
  throw i.Bu(`Unsupported field value: ${wf(r)}`);
 })(t, e);
}
function OP(t, e) {
 const n = {};
 return (
  xR(t)
   ? e.path && e.path.length > 0 && e.fieldMask.push(e.path)
   : No(t, (r, i) => {
      const o = iu(i, e.Mu(r));
      o != null && (n[r] = o);
     }),
  { mapValue: { fields: n } }
 );
}
function FP(t) {
 return !(
  typeof t != "object" ||
  t === null ||
  t instanceof Array ||
  t instanceof Date ||
  t instanceof st ||
  t instanceof Gy ||
  t instanceof Ls ||
  t instanceof xt ||
  t instanceof nu ||
  t instanceof zy
 );
}
function Qy(t, e, n) {
 if (
  !FP(n) ||
  !(function (i) {
   return (
    typeof i == "object" &&
    i !== null &&
    (Object.getPrototypeOf(i) === Object.prototype || Object.getPrototypeOf(i) === null)
   );
  })(n)
 ) {
  const r = wf(n);
  throw r === "an object" ? e.Bu(t + " a custom object") : e.Bu(t + " " + r);
 }
}
function Am(t, e, n) {
 if ((e = Se(e)) instanceof tu) return e._internalPath;
 if (typeof e == "string") return Xy(t, e);
 throw Sd("Field path arguments must be of type string or ", t, !1, void 0, n);
}
const L$ = new RegExp("[~\\*/\\[\\]]");
function Xy(t, e, n) {
 if (e.search(L$) >= 0)
  throw Sd(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t, !1, void 0, n);
 try {
  return new tu(...e.split("."))._internalPath;
 } catch {
  throw Sd(
   `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
   t,
   !1,
   void 0,
   n
  );
 }
}
function Sd(t, e, n, r, i) {
 const o = r && !r.isEmpty(),
  s = i !== void 0;
 let a = `Function ${e}() called with invalid data`;
 n && (a += " (via `toFirestore()`)"), (a += ". ");
 let l = "";
 return (
  (o || s) && ((l += " (found"), o && (l += ` in field ${r}`), s && (l += ` in document ${i}`), (l += ")")),
  new J(B.INVALID_ARGUMENT, a + t + l)
 );
}
function BP(t, e) {
 return t.some((n) => n.isEqual(e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class $P {
 constructor(e, n, r, i, o) {
  (this._firestore = e), (this._userDataWriter = n), (this._key = r), (this._document = i), (this._converter = o);
 }
 get id() {
  return this._key.path.lastSegment();
 }
 get ref() {
  return new xt(this._firestore, this._converter, this._key);
 }
 exists() {
  return this._document !== null;
 }
 data() {
  if (this._document) {
   if (this._converter) {
    const e = new V$(this._firestore, this._userDataWriter, this._key, this._document, null);
    return this._converter.fromFirestore(e);
   }
   return this._userDataWriter.convertValue(this._document.data.value);
  }
 }
 get(e) {
  if (this._document) {
   const n = this._document.data.field(If("DocumentSnapshot.get", e));
   if (n !== null) return this._userDataWriter.convertValue(n);
  }
 }
}
class V$ extends $P {
 data() {
  return super.data();
 }
}
function If(t, e) {
 return typeof e == "string" ? Xy(t, e) : e instanceof tu ? e._internalPath : e._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function HP(t) {
 if (t.limitType === "L" && t.explicitOrderBy.length === 0)
  throw new J(B.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
class jy {}
class Zy extends jy {}
function Ee(t, e, ...n) {
 let r = [];
 e instanceof jy && r.push(e),
  (r = r.concat(n)),
  (function (o) {
   const s = o.filter((l) => l instanceof ev).length,
    a = o.filter((l) => l instanceof Sf).length;
   if (s > 1 || (s > 0 && a > 0))
    throw new J(
     B.INVALID_ARGUMENT,
     "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`."
    );
  })(r);
 for (const i of r) t = i._apply(t);
 return t;
}
class Sf extends Zy {
 constructor(e, n, r) {
  super(), (this._field = e), (this._op = n), (this._value = r), (this.type = "where");
 }
 static _create(e, n, r) {
  return new Sf(e, n, r);
 }
 _apply(e) {
  const n = this._parse(e);
  return qP(e._query, n), new Or(e.firestore, e.converter, gm(e._query, n));
 }
 _parse(e) {
  const n = ru(e.firestore);
  return (function (o, s, a, l, u, h, p) {
   let m;
   if (u.isKeyField()) {
    if (h === "array-contains" || h === "array-contains-any")
     throw new J(B.INVALID_ARGUMENT, `Invalid Query. You can't perform '${h}' queries on documentId().`);
    if (h === "in" || h === "not-in") {
     yE(p, h);
     const v = [];
     for (const w of p) v.push(gE(l, o, w));
     m = { arrayValue: { values: v } };
    } else m = gE(l, o, p);
   } else
    (h !== "in" && h !== "not-in" && h !== "array-contains-any") || yE(p, h),
     (m = D$(a, s, p, h === "in" || h === "not-in"));
   return tt.create(u, h, m);
  })(e._query, "where", n, e.firestore._databaseId, this._field, this._op, this._value);
 }
}
function he(t, e, n) {
 const r = e,
  i = If("where", t);
 return Sf._create(i, r, n);
}
class ev extends jy {
 constructor(e, n) {
  super(), (this.type = e), (this._queryConstraints = n);
 }
 static _create(e, n) {
  return new ev(e, n);
 }
 _parse(e) {
  const n = this._queryConstraints.map((r) => r._parse(e)).filter((r) => r.getFilters().length > 0);
  return n.length === 1 ? n[0] : Gn.create(n, this._getOperator());
 }
 _apply(e) {
  const n = this._parse(e);
  return n.getFilters().length === 0
   ? e
   : ((function (i, o) {
      let s = i;
      const a = o.getFlattenedFilters();
      for (const l of a) qP(s, l), (s = gm(s, l));
     })(e._query, n),
     new Or(e.firestore, e.converter, gm(e._query, n)));
 }
 _getQueryConstraints() {
  return this._queryConstraints;
 }
 _getOperator() {
  return this.type === "and" ? "and" : "or";
 }
}
class tv extends Zy {
 constructor(e, n) {
  super(), (this._field = e), (this._direction = n), (this.type = "orderBy");
 }
 static _create(e, n) {
  return new tv(e, n);
 }
 _apply(e) {
  const n = (function (i, o, s) {
   if (i.startAt !== null)
    throw new J(
     B.INVALID_ARGUMENT,
     "Invalid query. You must not call startAt() or startAfter() before calling orderBy()."
    );
   if (i.endAt !== null)
    throw new J(
     B.INVALID_ARGUMENT,
     "Invalid query. You must not call endAt() or endBefore() before calling orderBy()."
    );
   return new Cl(o, s);
  })(e._query, this._field, this._direction);
  return new Or(
   e.firestore,
   e.converter,
   (function (i, o) {
    const s = i.explicitOrderBy.concat([o]);
    return new Ws(i.path, i.collectionGroup, s, i.filters.slice(), i.limit, i.limitType, i.startAt, i.endAt);
   })(e._query, n)
  );
 }
}
function Ea(t, e = "asc") {
 const n = e,
  r = If("orderBy", t);
 return tv._create(r, n);
}
class nv extends Zy {
 constructor(e, n, r) {
  super(), (this.type = e), (this._limit = n), (this._limitType = r);
 }
 static _create(e, n, r) {
  return new nv(e, n, r);
 }
 _apply(e) {
  return new Or(e.firestore, e.converter, _d(e._query, this._limit, this._limitType));
 }
}
function mE(t) {
 return A$("limit", t), nv._create("limit", t, "F");
}
function gE(t, e, n) {
 if (typeof (n = Se(n)) == "string") {
  if (n === "")
   throw new J(
    B.INVALID_ARGUMENT,
    "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string."
   );
  if (!$R(e) && n.indexOf("/") !== -1)
   throw new J(
    B.INVALID_ARGUMENT,
    `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`
   );
  const r = e.path.child(Ne.fromString(n));
  if (!j.isDocumentKey(r))
   throw new J(
    B.INVALID_ARGUMENT,
    `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`
   );
  return V0(t, new j(r));
 }
 if (n instanceof xt) return V0(t, n._key);
 throw new J(
  B.INVALID_ARGUMENT,
  `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${wf(n)}.`
 );
}
function yE(t, e) {
 if (!Array.isArray(t) || t.length === 0)
  throw new J(B.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
}
function qP(t, e) {
 const n = (function (i, o) {
  for (const s of i) for (const a of s.getFlattenedFilters()) if (o.indexOf(a.op) >= 0) return a.op;
  return null;
 })(
  t.filters,
  (function (i) {
   switch (i) {
    case "!=":
     return ["!=", "not-in"];
    case "array-contains-any":
    case "in":
     return ["not-in"];
    case "not-in":
     return ["array-contains-any", "in", "not-in", "!="];
    default:
     return [];
   }
  })(e.op)
 );
 if (n !== null)
  throw n === e.op
   ? new J(B.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`)
   : new J(
      B.INVALID_ARGUMENT,
      `Invalid query. You cannot use '${e.op.toString()}' filters with '${n.toString()}' filters.`
     );
}
class U$ {
 convertValue(e, n = "none") {
  switch (vo(e)) {
   case 0:
    return null;
   case 1:
    return e.booleanValue;
   case 2:
    return Je(e.integerValue || e.doubleValue);
   case 3:
    return this.convertTimestamp(e.timestampValue);
   case 4:
    return this.convertServerTimestamp(e, n);
   case 5:
    return e.stringValue;
   case 6:
    return this.convertBytes(yo(e.bytesValue));
   case 7:
    return this.convertReference(e.referenceValue);
   case 8:
    return this.convertGeoPoint(e.geoPointValue);
   case 9:
    return this.convertArray(e.arrayValue, n);
   case 11:
    return this.convertObject(e.mapValue, n);
   case 10:
    return this.convertVectorValue(e.mapValue);
   default:
    throw ne();
  }
 }
 convertObject(e, n) {
  return this.convertObjectMap(e.fields, n);
 }
 convertObjectMap(e, n = "none") {
  const r = {};
  return (
   No(e, (i, o) => {
    r[i] = this.convertValue(o, n);
   }),
   r
  );
 }
 convertVectorValue(e) {
  var n, r, i;
  const o =
   (i =
    (r = (n = e.fields) === null || n === void 0 ? void 0 : n.value.arrayValue) === null || r === void 0
     ? void 0
     : r.values) === null || i === void 0
    ? void 0
    : i.map((s) => Je(s.doubleValue));
  return new zy(o);
 }
 convertGeoPoint(e) {
  return new Gy(Je(e.latitude), Je(e.longitude));
 }
 convertArray(e, n) {
  return (e.values || []).map((r) => this.convertValue(r, n));
 }
 convertServerTimestamp(e, n) {
  switch (n) {
   case "previous":
    const r = wy(e);
    return r == null ? null : this.convertValue(r, n);
   case "estimate":
    return this.convertTimestamp(Il(e));
   default:
    return null;
  }
 }
 convertTimestamp(e) {
  const n = Ri(e);
  return new st(n.seconds, n.nanos);
 }
 convertDocumentKey(e, n) {
  const r = Ne.fromString(e);
  we(hP(r));
  const i = new Sl(r.get(1), r.get(3)),
   o = new j(r.popFirst(5));
  return (
   i.isEqual(n) ||
    xr(
     `Document ${o} contains a document reference within a different database (${i.projectId}/${i.database}) which is not supported. It will be treated as a reference in the current database (${n.projectId}/${n.database}) instead.`
    ),
   o
  );
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function rv(t, e, n) {
 let r;
 return (r = t ? (n && (n.merge || n.mergeFields) ? t.toFirestore(e, n) : t.toFirestore(e)) : e), r;
}
function O$() {
 return new k$("count");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class La {
 constructor(e, n) {
  (this.hasPendingWrites = e), (this.fromCache = n);
 }
 isEqual(e) {
  return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache;
 }
}
class GP extends $P {
 constructor(e, n, r, i, o, s) {
  super(e, n, r, i, s), (this._firestore = e), (this._firestoreImpl = e), (this.metadata = o);
 }
 exists() {
  return super.exists();
 }
 data(e = {}) {
  if (this._document) {
   if (this._converter) {
    const n = new Rc(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
    return this._converter.fromFirestore(n, e);
   }
   return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps);
  }
 }
 get(e, n = {}) {
  if (this._document) {
   const r = this._document.data.field(If("DocumentSnapshot.get", e));
   if (r !== null) return this._userDataWriter.convertValue(r, n.serverTimestamps);
  }
 }
}
class Rc extends GP {
 data(e = {}) {
  return super.data(e);
 }
}
class zP {
 constructor(e, n, r, i) {
  (this._firestore = e),
   (this._userDataWriter = n),
   (this._snapshot = i),
   (this.metadata = new La(i.hasPendingWrites, i.fromCache)),
   (this.query = r);
 }
 get docs() {
  const e = [];
  return this.forEach((n) => e.push(n)), e;
 }
 get size() {
  return this._snapshot.docs.size;
 }
 get empty() {
  return this.size === 0;
 }
 forEach(e, n) {
  this._snapshot.docs.forEach((r) => {
   e.call(
    n,
    new Rc(
     this._firestore,
     this._userDataWriter,
     r.key,
     r,
     new La(this._snapshot.mutatedKeys.has(r.key), this._snapshot.fromCache),
     this.query.converter
    )
   );
  });
 }
 docChanges(e = {}) {
  const n = !!e.includeMetadataChanges;
  if (n && this._snapshot.excludesMetadataChanges)
   throw new J(
    B.INVALID_ARGUMENT,
    "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot()."
   );
  return (
   (this._cachedChanges && this._cachedChangesIncludeMetadataChanges === n) ||
    ((this._cachedChanges = (function (i, o) {
     if (i._snapshot.oldDocs.isEmpty()) {
      let s = 0;
      return i._snapshot.docChanges.map((a) => {
       const l = new Rc(
        i._firestore,
        i._userDataWriter,
        a.doc.key,
        a.doc,
        new La(i._snapshot.mutatedKeys.has(a.doc.key), i._snapshot.fromCache),
        i.query.converter
       );
       return a.doc, { type: "added", doc: l, oldIndex: -1, newIndex: s++ };
      });
     }
     {
      let s = i._snapshot.oldDocs;
      return i._snapshot.docChanges
       .filter((a) => o || a.type !== 3)
       .map((a) => {
        const l = new Rc(
         i._firestore,
         i._userDataWriter,
         a.doc.key,
         a.doc,
         new La(i._snapshot.mutatedKeys.has(a.doc.key), i._snapshot.fromCache),
         i.query.converter
        );
        let u = -1,
         h = -1;
        return (
         a.type !== 0 && ((u = s.indexOf(a.doc.key)), (s = s.delete(a.doc.key))),
         a.type !== 1 && ((s = s.add(a.doc)), (h = s.indexOf(a.doc.key))),
         { type: F$(a.type), doc: l, oldIndex: u, newIndex: h }
        );
       });
     }
    })(this, n)),
    (this._cachedChangesIncludeMetadataChanges = n)),
   this._cachedChanges
  );
 }
}
function F$(t) {
 switch (t) {
  case 0:
   return "added";
  case 2:
  case 3:
   return "modified";
  case 1:
   return "removed";
  default:
   return ne();
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Kr(t) {
 t = Nt(t, xt);
 const e = Nt(t.firestore, zn);
 return E$(Ys(e), t._key).then((n) => WP(e, t, n));
}
class Af extends U$ {
 constructor(e) {
  super(), (this.firestore = e);
 }
 convertBytes(e) {
  return new Ls(e);
 }
 convertReference(e) {
  const n = this.convertDocumentKey(e, this.firestore._databaseId);
  return new xt(this.firestore, null, n);
 }
}
function Ve(t) {
 t = Nt(t, Or);
 const e = Nt(t.firestore, zn),
  n = Ys(e),
  r = new Af(e);
 return HP(t._query), T$(n, t._query).then((i) => new zP(e, r, t, i));
}
function Jr(t, e, n) {
 t = Nt(t, xt);
 const r = Nt(t.firestore, zn),
  i = rv(t.converter, e, n);
 return ou(r, [Ky(ru(r), "setDoc", t._key, i, t.converter !== null, n).toMutation(t._key, Ht.none())]);
}
function Yt(t, e, n, ...r) {
 t = Nt(t, xt);
 const i = Nt(t.firestore, zn),
  o = ru(i);
 let s;
 return (
  (s =
   typeof (e = Se(e)) == "string" || e instanceof tu
    ? UP(o, "updateDoc", t._key, e, n, r)
    : VP(o, "updateDoc", t._key, e)),
  ou(i, [s.toMutation(t._key, Ht.exists(!0))])
 );
}
function Mn(t) {
 return ou(Nt(t.firestore, zn), [new mf(t._key, Ht.none())]);
}
function Yn(t, e) {
 const n = Nt(t.firestore, zn),
  r = ee(t),
  i = rv(t.converter, e);
 return ou(n, [
  Ky(ru(t.firestore), "addDoc", r._key, i, t.converter !== null, {}).toMutation(r._key, Ht.exists(!1)),
 ]).then(() => r);
}
function vE(t, ...e) {
 var n, r, i;
 t = Se(t);
 let o = { includeMetadataChanges: !1, source: "default" },
  s = 0;
 typeof e[s] != "object" || pE(e[s]) || ((o = e[s]), s++);
 const a = { includeMetadataChanges: o.includeMetadataChanges, source: o.source };
 if (pE(e[s])) {
  const p = e[s];
  (e[s] = (n = p.next) === null || n === void 0 ? void 0 : n.bind(p)),
   (e[s + 1] = (r = p.error) === null || r === void 0 ? void 0 : r.bind(p)),
   (e[s + 2] = (i = p.complete) === null || i === void 0 ? void 0 : i.bind(p));
 }
 let l, u, h;
 if (t instanceof xt)
  (u = Nt(t.firestore, zn)),
   (h = cf(t._key.path)),
   (l = {
    next: (p) => {
     e[s] && e[s](WP(u, t, p));
    },
    error: e[s + 1],
    complete: e[s + 2],
   });
 else {
  const p = Nt(t, Or);
  (u = Nt(p.firestore, zn)), (h = p._query);
  const m = new Af(u);
  (l = {
   next: (v) => {
    e[s] && e[s](new zP(u, m, p, v));
   },
   error: e[s + 1],
   complete: e[s + 2],
  }),
   HP(t._query);
 }
 return (function (m, v, w, C) {
  const A = new Hy(C),
   T = new By(v, A, w);
  return (
   m.asyncQueue.enqueueAndForget(async () => Uy(await Id(m), T)),
   () => {
    A.Za(), m.asyncQueue.enqueueAndForget(async () => Oy(await Id(m), T));
   }
  );
 })(Ys(u), h, a, l);
}
function ou(t, e) {
 return (function (r, i) {
  const o = new or();
  return r.asyncQueue.enqueueAndForget(async () => u$(await _$(r), i, o)), o.promise;
 })(Ys(t), e);
}
function WP(t, e, n) {
 const r = n.docs.get(e._key),
  i = new Af(t);
 return new GP(t, i, e._key, r, new La(n.hasPendingWrites, n.fromCache), e.converter);
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Yu(t) {
 return B$(t, { count: O$() });
}
function B$(t, e) {
 const n = Nt(t.firestore, zn),
  r = Ys(n),
  i = tB(e, (o, s) => new DB(s, o.aggregateType, o._internalFieldPath));
 return I$(r, t._query, i).then((o) =>
  (function (a, l, u) {
   const h = new Af(a);
   return new b$(l, h, u);
  })(n, t, o)
 );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class $$ {
 constructor(e, n) {
  (this._firestore = e),
   (this._commitHandler = n),
   (this._mutations = []),
   (this._committed = !1),
   (this._dataReader = ru(e));
 }
 set(e, n, r) {
  this._verifyNotCommitted();
  const i = Gh(e, this._firestore),
   o = rv(i.converter, n, r),
   s = Ky(this._dataReader, "WriteBatch.set", i._key, o, i.converter !== null, r);
  return this._mutations.push(s.toMutation(i._key, Ht.none())), this;
 }
 update(e, n, r, ...i) {
  this._verifyNotCommitted();
  const o = Gh(e, this._firestore);
  let s;
  return (
   (s =
    typeof (n = Se(n)) == "string" || n instanceof tu
     ? UP(this._dataReader, "WriteBatch.update", o._key, n, r, i)
     : VP(this._dataReader, "WriteBatch.update", o._key, n)),
   this._mutations.push(s.toMutation(o._key, Ht.exists(!0))),
   this
  );
 }
 delete(e) {
  this._verifyNotCommitted();
  const n = Gh(e, this._firestore);
  return (this._mutations = this._mutations.concat(new mf(n._key, Ht.none()))), this;
 }
 commit() {
  return (
   this._verifyNotCommitted(),
   (this._committed = !0),
   this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
  );
 }
 _verifyNotCommitted() {
  if (this._committed)
   throw new J(B.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
 }
}
function Gh(t, e) {
 if ((t = Se(t)).firestore !== e)
  throw new J(B.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
 return t;
}
function Ta() {
 return new Jy("serverTimestamp");
}
function H$(t) {
 return new Yy("increment", t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Fo(t) {
 return Ys((t = Nt(t, zn))), new $$(t, (e) => ou(t, e));
}
(function (e, n = !0) {
 (function (i) {
  zs = i;
 })(ko),
  Hn(
   new Pn(
    "firestore",
    (r, { instanceIdentifier: i, options: o }) => {
     const s = r.getProvider("app").getImmediate(),
      a = new zn(
       new $F(r.getProvider("auth-internal")),
       new zF(r.getProvider("app-check-internal")),
       (function (u, h) {
        if (!Object.prototype.hasOwnProperty.apply(u.options, ["projectId"]))
         throw new J(B.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
        return new Sl(u.options.projectId, h);
       })(s, i),
       s
      );
     return (o = Object.assign({ useFetchStreams: n }, o)), a._setSettings(o), a;
    },
    "PUBLIC"
   ).setMultipleInstances(!0)
  ),
  rn(N0, "4.7.3", e),
  rn(N0, "4.7.3", "esm2017");
})();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const KP = "firebasestorage.googleapis.com",
 JP = "storageBucket",
 q$ = 2 * 60 * 1e3,
 G$ = 10 * 60 * 1e3;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ze extends bn {
 constructor(e, n, r = 0) {
  super(zh(e), `Firebase Storage: ${n} (${zh(e)})`),
   (this.status_ = r),
   (this.customData = { serverResponse: null }),
   (this._baseMessage = this.message),
   Object.setPrototypeOf(this, ze.prototype);
 }
 get status() {
  return this.status_;
 }
 set status(e) {
  this.status_ = e;
 }
 _codeEquals(e) {
  return zh(e) === this.code;
 }
 get serverResponse() {
  return this.customData.serverResponse;
 }
 set serverResponse(e) {
  (this.customData.serverResponse = e),
   this.customData.serverResponse
    ? (this.message = `${this._baseMessage}
${this.customData.serverResponse}`)
    : (this.message = this._baseMessage);
 }
}
var qe;
(function (t) {
 (t.UNKNOWN = "unknown"),
  (t.OBJECT_NOT_FOUND = "object-not-found"),
  (t.BUCKET_NOT_FOUND = "bucket-not-found"),
  (t.PROJECT_NOT_FOUND = "project-not-found"),
  (t.QUOTA_EXCEEDED = "quota-exceeded"),
  (t.UNAUTHENTICATED = "unauthenticated"),
  (t.UNAUTHORIZED = "unauthorized"),
  (t.UNAUTHORIZED_APP = "unauthorized-app"),
  (t.RETRY_LIMIT_EXCEEDED = "retry-limit-exceeded"),
  (t.INVALID_CHECKSUM = "invalid-checksum"),
  (t.CANCELED = "canceled"),
  (t.INVALID_EVENT_NAME = "invalid-event-name"),
  (t.INVALID_URL = "invalid-url"),
  (t.INVALID_DEFAULT_BUCKET = "invalid-default-bucket"),
  (t.NO_DEFAULT_BUCKET = "no-default-bucket"),
  (t.CANNOT_SLICE_BLOB = "cannot-slice-blob"),
  (t.SERVER_FILE_WRONG_SIZE = "server-file-wrong-size"),
  (t.NO_DOWNLOAD_URL = "no-download-url"),
  (t.INVALID_ARGUMENT = "invalid-argument"),
  (t.INVALID_ARGUMENT_COUNT = "invalid-argument-count"),
  (t.APP_DELETED = "app-deleted"),
  (t.INVALID_ROOT_OPERATION = "invalid-root-operation"),
  (t.INVALID_FORMAT = "invalid-format"),
  (t.INTERNAL_ERROR = "internal-error"),
  (t.UNSUPPORTED_ENVIRONMENT = "unsupported-environment");
})(qe || (qe = {}));
function zh(t) {
 return "storage/" + t;
}
function iv() {
 const t = "An unknown error occurred, please check the error payload for server response.";
 return new ze(qe.UNKNOWN, t);
}
function z$(t) {
 return new ze(qe.OBJECT_NOT_FOUND, "Object '" + t + "' does not exist.");
}
function W$(t) {
 return new ze(
  qe.QUOTA_EXCEEDED,
  "Quota for bucket '" + t + "' exceeded, please view quota on https://firebase.google.com/pricing/."
 );
}
function K$() {
 const t = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
 return new ze(qe.UNAUTHENTICATED, t);
}
function J$() {
 return new ze(qe.UNAUTHORIZED_APP, "This app does not have permission to access Firebase Storage on this project.");
}
function Y$(t) {
 return new ze(qe.UNAUTHORIZED, "User does not have permission to access '" + t + "'.");
}
function Q$() {
 return new ze(qe.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again.");
}
function X$() {
 return new ze(qe.CANCELED, "User canceled the upload/download.");
}
function j$(t) {
 return new ze(qe.INVALID_URL, "Invalid URL '" + t + "'.");
}
function Z$(t) {
 return new ze(qe.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + t + "'.");
}
function eH() {
 return new ze(
  qe.NO_DEFAULT_BUCKET,
  "No default bucket found. Did you set the '" + JP + "' property when initializing the app?"
 );
}
function tH() {
 return new ze(qe.CANNOT_SLICE_BLOB, "Cannot slice blob for upload. Please retry the upload.");
}
function nH() {
 return new ze(qe.NO_DOWNLOAD_URL, "The given file does not have any download URLs.");
}
function rH(t) {
 return new ze(
  qe.UNSUPPORTED_ENVIRONMENT,
  `${t} is missing. Make sure to install the required polyfills. See https://firebase.google.com/docs/web/environments-js-sdk#polyfills for more information.`
 );
}
function Cm(t) {
 return new ze(qe.INVALID_ARGUMENT, t);
}
function YP() {
 return new ze(qe.APP_DELETED, "The Firebase app was deleted.");
}
function iH(t) {
 return new ze(
  qe.INVALID_ROOT_OPERATION,
  "The operation '" +
   t +
   "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png')."
 );
}
function Xa(t, e) {
 return new ze(qe.INVALID_FORMAT, "String does not match format '" + t + "': " + e);
}
function Ia(t) {
 throw new ze(qe.INTERNAL_ERROR, "Internal error: " + t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class cn {
 constructor(e, n) {
  (this.bucket = e), (this.path_ = n);
 }
 get path() {
  return this.path_;
 }
 get isRoot() {
  return this.path.length === 0;
 }
 fullServerUrl() {
  const e = encodeURIComponent;
  return "/b/" + e(this.bucket) + "/o/" + e(this.path);
 }
 bucketOnlyServerUrl() {
  return "/b/" + encodeURIComponent(this.bucket) + "/o";
 }
 static makeFromBucketSpec(e, n) {
  let r;
  try {
   r = cn.makeFromUrl(e, n);
  } catch {
   return new cn(e, "");
  }
  if (r.path === "") return r;
  throw Z$(e);
 }
 static makeFromUrl(e, n) {
  let r = null;
  const i = "([A-Za-z0-9.\\-_]+)";
  function o(N) {
   N.path.charAt(N.path.length - 1) === "/" && (N.path_ = N.path_.slice(0, -1));
  }
  const s = "(/(.*))?$",
   a = new RegExp("^gs://" + i + s, "i"),
   l = { bucket: 1, path: 3 };
  function u(N) {
   N.path_ = decodeURIComponent(N.path);
  }
  const h = "v[A-Za-z0-9_]+",
   p = n.replace(/[.]/g, "\\."),
   m = "(/([^?#]*).*)?$",
   v = new RegExp(`^https?://${p}/${h}/b/${i}/o${m}`, "i"),
   w = { bucket: 1, path: 3 },
   C = n === KP ? "(?:storage.googleapis.com|storage.cloud.google.com)" : n,
   A = "([^?#]*)",
   T = new RegExp(`^https?://${C}/${i}/${A}`, "i"),
   E = [
    { regex: a, indices: l, postModify: o },
    { regex: v, indices: w, postModify: u },
    { regex: T, indices: { bucket: 1, path: 2 }, postModify: u },
   ];
  for (let N = 0; N < E.length; N++) {
   const M = E[N],
    F = M.regex.exec(e);
   if (F) {
    const P = F[M.indices.bucket];
    let I = F[M.indices.path];
    I || (I = ""), (r = new cn(P, I)), M.postModify(r);
    break;
   }
  }
  if (r == null) throw j$(e);
  return r;
 }
}
class oH {
 constructor(e) {
  this.promise_ = Promise.reject(e);
 }
 getPromise() {
  return this.promise_;
 }
 cancel(e = !1) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function sH(t, e, n) {
 let r = 1,
  i = null,
  o = null,
  s = !1,
  a = 0;
 function l() {
  return a === 2;
 }
 let u = !1;
 function h(...A) {
  u || ((u = !0), e.apply(null, A));
 }
 function p(A) {
  i = setTimeout(() => {
   (i = null), t(v, l());
  }, A);
 }
 function m() {
  o && clearTimeout(o);
 }
 function v(A, ...T) {
  if (u) {
   m();
   return;
  }
  if (A) {
   m(), h.call(null, A, ...T);
   return;
  }
  if (l() || s) {
   m(), h.call(null, A, ...T);
   return;
  }
  r < 64 && (r *= 2);
  let E;
  a === 1 ? ((a = 2), (E = 0)) : (E = (r + Math.random()) * 1e3), p(E);
 }
 let w = !1;
 function C(A) {
  w || ((w = !0), m(), !u && (i !== null ? (A || (a = 2), clearTimeout(i), p(0)) : A || (a = 1)));
 }
 return (
  p(0),
  (o = setTimeout(() => {
   (s = !0), C(!0);
  }, n)),
  C
 );
}
function aH(t) {
 t(!1);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function lH(t) {
 return t !== void 0;
}
function uH(t) {
 return typeof t == "object" && !Array.isArray(t);
}
function ov(t) {
 return typeof t == "string" || t instanceof String;
}
function _E(t) {
 return sv() && t instanceof Blob;
}
function sv() {
 return typeof Blob < "u";
}
function wE(t, e, n, r) {
 if (r < e) throw Cm(`Invalid value for '${t}'. Expected ${e} or greater.`);
 if (r > n) throw Cm(`Invalid value for '${t}'. Expected ${n} or less.`);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function av(t, e, n) {
 let r = e;
 return n == null && (r = `https://${e}`), `${n}://${r}/v0${t}`;
}
function QP(t) {
 const e = encodeURIComponent;
 let n = "?";
 for (const r in t)
  if (t.hasOwnProperty(r)) {
   const i = e(r) + "=" + e(t[r]);
   n = n + i + "&";
  }
 return (n = n.slice(0, -1)), n;
}
var so;
(function (t) {
 (t[(t.NO_ERROR = 0)] = "NO_ERROR"), (t[(t.NETWORK_ERROR = 1)] = "NETWORK_ERROR"), (t[(t.ABORT = 2)] = "ABORT");
})(so || (so = {}));
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function cH(t, e) {
 const n = t >= 500 && t < 600,
  i = [408, 429].indexOf(t) !== -1,
  o = e.indexOf(t) !== -1;
 return n || i || o;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class dH {
 constructor(e, n, r, i, o, s, a, l, u, h, p, m = !0) {
  (this.url_ = e),
   (this.method_ = n),
   (this.headers_ = r),
   (this.body_ = i),
   (this.successCodes_ = o),
   (this.additionalRetryCodes_ = s),
   (this.callback_ = a),
   (this.errorCallback_ = l),
   (this.timeout_ = u),
   (this.progressCallback_ = h),
   (this.connectionFactory_ = p),
   (this.retry = m),
   (this.pendingConnection_ = null),
   (this.backoffId_ = null),
   (this.canceled_ = !1),
   (this.appDelete_ = !1),
   (this.promise_ = new Promise((v, w) => {
    (this.resolve_ = v), (this.reject_ = w), this.start_();
   }));
 }
 start_() {
  const e = (r, i) => {
    if (i) {
     r(!1, new Qu(!1, null, !0));
     return;
    }
    const o = this.connectionFactory_();
    this.pendingConnection_ = o;
    const s = (a) => {
     const l = a.loaded,
      u = a.lengthComputable ? a.total : -1;
     this.progressCallback_ !== null && this.progressCallback_(l, u);
    };
    this.progressCallback_ !== null && o.addUploadProgressListener(s),
     o.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
      this.progressCallback_ !== null && o.removeUploadProgressListener(s), (this.pendingConnection_ = null);
      const a = o.getErrorCode() === so.NO_ERROR,
       l = o.getStatus();
      if (!a || (cH(l, this.additionalRetryCodes_) && this.retry)) {
       const h = o.getErrorCode() === so.ABORT;
       r(!1, new Qu(!1, null, h));
       return;
      }
      const u = this.successCodes_.indexOf(l) !== -1;
      r(!0, new Qu(u, o));
     });
   },
   n = (r, i) => {
    const o = this.resolve_,
     s = this.reject_,
     a = i.connection;
    if (i.wasSuccessCode)
     try {
      const l = this.callback_(a, a.getResponse());
      lH(l) ? o(l) : o();
     } catch (l) {
      s(l);
     }
    else if (a !== null) {
     const l = iv();
     (l.serverResponse = a.getErrorText()), this.errorCallback_ ? s(this.errorCallback_(a, l)) : s(l);
    } else if (i.canceled) {
     const l = this.appDelete_ ? YP() : X$();
     s(l);
    } else {
     const l = Q$();
     s(l);
    }
   };
  this.canceled_ ? n(!1, new Qu(!1, null, !0)) : (this.backoffId_ = sH(e, n, this.timeout_));
 }
 getPromise() {
  return this.promise_;
 }
 cancel(e) {
  (this.canceled_ = !0),
   (this.appDelete_ = e || !1),
   this.backoffId_ !== null && aH(this.backoffId_),
   this.pendingConnection_ !== null && this.pendingConnection_.abort();
 }
}
class Qu {
 constructor(e, n, r) {
  (this.wasSuccessCode = e), (this.connection = n), (this.canceled = !!r);
 }
}
function fH(t, e) {
 e !== null && e.length > 0 && (t.Authorization = "Firebase " + e);
}
function hH(t, e) {
 t["X-Firebase-Storage-Version"] = "webjs/" + (e ?? "AppManager");
}
function pH(t, e) {
 e && (t["X-Firebase-GMPID"] = e);
}
function mH(t, e) {
 e !== null && (t["X-Firebase-AppCheck"] = e);
}
function gH(t, e, n, r, i, o, s = !0) {
 const a = QP(t.urlParams),
  l = t.url + a,
  u = Object.assign({}, t.headers);
 return (
  pH(u, e),
  fH(u, n),
  hH(u, o),
  mH(u, r),
  new dH(
   l,
   t.method,
   u,
   t.body,
   t.successCodes,
   t.additionalRetryCodes,
   t.handler,
   t.errorHandler,
   t.timeout,
   t.progressCallback,
   i,
   s
  )
 );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function yH() {
 return typeof BlobBuilder < "u" ? BlobBuilder : typeof WebKitBlobBuilder < "u" ? WebKitBlobBuilder : void 0;
}
function vH(...t) {
 const e = yH();
 if (e !== void 0) {
  const n = new e();
  for (let r = 0; r < t.length; r++) n.append(t[r]);
  return n.getBlob();
 } else {
  if (sv()) return new Blob(t);
  throw new ze(qe.UNSUPPORTED_ENVIRONMENT, "This browser doesn't seem to support creating Blobs");
 }
}
function _H(t, e, n) {
 return t.webkitSlice ? t.webkitSlice(e, n) : t.mozSlice ? t.mozSlice(e, n) : t.slice ? t.slice(e, n) : null;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function wH(t) {
 if (typeof atob > "u") throw rH("base-64");
 return atob(t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const er = { RAW: "raw", BASE64: "base64", BASE64URL: "base64url", DATA_URL: "data_url" };
class Wh {
 constructor(e, n) {
  (this.data = e), (this.contentType = n || null);
 }
}
function EH(t, e) {
 switch (t) {
  case er.RAW:
   return new Wh(XP(e));
  case er.BASE64:
  case er.BASE64URL:
   return new Wh(jP(t, e));
  case er.DATA_URL:
   return new Wh(IH(e), SH(e));
 }
 throw iv();
}
function XP(t) {
 const e = [];
 for (let n = 0; n < t.length; n++) {
  let r = t.charCodeAt(n);
  if (r <= 127) e.push(r);
  else if (r <= 2047) e.push(192 | (r >> 6), 128 | (r & 63));
  else if ((r & 64512) === 55296)
   if (!(n < t.length - 1 && (t.charCodeAt(n + 1) & 64512) === 56320)) e.push(239, 191, 189);
   else {
    const o = r,
     s = t.charCodeAt(++n);
    (r = 65536 | ((o & 1023) << 10) | (s & 1023)),
     e.push(240 | (r >> 18), 128 | ((r >> 12) & 63), 128 | ((r >> 6) & 63), 128 | (r & 63));
   }
  else (r & 64512) === 56320 ? e.push(239, 191, 189) : e.push(224 | (r >> 12), 128 | ((r >> 6) & 63), 128 | (r & 63));
 }
 return new Uint8Array(e);
}
function TH(t) {
 let e;
 try {
  e = decodeURIComponent(t);
 } catch {
  throw Xa(er.DATA_URL, "Malformed data URL.");
 }
 return XP(e);
}
function jP(t, e) {
 switch (t) {
  case er.BASE64: {
   const i = e.indexOf("-") !== -1,
    o = e.indexOf("_") !== -1;
   if (i || o) throw Xa(t, "Invalid character '" + (i ? "-" : "_") + "' found: is it base64url encoded?");
   break;
  }
  case er.BASE64URL: {
   const i = e.indexOf("+") !== -1,
    o = e.indexOf("/") !== -1;
   if (i || o) throw Xa(t, "Invalid character '" + (i ? "+" : "/") + "' found: is it base64 encoded?");
   e = e.replace(/-/g, "+").replace(/_/g, "/");
   break;
  }
 }
 let n;
 try {
  n = wH(e);
 } catch (i) {
  throw i.message.includes("polyfill") ? i : Xa(t, "Invalid character found");
 }
 const r = new Uint8Array(n.length);
 for (let i = 0; i < n.length; i++) r[i] = n.charCodeAt(i);
 return r;
}
class ZP {
 constructor(e) {
  (this.base64 = !1), (this.contentType = null);
  const n = e.match(/^data:([^,]+)?,/);
  if (n === null) throw Xa(er.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
  const r = n[1] || null;
  r != null && ((this.base64 = AH(r, ";base64")), (this.contentType = this.base64 ? r.substring(0, r.length - 7) : r)),
   (this.rest = e.substring(e.indexOf(",") + 1));
 }
}
function IH(t) {
 const e = new ZP(t);
 return e.base64 ? jP(er.BASE64, e.rest) : TH(e.rest);
}
function SH(t) {
 return new ZP(t).contentType;
}
function AH(t, e) {
 return t.length >= e.length ? t.substring(t.length - e.length) === e : !1;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ii {
 constructor(e, n) {
  let r = 0,
   i = "";
  _E(e)
   ? ((this.data_ = e), (r = e.size), (i = e.type))
   : e instanceof ArrayBuffer
     ? (n
        ? (this.data_ = new Uint8Array(e))
        : ((this.data_ = new Uint8Array(e.byteLength)), this.data_.set(new Uint8Array(e))),
       (r = this.data_.length))
     : e instanceof Uint8Array &&
       (n ? (this.data_ = e) : ((this.data_ = new Uint8Array(e.length)), this.data_.set(e)), (r = e.length)),
   (this.size_ = r),
   (this.type_ = i);
 }
 size() {
  return this.size_;
 }
 type() {
  return this.type_;
 }
 slice(e, n) {
  if (_E(this.data_)) {
   const r = this.data_,
    i = _H(r, e, n);
   return i === null ? null : new ii(i);
  } else {
   const r = new Uint8Array(this.data_.buffer, e, n - e);
   return new ii(r, !0);
  }
 }
 static getBlob(...e) {
  if (sv()) {
   const n = e.map((r) => (r instanceof ii ? r.data_ : r));
   return new ii(vH.apply(null, n));
  } else {
   const n = e.map((s) => (ov(s) ? EH(er.RAW, s).data : s.data_));
   let r = 0;
   n.forEach((s) => {
    r += s.byteLength;
   });
   const i = new Uint8Array(r);
   let o = 0;
   return (
    n.forEach((s) => {
     for (let a = 0; a < s.length; a++) i[o++] = s[a];
    }),
    new ii(i, !0)
   );
  }
 }
 uploadData() {
  return this.data_;
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function ek(t) {
 let e;
 try {
  e = JSON.parse(t);
 } catch {
  return null;
 }
 return uH(e) ? e : null;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function CH(t) {
 if (t.length === 0) return null;
 const e = t.lastIndexOf("/");
 return e === -1 ? "" : t.slice(0, e);
}
function RH(t, e) {
 const n = e
  .split("/")
  .filter((r) => r.length > 0)
  .join("/");
 return t.length === 0 ? n : t + "/" + n;
}
function tk(t) {
 const e = t.lastIndexOf("/", t.length - 2);
 return e === -1 ? t : t.slice(e + 1);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function PH(t, e) {
 return e;
}
class Ot {
 constructor(e, n, r, i) {
  (this.server = e), (this.local = n || e), (this.writable = !!r), (this.xform = i || PH);
 }
}
let Xu = null;
function kH(t) {
 return !ov(t) || t.length < 2 ? t : tk(t);
}
function nk() {
 if (Xu) return Xu;
 const t = [];
 t.push(new Ot("bucket")),
  t.push(new Ot("generation")),
  t.push(new Ot("metageneration")),
  t.push(new Ot("name", "fullPath", !0));
 function e(o, s) {
  return kH(s);
 }
 const n = new Ot("name");
 (n.xform = e), t.push(n);
 function r(o, s) {
  return s !== void 0 ? Number(s) : s;
 }
 const i = new Ot("size");
 return (
  (i.xform = r),
  t.push(i),
  t.push(new Ot("timeCreated")),
  t.push(new Ot("updated")),
  t.push(new Ot("md5Hash", null, !0)),
  t.push(new Ot("cacheControl", null, !0)),
  t.push(new Ot("contentDisposition", null, !0)),
  t.push(new Ot("contentEncoding", null, !0)),
  t.push(new Ot("contentLanguage", null, !0)),
  t.push(new Ot("contentType", null, !0)),
  t.push(new Ot("metadata", "customMetadata", !0)),
  (Xu = t),
  Xu
 );
}
function bH(t, e) {
 function n() {
  const r = t.bucket,
   i = t.fullPath,
   o = new cn(r, i);
  return e._makeStorageReference(o);
 }
 Object.defineProperty(t, "ref", { get: n });
}
function NH(t, e, n) {
 const r = {};
 r.type = "file";
 const i = n.length;
 for (let o = 0; o < i; o++) {
  const s = n[o];
  r[s.local] = s.xform(r, e[s.server]);
 }
 return bH(r, t), r;
}
function rk(t, e, n) {
 const r = ek(e);
 return r === null ? null : NH(t, r, n);
}
function xH(t, e, n, r) {
 const i = ek(e);
 if (i === null || !ov(i.downloadTokens)) return null;
 const o = i.downloadTokens;
 if (o.length === 0) return null;
 const s = encodeURIComponent;
 return o.split(",").map((u) => {
  const h = t.bucket,
   p = t.fullPath,
   m = "/b/" + s(h) + "/o/" + s(p),
   v = av(m, n, r),
   w = QP({ alt: "media", token: u });
  return v + w;
 })[0];
}
function MH(t, e) {
 const n = {},
  r = e.length;
 for (let i = 0; i < r; i++) {
  const o = e[i];
  o.writable && (n[o.server] = t[o.local]);
 }
 return JSON.stringify(n);
}
class ik {
 constructor(e, n, r, i) {
  (this.url = e),
   (this.method = n),
   (this.handler = r),
   (this.timeout = i),
   (this.urlParams = {}),
   (this.headers = {}),
   (this.body = null),
   (this.errorHandler = null),
   (this.progressCallback = null),
   (this.successCodes = [200]),
   (this.additionalRetryCodes = []);
 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function ok(t) {
 if (!t) throw iv();
}
function DH(t, e) {
 function n(r, i) {
  const o = rk(t, i, e);
  return ok(o !== null), o;
 }
 return n;
}
function LH(t, e) {
 function n(r, i) {
  const o = rk(t, i, e);
  return ok(o !== null), xH(o, i, t.host, t._protocol);
 }
 return n;
}
function sk(t) {
 function e(n, r) {
  let i;
  return (
   n.getStatus() === 401
    ? n.getErrorText().includes("Firebase App Check token is invalid")
      ? (i = J$())
      : (i = K$())
    : n.getStatus() === 402
      ? (i = W$(t.bucket))
      : n.getStatus() === 403
        ? (i = Y$(t.path))
        : (i = r),
   (i.status = n.getStatus()),
   (i.serverResponse = r.serverResponse),
   i
  );
 }
 return e;
}
function VH(t) {
 const e = sk(t);
 function n(r, i) {
  let o = e(r, i);
  return r.getStatus() === 404 && (o = z$(t.path)), (o.serverResponse = i.serverResponse), o;
 }
 return n;
}
function UH(t, e, n) {
 const r = e.fullServerUrl(),
  i = av(r, t.host, t._protocol),
  o = "GET",
  s = t.maxOperationRetryTime,
  a = new ik(i, o, LH(t, n), s);
 return (a.errorHandler = VH(e)), a;
}
function OH(t, e) {
 return (t && t.contentType) || (e && e.type()) || "application/octet-stream";
}
function FH(t, e, n) {
 const r = Object.assign({}, n);
 return (r.fullPath = t.path), (r.size = e.size()), r.contentType || (r.contentType = OH(null, e)), r;
}
function BH(t, e, n, r, i) {
 const o = e.bucketOnlyServerUrl(),
  s = { "X-Goog-Upload-Protocol": "multipart" };
 function a() {
  let E = "";
  for (let N = 0; N < 2; N++) E = E + Math.random().toString().slice(2);
  return E;
 }
 const l = a();
 s["Content-Type"] = "multipart/related; boundary=" + l;
 const u = FH(e, r, i),
  h = MH(u, n),
  p =
   "--" +
   l +
   `\r
Content-Type: application/json; charset=utf-8\r
\r
` +
   h +
   `\r
--` +
   l +
   `\r
Content-Type: ` +
   u.contentType +
   `\r
\r
`,
  m =
   `\r
--` +
   l +
   "--",
  v = ii.getBlob(p, r, m);
 if (v === null) throw tH();
 const w = { name: u.fullPath },
  C = av(o, t.host, t._protocol),
  A = "POST",
  T = t.maxUploadRetryTime,
  _ = new ik(C, A, DH(t, n), T);
 return (_.urlParams = w), (_.headers = s), (_.body = v.uploadData()), (_.errorHandler = sk(e)), _;
}
class $H {
 constructor() {
  (this.sent_ = !1),
   (this.xhr_ = new XMLHttpRequest()),
   this.initXhr(),
   (this.errorCode_ = so.NO_ERROR),
   (this.sendPromise_ = new Promise((e) => {
    this.xhr_.addEventListener("abort", () => {
     (this.errorCode_ = so.ABORT), e();
    }),
     this.xhr_.addEventListener("error", () => {
      (this.errorCode_ = so.NETWORK_ERROR), e();
     }),
     this.xhr_.addEventListener("load", () => {
      e();
     });
   }));
 }
 send(e, n, r, i) {
  if (this.sent_) throw Ia("cannot .send() more than once");
  if (((this.sent_ = !0), this.xhr_.open(n, e, !0), i !== void 0))
   for (const o in i) i.hasOwnProperty(o) && this.xhr_.setRequestHeader(o, i[o].toString());
  return r !== void 0 ? this.xhr_.send(r) : this.xhr_.send(), this.sendPromise_;
 }
 getErrorCode() {
  if (!this.sent_) throw Ia("cannot .getErrorCode() before sending");
  return this.errorCode_;
 }
 getStatus() {
  if (!this.sent_) throw Ia("cannot .getStatus() before sending");
  try {
   return this.xhr_.status;
  } catch {
   return -1;
  }
 }
 getResponse() {
  if (!this.sent_) throw Ia("cannot .getResponse() before sending");
  return this.xhr_.response;
 }
 getErrorText() {
  if (!this.sent_) throw Ia("cannot .getErrorText() before sending");
  return this.xhr_.statusText;
 }
 abort() {
  this.xhr_.abort();
 }
 getResponseHeader(e) {
  return this.xhr_.getResponseHeader(e);
 }
 addUploadProgressListener(e) {
  this.xhr_.upload != null && this.xhr_.upload.addEventListener("progress", e);
 }
 removeUploadProgressListener(e) {
  this.xhr_.upload != null && this.xhr_.upload.removeEventListener("progress", e);
 }
}
class HH extends $H {
 initXhr() {
  this.xhr_.responseType = "text";
 }
}
function ak() {
 return new HH();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _o {
 constructor(e, n) {
  (this._service = e), n instanceof cn ? (this._location = n) : (this._location = cn.makeFromUrl(n, e.host));
 }
 toString() {
  return "gs://" + this._location.bucket + "/" + this._location.path;
 }
 _newRef(e, n) {
  return new _o(e, n);
 }
 get root() {
  const e = new cn(this._location.bucket, "");
  return this._newRef(this._service, e);
 }
 get bucket() {
  return this._location.bucket;
 }
 get fullPath() {
  return this._location.path;
 }
 get name() {
  return tk(this._location.path);
 }
 get storage() {
  return this._service;
 }
 get parent() {
  const e = CH(this._location.path);
  if (e === null) return null;
  const n = new cn(this._location.bucket, e);
  return new _o(this._service, n);
 }
 _throwIfRoot(e) {
  if (this._location.path === "") throw iH(e);
 }
}
function qH(t, e, n) {
 t._throwIfRoot("uploadBytes");
 const r = BH(t.storage, t._location, nk(), new ii(e, !0), n);
 return t.storage.makeRequestWithTokens(r, ak).then((i) => ({ metadata: i, ref: t }));
}
function GH(t) {
 t._throwIfRoot("getDownloadURL");
 const e = UH(t.storage, t._location, nk());
 return t.storage.makeRequestWithTokens(e, ak).then((n) => {
  if (n === null) throw nH();
  return n;
 });
}
function zH(t, e) {
 const n = RH(t._location.path, e),
  r = new cn(t._location.bucket, n);
 return new _o(t.storage, r);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function WH(t) {
 return /^[A-Za-z]+:\/\//.test(t);
}
function KH(t, e) {
 return new _o(t, e);
}
function lk(t, e) {
 if (t instanceof lv) {
  const n = t;
  if (n._bucket == null) throw eH();
  const r = new _o(n, n._bucket);
  return e != null ? lk(r, e) : r;
 } else return e !== void 0 ? zH(t, e) : t;
}
function JH(t, e) {
 if (e && WH(e)) {
  if (t instanceof lv) return KH(t, e);
  throw Cm("To use ref(service, url), the first argument must be a Storage instance.");
 } else return lk(t, e);
}
function EE(t, e) {
 const n = e == null ? void 0 : e[JP];
 return n == null ? null : cn.makeFromBucketSpec(n, t);
}
function YH(t, e, n, r = {}) {
 (t.host = `${e}:${n}`), (t._protocol = "http");
 const { mockUserToken: i } = r;
 i && (t._overrideAuthToken = typeof i == "string" ? i : VC(i, t.app.options.projectId));
}
class lv {
 constructor(e, n, r, i, o) {
  (this.app = e),
   (this._authProvider = n),
   (this._appCheckProvider = r),
   (this._url = i),
   (this._firebaseVersion = o),
   (this._bucket = null),
   (this._host = KP),
   (this._protocol = "https"),
   (this._appId = null),
   (this._deleted = !1),
   (this._maxOperationRetryTime = q$),
   (this._maxUploadRetryTime = G$),
   (this._requests = new Set()),
   i != null
    ? (this._bucket = cn.makeFromBucketSpec(i, this._host))
    : (this._bucket = EE(this._host, this.app.options));
 }
 get host() {
  return this._host;
 }
 set host(e) {
  (this._host = e),
   this._url != null ? (this._bucket = cn.makeFromBucketSpec(this._url, e)) : (this._bucket = EE(e, this.app.options));
 }
 get maxUploadRetryTime() {
  return this._maxUploadRetryTime;
 }
 set maxUploadRetryTime(e) {
  wE("time", 0, Number.POSITIVE_INFINITY, e), (this._maxUploadRetryTime = e);
 }
 get maxOperationRetryTime() {
  return this._maxOperationRetryTime;
 }
 set maxOperationRetryTime(e) {
  wE("time", 0, Number.POSITIVE_INFINITY, e), (this._maxOperationRetryTime = e);
 }
 async _getAuthToken() {
  if (this._overrideAuthToken) return this._overrideAuthToken;
  const e = this._authProvider.getImmediate({ optional: !0 });
  if (e) {
   const n = await e.getToken();
   if (n !== null) return n.accessToken;
  }
  return null;
 }
 async _getAppCheckToken() {
  const e = this._appCheckProvider.getImmediate({ optional: !0 });
  return e ? (await e.getToken()).token : null;
 }
 _delete() {
  return (
   this._deleted || ((this._deleted = !0), this._requests.forEach((e) => e.cancel()), this._requests.clear()),
   Promise.resolve()
  );
 }
 _makeStorageReference(e) {
  return new _o(this, e);
 }
 _makeRequest(e, n, r, i, o = !0) {
  if (this._deleted) return new oH(YP());
  {
   const s = gH(e, this._appId, r, i, n, this._firebaseVersion, o);
   return (
    this._requests.add(s),
    s.getPromise().then(
     () => this._requests.delete(s),
     () => this._requests.delete(s)
    ),
    s
   );
  }
 }
 async makeRequestWithTokens(e, n) {
  const [r, i] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()]);
  return this._makeRequest(e, n, r, i).getPromise();
 }
}
const TE = "@firebase/storage",
 IE = "0.13.2";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const uk = "storage";
function QH(t, e, n) {
 return (t = Se(t)), qH(t, e, n);
}
function XH(t) {
 return (t = Se(t)), GH(t);
}
function jH(t, e) {
 return (t = Se(t)), JH(t, e);
}
function ZH(t = Gl(), e) {
 t = Se(t);
 const r = Mi(t, uk).getImmediate({ identifier: e }),
  i = MC("storage");
 return i && eq(r, ...i), r;
}
function eq(t, e, n, r = {}) {
 YH(t, e, n, r);
}
function tq(t, { instanceIdentifier: e }) {
 const n = t.getProvider("app").getImmediate(),
  r = t.getProvider("auth-internal"),
  i = t.getProvider("app-check-internal");
 return new lv(n, r, i, e, ko);
}
function nq() {
 Hn(new Pn(uk, tq, "PUBLIC").setMultipleInstances(!0)), rn(TE, IE, ""), rn(TE, IE, "esm2017");
}
nq();
const ck = "@firebase/installations",
 uv = "0.6.9";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const dk = 1e4,
 fk = `w:${uv}`,
 hk = "FIS_v2",
 rq = "https://firebaseinstallations.googleapis.com/v1",
 iq = 60 * 60 * 1e3,
 oq = "installations",
 sq = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const aq = {
  "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
  "not-registered": "Firebase Installation is not registered.",
  "installation-not-found": "Firebase Installation not found.",
  "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
  "app-offline": "Could not process request. Application offline.",
  "delete-pending-registration": "Can't delete installation while there is a pending registration request.",
 },
 wo = new Po(oq, sq, aq);
function pk(t) {
 return t instanceof bn && t.code.includes("request-failed");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function mk({ projectId: t }) {
 return `${rq}/projects/${t}/installations`;
}
function gk(t) {
 return { token: t.token, requestStatus: 2, expiresIn: uq(t.expiresIn), creationTime: Date.now() };
}
async function yk(t, e) {
 const r = (await e.json()).error;
 return wo.create("request-failed", {
  requestName: t,
  serverCode: r.code,
  serverMessage: r.message,
  serverStatus: r.status,
 });
}
function vk({ apiKey: t }) {
 return new Headers({ "Content-Type": "application/json", Accept: "application/json", "x-goog-api-key": t });
}
function lq(t, { refreshToken: e }) {
 const n = vk(t);
 return n.append("Authorization", cq(e)), n;
}
async function _k(t) {
 const e = await t();
 return e.status >= 500 && e.status < 600 ? t() : e;
}
function uq(t) {
 return Number(t.replace("s", "000"));
}
function cq(t) {
 return `${hk} ${t}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function dq({ appConfig: t, heartbeatServiceProvider: e }, { fid: n }) {
 const r = mk(t),
  i = vk(t),
  o = e.getImmediate({ optional: !0 });
 if (o) {
  const u = await o.getHeartbeatsHeader();
  u && i.append("x-firebase-client", u);
 }
 const s = { fid: n, authVersion: hk, appId: t.appId, sdkVersion: fk },
  a = { method: "POST", headers: i, body: JSON.stringify(s) },
  l = await _k(() => fetch(r, a));
 if (l.ok) {
  const u = await l.json();
  return { fid: u.fid || n, registrationStatus: 2, refreshToken: u.refreshToken, authToken: gk(u.authToken) };
 } else throw await yk("Create Installation", l);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function wk(t) {
 return new Promise((e) => {
  setTimeout(e, t);
 });
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function fq(t) {
 return btoa(String.fromCharCode(...t))
  .replace(/\+/g, "-")
  .replace(/\//g, "_");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const hq = /^[cdef][\w-]{21}$/,
 Rm = "";
function pq() {
 try {
  const t = new Uint8Array(17);
  (self.crypto || self.msCrypto).getRandomValues(t), (t[0] = 112 + (t[0] % 16));
  const n = mq(t);
  return hq.test(n) ? n : Rm;
 } catch {
  return Rm;
 }
}
function mq(t) {
 return fq(t).substr(0, 22);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Cf(t) {
 return `${t.appName}!${t.appId}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Ek = new Map();
function Tk(t, e) {
 const n = Cf(t);
 Ik(n, e), gq(n, e);
}
function Ik(t, e) {
 const n = Ek.get(t);
 if (n) for (const r of n) r(e);
}
function gq(t, e) {
 const n = yq();
 n && n.postMessage({ key: t, fid: e }), vq();
}
let to = null;
function yq() {
 return (
  !to &&
   "BroadcastChannel" in self &&
   ((to = new BroadcastChannel("[Firebase] FID Change")),
   (to.onmessage = (t) => {
    Ik(t.data.key, t.data.fid);
   })),
  to
 );
}
function vq() {
 Ek.size === 0 && to && (to.close(), (to = null));
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const _q = "firebase-installations-database",
 wq = 1,
 Eo = "firebase-installations-store";
let Kh = null;
function cv() {
 return (
  Kh ||
   (Kh = BC(_q, wq, {
    upgrade: (t, e) => {
     switch (e) {
      case 0:
       t.createObjectStore(Eo);
     }
    },
   })),
  Kh
 );
}
async function Ad(t, e) {
 const n = Cf(t),
  i = (await cv()).transaction(Eo, "readwrite"),
  o = i.objectStore(Eo),
  s = await o.get(n);
 return await o.put(e, n), await i.done, (!s || s.fid !== e.fid) && Tk(t, e.fid), e;
}
async function Sk(t) {
 const e = Cf(t),
  r = (await cv()).transaction(Eo, "readwrite");
 await r.objectStore(Eo).delete(e), await r.done;
}
async function Rf(t, e) {
 const n = Cf(t),
  i = (await cv()).transaction(Eo, "readwrite"),
  o = i.objectStore(Eo),
  s = await o.get(n),
  a = e(s);
 return (
  a === void 0 ? await o.delete(n) : await o.put(a, n), await i.done, a && (!s || s.fid !== a.fid) && Tk(t, a.fid), a
 );
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function dv(t) {
 let e;
 const n = await Rf(t.appConfig, (r) => {
  const i = Eq(r),
   o = Tq(t, i);
  return (e = o.registrationPromise), o.installationEntry;
 });
 return n.fid === Rm ? { installationEntry: await e } : { installationEntry: n, registrationPromise: e };
}
function Eq(t) {
 const e = t || { fid: pq(), registrationStatus: 0 };
 return Ak(e);
}
function Tq(t, e) {
 if (e.registrationStatus === 0) {
  if (!navigator.onLine) {
   const i = Promise.reject(wo.create("app-offline"));
   return { installationEntry: e, registrationPromise: i };
  }
  const n = { fid: e.fid, registrationStatus: 1, registrationTime: Date.now() },
   r = Iq(t, n);
  return { installationEntry: n, registrationPromise: r };
 } else
  return e.registrationStatus === 1 ? { installationEntry: e, registrationPromise: Sq(t) } : { installationEntry: e };
}
async function Iq(t, e) {
 try {
  const n = await dq(t, e);
  return Ad(t.appConfig, n);
 } catch (n) {
  throw (
   (pk(n) && n.customData.serverCode === 409
    ? await Sk(t.appConfig)
    : await Ad(t.appConfig, { fid: e.fid, registrationStatus: 0 }),
   n)
  );
 }
}
async function Sq(t) {
 let e = await SE(t.appConfig);
 for (; e.registrationStatus === 1; ) await wk(100), (e = await SE(t.appConfig));
 if (e.registrationStatus === 0) {
  const { installationEntry: n, registrationPromise: r } = await dv(t);
  return r || n;
 }
 return e;
}
function SE(t) {
 return Rf(t, (e) => {
  if (!e) throw wo.create("installation-not-found");
  return Ak(e);
 });
}
function Ak(t) {
 return Aq(t) ? { fid: t.fid, registrationStatus: 0 } : t;
}
function Aq(t) {
 return t.registrationStatus === 1 && t.registrationTime + dk < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Cq({ appConfig: t, heartbeatServiceProvider: e }, n) {
 const r = Rq(t, n),
  i = lq(t, n),
  o = e.getImmediate({ optional: !0 });
 if (o) {
  const u = await o.getHeartbeatsHeader();
  u && i.append("x-firebase-client", u);
 }
 const s = { installation: { sdkVersion: fk, appId: t.appId } },
  a = { method: "POST", headers: i, body: JSON.stringify(s) },
  l = await _k(() => fetch(r, a));
 if (l.ok) {
  const u = await l.json();
  return gk(u);
 } else throw await yk("Generate Auth Token", l);
}
function Rq(t, { fid: e }) {
 return `${mk(t)}/${e}/authTokens:generate`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function fv(t, e = !1) {
 let n;
 const r = await Rf(t.appConfig, (o) => {
  if (!Ck(o)) throw wo.create("not-registered");
  const s = o.authToken;
  if (!e && bq(s)) return o;
  if (s.requestStatus === 1) return (n = Pq(t, e)), o;
  {
   if (!navigator.onLine) throw wo.create("app-offline");
   const a = xq(o);
   return (n = kq(t, a)), a;
  }
 });
 return n ? await n : r.authToken;
}
async function Pq(t, e) {
 let n = await AE(t.appConfig);
 for (; n.authToken.requestStatus === 1; ) await wk(100), (n = await AE(t.appConfig));
 const r = n.authToken;
 return r.requestStatus === 0 ? fv(t, e) : r;
}
function AE(t) {
 return Rf(t, (e) => {
  if (!Ck(e)) throw wo.create("not-registered");
  const n = e.authToken;
  return Mq(n) ? Object.assign(Object.assign({}, e), { authToken: { requestStatus: 0 } }) : e;
 });
}
async function kq(t, e) {
 try {
  const n = await Cq(t, e),
   r = Object.assign(Object.assign({}, e), { authToken: n });
  return await Ad(t.appConfig, r), n;
 } catch (n) {
  if (pk(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404)) await Sk(t.appConfig);
  else {
   const r = Object.assign(Object.assign({}, e), { authToken: { requestStatus: 0 } });
   await Ad(t.appConfig, r);
  }
  throw n;
 }
}
function Ck(t) {
 return t !== void 0 && t.registrationStatus === 2;
}
function bq(t) {
 return t.requestStatus === 2 && !Nq(t);
}
function Nq(t) {
 const e = Date.now();
 return e < t.creationTime || t.creationTime + t.expiresIn < e + iq;
}
function xq(t) {
 const e = { requestStatus: 1, requestTime: Date.now() };
 return Object.assign(Object.assign({}, t), { authToken: e });
}
function Mq(t) {
 return t.requestStatus === 1 && t.requestTime + dk < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Dq(t) {
 const e = t,
  { installationEntry: n, registrationPromise: r } = await dv(e);
 return r ? r.catch(console.error) : fv(e).catch(console.error), n.fid;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Lq(t, e = !1) {
 const n = t;
 return await Vq(n), (await fv(n, e)).token;
}
async function Vq(t) {
 const { registrationPromise: e } = await dv(t);
 e && (await e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Uq(t) {
 if (!t || !t.options) throw Jh("App Configuration");
 if (!t.name) throw Jh("App Name");
 const e = ["projectId", "apiKey", "appId"];
 for (const n of e) if (!t.options[n]) throw Jh(n);
 return { appName: t.name, projectId: t.options.projectId, apiKey: t.options.apiKey, appId: t.options.appId };
}
function Jh(t) {
 return wo.create("missing-app-config-values", { valueName: t });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Rk = "installations",
 Oq = "installations-internal",
 Fq = (t) => {
  const e = t.getProvider("app").getImmediate(),
   n = Uq(e),
   r = Mi(e, "heartbeat");
  return { app: e, appConfig: n, heartbeatServiceProvider: r, _delete: () => Promise.resolve() };
 },
 Bq = (t) => {
  const e = t.getProvider("app").getImmediate(),
   n = Mi(e, Rk).getImmediate();
  return { getId: () => Dq(n), getToken: (i) => Lq(n, i) };
 };
function $q() {
 Hn(new Pn(Rk, Fq, "PUBLIC")), Hn(new Pn(Oq, Bq, "PRIVATE"));
}
$q();
rn(ck, uv);
rn(ck, uv, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Cd = "analytics",
 Hq = "firebase_id",
 qq = "origin",
 Gq = 60 * 1e3,
 zq = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig",
 hv = "https://www.googletagmanager.com/gtag/js";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const on = new of("@firebase/analytics");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Wq = {
  "already-exists":
   "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
  "already-initialized":
   "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-initialized instance.",
  "already-initialized-settings":
   "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
  "interop-component-reg-failed": "Firebase Analytics Interop Component failed to instantiate: {$reason}",
  "invalid-analytics-context":
   "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  "indexeddb-unavailable":
   "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  "fetch-throttle":
   "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
  "config-fetch-failed": "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
  "no-api-key":
   'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
  "no-app-id":
   'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',
  "no-client-id": 'The "client_id" field is empty.',
  "invalid-gtag-resource": "Trusted Types detected an invalid gtag resource: {$gtagURL}.",
 },
 fn = new Po("analytics", "Analytics", Wq);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Kq(t) {
 if (!t.startsWith(hv)) {
  const e = fn.create("invalid-gtag-resource", { gtagURL: t });
  return on.warn(e.message), "";
 }
 return t;
}
function Pk(t) {
 return Promise.all(t.map((e) => e.catch((n) => n)));
}
function Jq(t, e) {
 let n;
 return window.trustedTypes && (n = window.trustedTypes.createPolicy(t, e)), n;
}
function Yq(t, e) {
 const n = Jq("firebase-js-sdk-policy", { createScriptURL: Kq }),
  r = document.createElement("script"),
  i = `${hv}?l=${t}&id=${e}`;
 (r.src = n ? (n == null ? void 0 : n.createScriptURL(i)) : i), (r.async = !0), document.head.appendChild(r);
}
function Qq(t) {
 let e = [];
 return Array.isArray(window[t]) ? (e = window[t]) : (window[t] = e), e;
}
async function Xq(t, e, n, r, i, o) {
 const s = r[i];
 try {
  if (s) await e[s];
  else {
   const l = (await Pk(n)).find((u) => u.measurementId === i);
   l && (await e[l.appId]);
  }
 } catch (a) {
  on.error(a);
 }
 t("config", i, o);
}
async function jq(t, e, n, r, i) {
 try {
  let o = [];
  if (i && i.send_to) {
   let s = i.send_to;
   Array.isArray(s) || (s = [s]);
   const a = await Pk(n);
   for (const l of s) {
    const u = a.find((p) => p.measurementId === l),
     h = u && e[u.appId];
    if (h) o.push(h);
    else {
     o = [];
     break;
    }
   }
  }
  o.length === 0 && (o = Object.values(e)), await Promise.all(o), t("event", r, i || {});
 } catch (o) {
  on.error(o);
 }
}
function Zq(t, e, n, r) {
 async function i(o, ...s) {
  try {
   if (o === "event") {
    const [a, l] = s;
    await jq(t, e, n, a, l);
   } else if (o === "config") {
    const [a, l] = s;
    await Xq(t, e, n, r, a, l);
   } else if (o === "consent") {
    const [a, l] = s;
    t("consent", a, l);
   } else if (o === "get") {
    const [a, l, u] = s;
    t("get", a, l, u);
   } else if (o === "set") {
    const [a] = s;
    t("set", a);
   } else t(o, ...s);
  } catch (a) {
   on.error(a);
  }
 }
 return i;
}
function eG(t, e, n, r, i) {
 let o = function (...s) {
  window[r].push(arguments);
 };
 return (
  window[i] && typeof window[i] == "function" && (o = window[i]),
  (window[i] = Zq(o, t, e, n)),
  { gtagCore: o, wrappedGtag: window[i] }
 );
}
function tG(t) {
 const e = window.document.getElementsByTagName("script");
 for (const n of Object.values(e)) if (n.src && n.src.includes(hv) && n.src.includes(t)) return n;
 return null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const nG = 30,
 rG = 1e3;
class iG {
 constructor(e = {}, n = rG) {
  (this.throttleMetadata = e), (this.intervalMillis = n);
 }
 getThrottleMetadata(e) {
  return this.throttleMetadata[e];
 }
 setThrottleMetadata(e, n) {
  this.throttleMetadata[e] = n;
 }
 deleteThrottleMetadata(e) {
  delete this.throttleMetadata[e];
 }
}
const kk = new iG();
function oG(t) {
 return new Headers({ Accept: "application/json", "x-goog-api-key": t });
}
async function sG(t) {
 var e;
 const { appId: n, apiKey: r } = t,
  i = { method: "GET", headers: oG(r) },
  o = zq.replace("{app-id}", n),
  s = await fetch(o, i);
 if (s.status !== 200 && s.status !== 304) {
  let a = "";
  try {
   const l = await s.json();
   !((e = l.error) === null || e === void 0) && e.message && (a = l.error.message);
  } catch {}
  throw fn.create("config-fetch-failed", { httpStatus: s.status, responseMessage: a });
 }
 return s.json();
}
async function aG(t, e = kk, n) {
 const { appId: r, apiKey: i, measurementId: o } = t.options;
 if (!r) throw fn.create("no-app-id");
 if (!i) {
  if (o) return { measurementId: o, appId: r };
  throw fn.create("no-api-key");
 }
 const s = e.getThrottleMetadata(r) || { backoffCount: 0, throttleEndTimeMillis: Date.now() },
  a = new cG();
 return (
  setTimeout(async () => {
   a.abort();
  }, Gq),
  bk({ appId: r, apiKey: i, measurementId: o }, s, a, e)
 );
}
async function bk(t, { throttleEndTimeMillis: e, backoffCount: n }, r, i = kk) {
 var o;
 const { appId: s, measurementId: a } = t;
 try {
  await lG(r, e);
 } catch (l) {
  if (a)
   return (
    on.warn(
     `Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${l == null ? void 0 : l.message}]`
    ),
    { appId: s, measurementId: a }
   );
  throw l;
 }
 try {
  const l = await sG(t);
  return i.deleteThrottleMetadata(s), l;
 } catch (l) {
  const u = l;
  if (!uG(u)) {
   if ((i.deleteThrottleMetadata(s), a))
    return (
     on.warn(
      `Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${u == null ? void 0 : u.message}]`
     ),
     { appId: s, measurementId: a }
    );
   throw l;
  }
  const h =
    Number((o = u == null ? void 0 : u.customData) === null || o === void 0 ? void 0 : o.httpStatus) === 503
     ? t0(n, i.intervalMillis, nG)
     : t0(n, i.intervalMillis),
   p = { throttleEndTimeMillis: Date.now() + h, backoffCount: n + 1 };
  return i.setThrottleMetadata(s, p), on.debug(`Calling attemptFetch again in ${h} millis`), bk(t, p, r, i);
 }
}
function lG(t, e) {
 return new Promise((n, r) => {
  const i = Math.max(e - Date.now(), 0),
   o = setTimeout(n, i);
  t.addEventListener(() => {
   clearTimeout(o), r(fn.create("fetch-throttle", { throttleEndTimeMillis: e }));
  });
 });
}
function uG(t) {
 if (!(t instanceof bn) || !t.customData) return !1;
 const e = Number(t.customData.httpStatus);
 return e === 429 || e === 500 || e === 503 || e === 504;
}
class cG {
 constructor() {
  this.listeners = [];
 }
 addEventListener(e) {
  this.listeners.push(e);
 }
 abort() {
  this.listeners.forEach((e) => e());
 }
}
async function dG(t, e, n, r, i) {
 if (i && i.global) {
  t("event", n, r);
  return;
 } else {
  const o = await e,
   s = Object.assign(Object.assign({}, r), { send_to: o });
  t("event", n, s);
 }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function fG() {
 if (iy())
  try {
   await oy();
  } catch (t) {
   return on.warn(fn.create("indexeddb-unavailable", { errorInfo: t == null ? void 0 : t.toString() }).message), !1;
  }
 else
  return (
   on.warn(
    fn.create("indexeddb-unavailable", { errorInfo: "IndexedDB is not available in this environment." }).message
   ),
   !1
  );
 return !0;
}
async function hG(t, e, n, r, i, o, s) {
 var a;
 const l = aG(t);
 l
  .then((v) => {
   (n[v.measurementId] = v.appId),
    t.options.measurementId &&
     v.measurementId !== t.options.measurementId &&
     on.warn(
      `The measurement ID in the local Firebase config (${t.options.measurementId}) does not match the measurement ID fetched from the server (${v.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`
     );
  })
  .catch((v) => on.error(v)),
  e.push(l);
 const u = fG().then((v) => {
   if (v) return r.getId();
  }),
  [h, p] = await Promise.all([l, u]);
 tG(o) || Yq(o, h.measurementId), i("js", new Date());
 const m = (a = s == null ? void 0 : s.config) !== null && a !== void 0 ? a : {};
 return (
  (m[qq] = "firebase"), (m.update = !0), p != null && (m[Hq] = p), i("config", h.measurementId, m), h.measurementId
 );
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class pG {
 constructor(e) {
  this.app = e;
 }
 _delete() {
  return delete ja[this.app.options.appId], Promise.resolve();
 }
}
let ja = {},
 CE = [];
const RE = {};
let Yh = "dataLayer",
 mG = "gtag",
 PE,
 Nk,
 kE = !1;
function gG() {
 const t = [];
 if (
  (ry() && t.push("This is a browser extension environment."),
  UC() || t.push("Cookies are not available."),
  t.length > 0)
 ) {
  const e = t.map((r, i) => `(${i + 1}) ${r}`).join(" "),
   n = fn.create("invalid-analytics-context", { errorInfo: e });
  on.warn(n.message);
 }
}
function yG(t, e, n) {
 gG();
 const r = t.options.appId;
 if (!r) throw fn.create("no-app-id");
 if (!t.options.apiKey)
  if (t.options.measurementId)
   on.warn(
    `The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${t.options.measurementId} provided in the "measurementId" field in the local Firebase config.`
   );
  else throw fn.create("no-api-key");
 if (ja[r] != null) throw fn.create("already-exists", { id: r });
 if (!kE) {
  Qq(Yh);
  const { wrappedGtag: o, gtagCore: s } = eG(ja, CE, RE, Yh, mG);
  (Nk = o), (PE = s), (kE = !0);
 }
 return (ja[r] = hG(t, CE, RE, e, PE, Yh, n)), new pG(t);
}
function vG(t = Gl()) {
 t = Se(t);
 const e = Mi(t, Cd);
 return e.isInitialized() ? e.getImmediate() : _G(t);
}
function _G(t, e = {}) {
 const n = Mi(t, Cd);
 if (n.isInitialized()) {
  const i = n.getImmediate();
  if (_l(e, n.getOptions())) return i;
  throw fn.create("already-initialized");
 }
 return n.initialize({ options: e });
}
async function wG() {
 if (ry() || !UC() || !iy()) return !1;
 try {
  return await oy();
 } catch {
  return !1;
 }
}
function EG(t, e, n, r) {
 (t = Se(t)), dG(Nk, ja[t.app.options.appId], e, n, r).catch((i) => on.error(i));
}
const bE = "@firebase/analytics",
 NE = "0.10.8";
function TG() {
 Hn(
  new Pn(
   Cd,
   (e, { options: n }) => {
    const r = e.getProvider("app").getImmediate(),
     i = e.getProvider("installations-internal").getImmediate();
    return yG(r, i, n);
   },
   "PUBLIC"
  )
 ),
  Hn(new Pn("analytics-internal", t, "PRIVATE")),
  rn(bE, NE),
  rn(bE, NE, "esm2017");
 function t(e) {
  try {
   const n = e.getProvider(Cd).getImmediate();
   return { logEvent: (r, i, o) => EG(n, r, i, o) };
  } catch (n) {
   throw fn.create("interop-component-reg-failed", { reason: n });
  }
 }
}
TG();
const IG = {
  apiKey: "AIzaSyB5zXw31sraQnZ3fwFOtkP_O-ZmDWQxvfE",
  authDomain: "dashboardgururizal.firebaseapp.com",
  databaseURL: "https://dashboardgururizal-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "dashboardgururizal",
  storageBucket: "dashboardgururizal.firebasestorage.app",
  messagingSenderId: "1067383843556",
  appId: "1:1067383843556:web:676e641bbf8483d9bedaf1",
  measurementId: "G-7VF6H9WE5E",
 },
 su = ay(IG),
 Yi = IR(su),
 q = R$(su),
 SG = ZH(su);
typeof window < "u" &&
 wG()
  .then((t) => {
   t && vG(su);
  })
  .catch((t) => {
   console.warn("Analytics not supported:", t);
  });
var AG = {};
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ let CG, RG;
function PG() {
 return { geminiUrl: CG, vertexUrl: RG };
}
function kG(t, e, n, r) {
 var i, o;
 if (!(t != null && t.baseUrl)) {
  const s = PG();
  return e ? ((i = s.vertexUrl) !== null && i !== void 0 ? i : n) : (o = s.geminiUrl) !== null && o !== void 0 ? o : r;
 }
 return t.baseUrl;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class Fr {}
function K(t, e) {
 const n = /\{([^}]+)\}/g;
 return t.replace(n, (r, i) => {
  if (Object.prototype.hasOwnProperty.call(e, i)) {
   const o = e[i];
   return o != null ? String(o) : "";
  } else throw new Error(`Key '${i}' not found in valueMap.`);
 });
}
function d(t, e, n) {
 for (let o = 0; o < e.length - 1; o++) {
  const s = e[o];
  if (s.endsWith("[]")) {
   const a = s.slice(0, -2);
   if (!(a in t))
    if (Array.isArray(n)) t[a] = Array.from({ length: n.length }, () => ({}));
    else throw new Error(`Value must be a list given an array path ${s}`);
   if (Array.isArray(t[a])) {
    const l = t[a];
    if (Array.isArray(n))
     for (let u = 0; u < l.length; u++) {
      const h = l[u];
      d(h, e.slice(o + 1), n[u]);
     }
    else for (const u of l) d(u, e.slice(o + 1), n);
   }
   return;
  } else if (s.endsWith("[0]")) {
   const a = s.slice(0, -3);
   a in t || (t[a] = [{}]);
   const l = t[a];
   d(l[0], e.slice(o + 1), n);
   return;
  }
  (!t[s] || typeof t[s] != "object") && (t[s] = {}), (t = t[s]);
 }
 const r = e[e.length - 1],
  i = t[r];
 if (i !== void 0) {
  if (!n || (typeof n == "object" && Object.keys(n).length === 0) || n === i) return;
  if (typeof i == "object" && typeof n == "object" && i !== null && n !== null) Object.assign(i, n);
  else throw new Error(`Cannot set value for an existing key. Key: ${r}`);
 } else r === "_self" && typeof n == "object" && n !== null && !Array.isArray(n) ? Object.assign(t, n) : (t[r] = n);
}
function c(t, e, n = void 0) {
 try {
  if (e.length === 1 && e[0] === "_self") return t;
  for (let r = 0; r < e.length; r++) {
   if (typeof t != "object" || t === null) return n;
   const i = e[r];
   if (i.endsWith("[]")) {
    const o = i.slice(0, -2);
    if (o in t) {
     const s = t[o];
     return Array.isArray(s) ? s.map((a) => c(a, e.slice(r + 1), n)) : n;
    } else return n;
   } else t = t[i];
  }
  return t;
 } catch (r) {
  if (r instanceof TypeError) return n;
  throw r;
 }
}
function bG(t, e) {
 for (const [n, r] of Object.entries(e)) {
  const i = n.split("."),
   o = r.split("."),
   s = new Set();
  let a = -1;
  for (let l = 0; l < i.length; l++)
   if (i[l] === "*") {
    a = l;
    break;
   }
  if (a !== -1 && o.length > a)
   for (let l = a; l < o.length; l++) {
    const u = o[l];
    u !== "*" && !u.endsWith("[]") && !u.endsWith("[0]") && s.add(u);
   }
  Pm(t, i, o, 0, s);
 }
}
function Pm(t, e, n, r, i) {
 if (r >= e.length || typeof t != "object" || t === null) return;
 const o = e[r];
 if (o.endsWith("[]")) {
  const s = o.slice(0, -2),
   a = t;
  if (s in a && Array.isArray(a[s])) for (const l of a[s]) Pm(l, e, n, r + 1, i);
 } else if (o === "*") {
  if (typeof t == "object" && t !== null && !Array.isArray(t)) {
   const s = t,
    a = Object.keys(s).filter((u) => !u.startsWith("_") && !i.has(u)),
    l = {};
   for (const u of a) l[u] = s[u];
   for (const [u, h] of Object.entries(l)) {
    const p = [];
    for (const m of n.slice(r)) m === "*" ? p.push(u) : p.push(m);
    d(s, p, h);
   }
   for (const u of a) delete s[u];
  }
 } else {
  const s = t;
  o in s && Pm(s[o], e, n, r + 1, i);
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function pv(t) {
 if (typeof t != "string") throw new Error("fromImageBytes must be a string");
 return t;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function NG(t) {
 const e = {},
  n = c(t, ["operationName"]);
 n != null && d(e, ["operationName"], n);
 const r = c(t, ["resourceName"]);
 return r != null && d(e, ["_url", "resourceName"], r), e;
}
function xG(t) {
 const e = {},
  n = c(t, ["name"]);
 n != null && d(e, ["name"], n);
 const r = c(t, ["metadata"]);
 r != null && d(e, ["metadata"], r);
 const i = c(t, ["done"]);
 i != null && d(e, ["done"], i);
 const o = c(t, ["error"]);
 o != null && d(e, ["error"], o);
 const s = c(t, ["response", "generateVideoResponse"]);
 return s != null && d(e, ["response"], DG(s)), e;
}
function MG(t) {
 const e = {},
  n = c(t, ["name"]);
 n != null && d(e, ["name"], n);
 const r = c(t, ["metadata"]);
 r != null && d(e, ["metadata"], r);
 const i = c(t, ["done"]);
 i != null && d(e, ["done"], i);
 const o = c(t, ["error"]);
 o != null && d(e, ["error"], o);
 const s = c(t, ["response"]);
 return s != null && d(e, ["response"], LG(s)), e;
}
function DG(t) {
 const e = {},
  n = c(t, ["generatedSamples"]);
 if (n != null) {
  let o = n;
  Array.isArray(o) && (o = o.map((s) => VG(s))), d(e, ["generatedVideos"], o);
 }
 const r = c(t, ["raiMediaFilteredCount"]);
 r != null && d(e, ["raiMediaFilteredCount"], r);
 const i = c(t, ["raiMediaFilteredReasons"]);
 return i != null && d(e, ["raiMediaFilteredReasons"], i), e;
}
function LG(t) {
 const e = {},
  n = c(t, ["videos"]);
 if (n != null) {
  let o = n;
  Array.isArray(o) && (o = o.map((s) => UG(s))), d(e, ["generatedVideos"], o);
 }
 const r = c(t, ["raiMediaFilteredCount"]);
 r != null && d(e, ["raiMediaFilteredCount"], r);
 const i = c(t, ["raiMediaFilteredReasons"]);
 return i != null && d(e, ["raiMediaFilteredReasons"], i), e;
}
function VG(t) {
 const e = {},
  n = c(t, ["video"]);
 return n != null && d(e, ["video"], qG(n)), e;
}
function UG(t) {
 const e = {},
  n = c(t, ["_self"]);
 return n != null && d(e, ["video"], GG(n)), e;
}
function OG(t) {
 const e = {},
  n = c(t, ["operationName"]);
 return n != null && d(e, ["_url", "operationName"], n), e;
}
function FG(t) {
 const e = {},
  n = c(t, ["operationName"]);
 return n != null && d(e, ["_url", "operationName"], n), e;
}
function BG(t) {
 const e = {},
  n = c(t, ["name"]);
 n != null && d(e, ["name"], n);
 const r = c(t, ["metadata"]);
 r != null && d(e, ["metadata"], r);
 const i = c(t, ["done"]);
 i != null && d(e, ["done"], i);
 const o = c(t, ["error"]);
 o != null && d(e, ["error"], o);
 const s = c(t, ["response"]);
 return s != null && d(e, ["response"], $G(s)), e;
}
function $G(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["parent"]);
 r != null && d(e, ["parent"], r);
 const i = c(t, ["documentName"]);
 return i != null && d(e, ["documentName"], i), e;
}
function xk(t) {
 const e = {},
  n = c(t, ["name"]);
 n != null && d(e, ["name"], n);
 const r = c(t, ["metadata"]);
 r != null && d(e, ["metadata"], r);
 const i = c(t, ["done"]);
 i != null && d(e, ["done"], i);
 const o = c(t, ["error"]);
 o != null && d(e, ["error"], o);
 const s = c(t, ["response"]);
 return s != null && d(e, ["response"], HG(s)), e;
}
function HG(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["parent"]);
 r != null && d(e, ["parent"], r);
 const i = c(t, ["documentName"]);
 return i != null && d(e, ["documentName"], i), e;
}
function qG(t) {
 const e = {},
  n = c(t, ["uri"]);
 n != null && d(e, ["uri"], n);
 const r = c(t, ["encodedVideo"]);
 r != null && d(e, ["videoBytes"], pv(r));
 const i = c(t, ["encoding"]);
 return i != null && d(e, ["mimeType"], i), e;
}
function GG(t) {
 const e = {},
  n = c(t, ["gcsUri"]);
 n != null && d(e, ["uri"], n);
 const r = c(t, ["bytesBase64Encoded"]);
 r != null && d(e, ["videoBytes"], pv(r));
 const i = c(t, ["mimeType"]);
 return i != null && d(e, ["mimeType"], i), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ var xE;
(function (t) {
 (t.OUTCOME_UNSPECIFIED = "OUTCOME_UNSPECIFIED"),
  (t.OUTCOME_OK = "OUTCOME_OK"),
  (t.OUTCOME_FAILED = "OUTCOME_FAILED"),
  (t.OUTCOME_DEADLINE_EXCEEDED = "OUTCOME_DEADLINE_EXCEEDED");
})(xE || (xE = {}));
var ME;
(function (t) {
 (t.LANGUAGE_UNSPECIFIED = "LANGUAGE_UNSPECIFIED"), (t.PYTHON = "PYTHON");
})(ME || (ME = {}));
var DE;
(function (t) {
 (t.SCHEDULING_UNSPECIFIED = "SCHEDULING_UNSPECIFIED"),
  (t.SILENT = "SILENT"),
  (t.WHEN_IDLE = "WHEN_IDLE"),
  (t.INTERRUPT = "INTERRUPT");
})(DE || (DE = {}));
var Rt;
(function (t) {
 (t.TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED"),
  (t.STRING = "STRING"),
  (t.NUMBER = "NUMBER"),
  (t.INTEGER = "INTEGER"),
  (t.BOOLEAN = "BOOLEAN"),
  (t.ARRAY = "ARRAY"),
  (t.OBJECT = "OBJECT"),
  (t.NULL = "NULL");
})(Rt || (Rt = {}));
var LE;
(function (t) {
 (t.API_SPEC_UNSPECIFIED = "API_SPEC_UNSPECIFIED"),
  (t.SIMPLE_SEARCH = "SIMPLE_SEARCH"),
  (t.ELASTIC_SEARCH = "ELASTIC_SEARCH");
})(LE || (LE = {}));
var VE;
(function (t) {
 (t.AUTH_TYPE_UNSPECIFIED = "AUTH_TYPE_UNSPECIFIED"),
  (t.NO_AUTH = "NO_AUTH"),
  (t.API_KEY_AUTH = "API_KEY_AUTH"),
  (t.HTTP_BASIC_AUTH = "HTTP_BASIC_AUTH"),
  (t.GOOGLE_SERVICE_ACCOUNT_AUTH = "GOOGLE_SERVICE_ACCOUNT_AUTH"),
  (t.OAUTH = "OAUTH"),
  (t.OIDC_AUTH = "OIDC_AUTH");
})(VE || (VE = {}));
var UE;
(function (t) {
 (t.HTTP_IN_UNSPECIFIED = "HTTP_IN_UNSPECIFIED"),
  (t.HTTP_IN_QUERY = "HTTP_IN_QUERY"),
  (t.HTTP_IN_HEADER = "HTTP_IN_HEADER"),
  (t.HTTP_IN_PATH = "HTTP_IN_PATH"),
  (t.HTTP_IN_BODY = "HTTP_IN_BODY"),
  (t.HTTP_IN_COOKIE = "HTTP_IN_COOKIE");
})(UE || (UE = {}));
var OE;
(function (t) {
 (t.PHISH_BLOCK_THRESHOLD_UNSPECIFIED = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED"),
  (t.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE"),
  (t.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE"),
  (t.BLOCK_HIGH_AND_ABOVE = "BLOCK_HIGH_AND_ABOVE"),
  (t.BLOCK_HIGHER_AND_ABOVE = "BLOCK_HIGHER_AND_ABOVE"),
  (t.BLOCK_VERY_HIGH_AND_ABOVE = "BLOCK_VERY_HIGH_AND_ABOVE"),
  (t.BLOCK_ONLY_EXTREMELY_HIGH = "BLOCK_ONLY_EXTREMELY_HIGH");
})(OE || (OE = {}));
var FE;
(function (t) {
 (t.UNSPECIFIED = "UNSPECIFIED"), (t.BLOCKING = "BLOCKING"), (t.NON_BLOCKING = "NON_BLOCKING");
})(FE || (FE = {}));
var BE;
(function (t) {
 (t.MODE_UNSPECIFIED = "MODE_UNSPECIFIED"), (t.MODE_DYNAMIC = "MODE_DYNAMIC");
})(BE || (BE = {}));
var $E;
(function (t) {
 (t.MODE_UNSPECIFIED = "MODE_UNSPECIFIED"),
  (t.AUTO = "AUTO"),
  (t.ANY = "ANY"),
  (t.NONE = "NONE"),
  (t.VALIDATED = "VALIDATED");
})($E || ($E = {}));
var HE;
(function (t) {
 (t.THINKING_LEVEL_UNSPECIFIED = "THINKING_LEVEL_UNSPECIFIED"),
  (t.LOW = "LOW"),
  (t.MEDIUM = "MEDIUM"),
  (t.HIGH = "HIGH"),
  (t.MINIMAL = "MINIMAL");
})(HE || (HE = {}));
var qE;
(function (t) {
 (t.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED"),
  (t.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT"),
  (t.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH"),
  (t.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT"),
  (t.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT"),
  (t.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY"),
  (t.HARM_CATEGORY_IMAGE_HATE = "HARM_CATEGORY_IMAGE_HATE"),
  (t.HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"),
  (t.HARM_CATEGORY_IMAGE_HARASSMENT = "HARM_CATEGORY_IMAGE_HARASSMENT"),
  (t.HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"),
  (t.HARM_CATEGORY_JAILBREAK = "HARM_CATEGORY_JAILBREAK");
})(qE || (qE = {}));
var GE;
(function (t) {
 (t.HARM_BLOCK_METHOD_UNSPECIFIED = "HARM_BLOCK_METHOD_UNSPECIFIED"),
  (t.SEVERITY = "SEVERITY"),
  (t.PROBABILITY = "PROBABILITY");
})(GE || (GE = {}));
var zE;
(function (t) {
 (t.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED"),
  (t.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE"),
  (t.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE"),
  (t.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH"),
  (t.BLOCK_NONE = "BLOCK_NONE"),
  (t.OFF = "OFF");
})(zE || (zE = {}));
var WE;
(function (t) {
 (t.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED"),
  (t.STOP = "STOP"),
  (t.MAX_TOKENS = "MAX_TOKENS"),
  (t.SAFETY = "SAFETY"),
  (t.RECITATION = "RECITATION"),
  (t.LANGUAGE = "LANGUAGE"),
  (t.OTHER = "OTHER"),
  (t.BLOCKLIST = "BLOCKLIST"),
  (t.PROHIBITED_CONTENT = "PROHIBITED_CONTENT"),
  (t.SPII = "SPII"),
  (t.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL"),
  (t.IMAGE_SAFETY = "IMAGE_SAFETY"),
  (t.UNEXPECTED_TOOL_CALL = "UNEXPECTED_TOOL_CALL"),
  (t.IMAGE_PROHIBITED_CONTENT = "IMAGE_PROHIBITED_CONTENT"),
  (t.NO_IMAGE = "NO_IMAGE"),
  (t.IMAGE_RECITATION = "IMAGE_RECITATION"),
  (t.IMAGE_OTHER = "IMAGE_OTHER");
})(WE || (WE = {}));
var KE;
(function (t) {
 (t.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED"),
  (t.NEGLIGIBLE = "NEGLIGIBLE"),
  (t.LOW = "LOW"),
  (t.MEDIUM = "MEDIUM"),
  (t.HIGH = "HIGH");
})(KE || (KE = {}));
var JE;
(function (t) {
 (t.HARM_SEVERITY_UNSPECIFIED = "HARM_SEVERITY_UNSPECIFIED"),
  (t.HARM_SEVERITY_NEGLIGIBLE = "HARM_SEVERITY_NEGLIGIBLE"),
  (t.HARM_SEVERITY_LOW = "HARM_SEVERITY_LOW"),
  (t.HARM_SEVERITY_MEDIUM = "HARM_SEVERITY_MEDIUM"),
  (t.HARM_SEVERITY_HIGH = "HARM_SEVERITY_HIGH");
})(JE || (JE = {}));
var YE;
(function (t) {
 (t.URL_RETRIEVAL_STATUS_UNSPECIFIED = "URL_RETRIEVAL_STATUS_UNSPECIFIED"),
  (t.URL_RETRIEVAL_STATUS_SUCCESS = "URL_RETRIEVAL_STATUS_SUCCESS"),
  (t.URL_RETRIEVAL_STATUS_ERROR = "URL_RETRIEVAL_STATUS_ERROR"),
  (t.URL_RETRIEVAL_STATUS_PAYWALL = "URL_RETRIEVAL_STATUS_PAYWALL"),
  (t.URL_RETRIEVAL_STATUS_UNSAFE = "URL_RETRIEVAL_STATUS_UNSAFE");
})(YE || (YE = {}));
var QE;
(function (t) {
 (t.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED"),
  (t.SAFETY = "SAFETY"),
  (t.OTHER = "OTHER"),
  (t.BLOCKLIST = "BLOCKLIST"),
  (t.PROHIBITED_CONTENT = "PROHIBITED_CONTENT"),
  (t.IMAGE_SAFETY = "IMAGE_SAFETY"),
  (t.MODEL_ARMOR = "MODEL_ARMOR"),
  (t.JAILBREAK = "JAILBREAK");
})(QE || (QE = {}));
var XE;
(function (t) {
 (t.TRAFFIC_TYPE_UNSPECIFIED = "TRAFFIC_TYPE_UNSPECIFIED"),
  (t.ON_DEMAND = "ON_DEMAND"),
  (t.PROVISIONED_THROUGHPUT = "PROVISIONED_THROUGHPUT");
})(XE || (XE = {}));
var Rd;
(function (t) {
 (t.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED"), (t.TEXT = "TEXT"), (t.IMAGE = "IMAGE"), (t.AUDIO = "AUDIO");
})(Rd || (Rd = {}));
var jE;
(function (t) {
 (t.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED"),
  (t.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW"),
  (t.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM"),
  (t.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH");
})(jE || (jE = {}));
var ZE;
(function (t) {
 (t.TUNING_MODE_UNSPECIFIED = "TUNING_MODE_UNSPECIFIED"),
  (t.TUNING_MODE_FULL = "TUNING_MODE_FULL"),
  (t.TUNING_MODE_PEFT_ADAPTER = "TUNING_MODE_PEFT_ADAPTER");
})(ZE || (ZE = {}));
var eT;
(function (t) {
 (t.ADAPTER_SIZE_UNSPECIFIED = "ADAPTER_SIZE_UNSPECIFIED"),
  (t.ADAPTER_SIZE_ONE = "ADAPTER_SIZE_ONE"),
  (t.ADAPTER_SIZE_TWO = "ADAPTER_SIZE_TWO"),
  (t.ADAPTER_SIZE_FOUR = "ADAPTER_SIZE_FOUR"),
  (t.ADAPTER_SIZE_EIGHT = "ADAPTER_SIZE_EIGHT"),
  (t.ADAPTER_SIZE_SIXTEEN = "ADAPTER_SIZE_SIXTEEN"),
  (t.ADAPTER_SIZE_THIRTY_TWO = "ADAPTER_SIZE_THIRTY_TWO");
})(eT || (eT = {}));
var km;
(function (t) {
 (t.JOB_STATE_UNSPECIFIED = "JOB_STATE_UNSPECIFIED"),
  (t.JOB_STATE_QUEUED = "JOB_STATE_QUEUED"),
  (t.JOB_STATE_PENDING = "JOB_STATE_PENDING"),
  (t.JOB_STATE_RUNNING = "JOB_STATE_RUNNING"),
  (t.JOB_STATE_SUCCEEDED = "JOB_STATE_SUCCEEDED"),
  (t.JOB_STATE_FAILED = "JOB_STATE_FAILED"),
  (t.JOB_STATE_CANCELLING = "JOB_STATE_CANCELLING"),
  (t.JOB_STATE_CANCELLED = "JOB_STATE_CANCELLED"),
  (t.JOB_STATE_PAUSED = "JOB_STATE_PAUSED"),
  (t.JOB_STATE_EXPIRED = "JOB_STATE_EXPIRED"),
  (t.JOB_STATE_UPDATING = "JOB_STATE_UPDATING"),
  (t.JOB_STATE_PARTIALLY_SUCCEEDED = "JOB_STATE_PARTIALLY_SUCCEEDED");
})(km || (km = {}));
var tT;
(function (t) {
 (t.TUNING_TASK_UNSPECIFIED = "TUNING_TASK_UNSPECIFIED"),
  (t.TUNING_TASK_I2V = "TUNING_TASK_I2V"),
  (t.TUNING_TASK_T2V = "TUNING_TASK_T2V"),
  (t.TUNING_TASK_R2V = "TUNING_TASK_R2V");
})(tT || (tT = {}));
var nT;
(function (t) {
 (t.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED"),
  (t.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW"),
  (t.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM"),
  (t.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH"),
  (t.MEDIA_RESOLUTION_ULTRA_HIGH = "MEDIA_RESOLUTION_ULTRA_HIGH");
})(nT || (nT = {}));
var bm;
(function (t) {
 t.COLLECTION = "COLLECTION";
})(bm || (bm = {}));
var rT;
(function (t) {
 (t.FEATURE_SELECTION_PREFERENCE_UNSPECIFIED = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"),
  (t.PRIORITIZE_QUALITY = "PRIORITIZE_QUALITY"),
  (t.BALANCED = "BALANCED"),
  (t.PRIORITIZE_COST = "PRIORITIZE_COST");
})(rT || (rT = {}));
var iT;
(function (t) {
 (t.ENVIRONMENT_UNSPECIFIED = "ENVIRONMENT_UNSPECIFIED"), (t.ENVIRONMENT_BROWSER = "ENVIRONMENT_BROWSER");
})(iT || (iT = {}));
var oT;
(function (t) {
 (t.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE"),
  (t.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE"),
  (t.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH"),
  (t.BLOCK_NONE = "BLOCK_NONE");
})(oT || (oT = {}));
var sT;
(function (t) {
 (t.DONT_ALLOW = "DONT_ALLOW"), (t.ALLOW_ADULT = "ALLOW_ADULT"), (t.ALLOW_ALL = "ALLOW_ALL");
})(sT || (sT = {}));
var aT;
(function (t) {
 (t.auto = "auto"),
  (t.en = "en"),
  (t.ja = "ja"),
  (t.ko = "ko"),
  (t.hi = "hi"),
  (t.zh = "zh"),
  (t.pt = "pt"),
  (t.es = "es");
})(aT || (aT = {}));
var lT;
(function (t) {
 (t.MASK_MODE_DEFAULT = "MASK_MODE_DEFAULT"),
  (t.MASK_MODE_USER_PROVIDED = "MASK_MODE_USER_PROVIDED"),
  (t.MASK_MODE_BACKGROUND = "MASK_MODE_BACKGROUND"),
  (t.MASK_MODE_FOREGROUND = "MASK_MODE_FOREGROUND"),
  (t.MASK_MODE_SEMANTIC = "MASK_MODE_SEMANTIC");
})(lT || (lT = {}));
var uT;
(function (t) {
 (t.CONTROL_TYPE_DEFAULT = "CONTROL_TYPE_DEFAULT"),
  (t.CONTROL_TYPE_CANNY = "CONTROL_TYPE_CANNY"),
  (t.CONTROL_TYPE_SCRIBBLE = "CONTROL_TYPE_SCRIBBLE"),
  (t.CONTROL_TYPE_FACE_MESH = "CONTROL_TYPE_FACE_MESH");
})(uT || (uT = {}));
var cT;
(function (t) {
 (t.SUBJECT_TYPE_DEFAULT = "SUBJECT_TYPE_DEFAULT"),
  (t.SUBJECT_TYPE_PERSON = "SUBJECT_TYPE_PERSON"),
  (t.SUBJECT_TYPE_ANIMAL = "SUBJECT_TYPE_ANIMAL"),
  (t.SUBJECT_TYPE_PRODUCT = "SUBJECT_TYPE_PRODUCT");
})(cT || (cT = {}));
var dT;
(function (t) {
 (t.EDIT_MODE_DEFAULT = "EDIT_MODE_DEFAULT"),
  (t.EDIT_MODE_INPAINT_REMOVAL = "EDIT_MODE_INPAINT_REMOVAL"),
  (t.EDIT_MODE_INPAINT_INSERTION = "EDIT_MODE_INPAINT_INSERTION"),
  (t.EDIT_MODE_OUTPAINT = "EDIT_MODE_OUTPAINT"),
  (t.EDIT_MODE_CONTROLLED_EDITING = "EDIT_MODE_CONTROLLED_EDITING"),
  (t.EDIT_MODE_STYLE = "EDIT_MODE_STYLE"),
  (t.EDIT_MODE_BGSWAP = "EDIT_MODE_BGSWAP"),
  (t.EDIT_MODE_PRODUCT_IMAGE = "EDIT_MODE_PRODUCT_IMAGE");
})(dT || (dT = {}));
var fT;
(function (t) {
 (t.FOREGROUND = "FOREGROUND"),
  (t.BACKGROUND = "BACKGROUND"),
  (t.PROMPT = "PROMPT"),
  (t.SEMANTIC = "SEMANTIC"),
  (t.INTERACTIVE = "INTERACTIVE");
})(fT || (fT = {}));
var hT;
(function (t) {
 (t.ASSET = "ASSET"), (t.STYLE = "STYLE");
})(hT || (hT = {}));
var pT;
(function (t) {
 (t.INSERT = "INSERT"), (t.REMOVE = "REMOVE"), (t.REMOVE_STATIC = "REMOVE_STATIC"), (t.OUTPAINT = "OUTPAINT");
})(pT || (pT = {}));
var mT;
(function (t) {
 (t.OPTIMIZED = "OPTIMIZED"), (t.LOSSLESS = "LOSSLESS");
})(mT || (mT = {}));
var gT;
(function (t) {
 (t.SUPERVISED_FINE_TUNING = "SUPERVISED_FINE_TUNING"),
  (t.PREFERENCE_TUNING = "PREFERENCE_TUNING"),
  (t.DISTILLATION = "DISTILLATION");
})(gT || (gT = {}));
var yT;
(function (t) {
 (t.STATE_UNSPECIFIED = "STATE_UNSPECIFIED"),
  (t.STATE_PENDING = "STATE_PENDING"),
  (t.STATE_ACTIVE = "STATE_ACTIVE"),
  (t.STATE_FAILED = "STATE_FAILED");
})(yT || (yT = {}));
var vT;
(function (t) {
 (t.STATE_UNSPECIFIED = "STATE_UNSPECIFIED"),
  (t.PROCESSING = "PROCESSING"),
  (t.ACTIVE = "ACTIVE"),
  (t.FAILED = "FAILED");
})(vT || (vT = {}));
var _T;
(function (t) {
 (t.SOURCE_UNSPECIFIED = "SOURCE_UNSPECIFIED"),
  (t.UPLOADED = "UPLOADED"),
  (t.GENERATED = "GENERATED"),
  (t.REGISTERED = "REGISTERED");
})(_T || (_T = {}));
var wT;
(function (t) {
 (t.TURN_COMPLETE_REASON_UNSPECIFIED = "TURN_COMPLETE_REASON_UNSPECIFIED"),
  (t.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL"),
  (t.RESPONSE_REJECTED = "RESPONSE_REJECTED"),
  (t.NEED_MORE_INPUT = "NEED_MORE_INPUT");
})(wT || (wT = {}));
var ET;
(function (t) {
 (t.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED"),
  (t.TEXT = "TEXT"),
  (t.IMAGE = "IMAGE"),
  (t.VIDEO = "VIDEO"),
  (t.AUDIO = "AUDIO"),
  (t.DOCUMENT = "DOCUMENT");
})(ET || (ET = {}));
var TT;
(function (t) {
 (t.VAD_SIGNAL_TYPE_UNSPECIFIED = "VAD_SIGNAL_TYPE_UNSPECIFIED"),
  (t.VAD_SIGNAL_TYPE_SOS = "VAD_SIGNAL_TYPE_SOS"),
  (t.VAD_SIGNAL_TYPE_EOS = "VAD_SIGNAL_TYPE_EOS");
})(TT || (TT = {}));
var IT;
(function (t) {
 (t.TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED"), (t.ACTIVITY_START = "ACTIVITY_START"), (t.ACTIVITY_END = "ACTIVITY_END");
})(IT || (IT = {}));
var ST;
(function (t) {
 (t.START_SENSITIVITY_UNSPECIFIED = "START_SENSITIVITY_UNSPECIFIED"),
  (t.START_SENSITIVITY_HIGH = "START_SENSITIVITY_HIGH"),
  (t.START_SENSITIVITY_LOW = "START_SENSITIVITY_LOW");
})(ST || (ST = {}));
var AT;
(function (t) {
 (t.END_SENSITIVITY_UNSPECIFIED = "END_SENSITIVITY_UNSPECIFIED"),
  (t.END_SENSITIVITY_HIGH = "END_SENSITIVITY_HIGH"),
  (t.END_SENSITIVITY_LOW = "END_SENSITIVITY_LOW");
})(AT || (AT = {}));
var CT;
(function (t) {
 (t.ACTIVITY_HANDLING_UNSPECIFIED = "ACTIVITY_HANDLING_UNSPECIFIED"),
  (t.START_OF_ACTIVITY_INTERRUPTS = "START_OF_ACTIVITY_INTERRUPTS"),
  (t.NO_INTERRUPTION = "NO_INTERRUPTION");
})(CT || (CT = {}));
var RT;
(function (t) {
 (t.TURN_COVERAGE_UNSPECIFIED = "TURN_COVERAGE_UNSPECIFIED"),
  (t.TURN_INCLUDES_ONLY_ACTIVITY = "TURN_INCLUDES_ONLY_ACTIVITY"),
  (t.TURN_INCLUDES_ALL_INPUT = "TURN_INCLUDES_ALL_INPUT");
})(RT || (RT = {}));
var PT;
(function (t) {
 (t.SCALE_UNSPECIFIED = "SCALE_UNSPECIFIED"),
  (t.C_MAJOR_A_MINOR = "C_MAJOR_A_MINOR"),
  (t.D_FLAT_MAJOR_B_FLAT_MINOR = "D_FLAT_MAJOR_B_FLAT_MINOR"),
  (t.D_MAJOR_B_MINOR = "D_MAJOR_B_MINOR"),
  (t.E_FLAT_MAJOR_C_MINOR = "E_FLAT_MAJOR_C_MINOR"),
  (t.E_MAJOR_D_FLAT_MINOR = "E_MAJOR_D_FLAT_MINOR"),
  (t.F_MAJOR_D_MINOR = "F_MAJOR_D_MINOR"),
  (t.G_FLAT_MAJOR_E_FLAT_MINOR = "G_FLAT_MAJOR_E_FLAT_MINOR"),
  (t.G_MAJOR_E_MINOR = "G_MAJOR_E_MINOR"),
  (t.A_FLAT_MAJOR_F_MINOR = "A_FLAT_MAJOR_F_MINOR"),
  (t.A_MAJOR_G_FLAT_MINOR = "A_MAJOR_G_FLAT_MINOR"),
  (t.B_FLAT_MAJOR_G_MINOR = "B_FLAT_MAJOR_G_MINOR"),
  (t.B_MAJOR_A_FLAT_MINOR = "B_MAJOR_A_FLAT_MINOR");
})(PT || (PT = {}));
var kT;
(function (t) {
 (t.MUSIC_GENERATION_MODE_UNSPECIFIED = "MUSIC_GENERATION_MODE_UNSPECIFIED"),
  (t.QUALITY = "QUALITY"),
  (t.DIVERSITY = "DIVERSITY"),
  (t.VOCALIZATION = "VOCALIZATION");
})(kT || (kT = {}));
var is;
(function (t) {
 (t.PLAYBACK_CONTROL_UNSPECIFIED = "PLAYBACK_CONTROL_UNSPECIFIED"),
  (t.PLAY = "PLAY"),
  (t.PAUSE = "PAUSE"),
  (t.STOP = "STOP"),
  (t.RESET_CONTEXT = "RESET_CONTEXT");
})(is || (is = {}));
class Nm {
 constructor(e) {
  const n = {};
  for (const r of e.headers.entries()) n[r[0]] = r[1];
  (this.headers = n), (this.responseInternal = e);
 }
 json() {
  return this.responseInternal.json();
 }
}
class Sa {
 get text() {
  var e, n, r, i, o, s, a, l;
  if (
   ((i =
    (r =
     (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0
      ? void 0
      : n.content) === null || r === void 0
     ? void 0
     : r.parts) === null || i === void 0
    ? void 0
    : i.length) === 0
  )
   return;
  this.candidates &&
   this.candidates.length > 1 &&
   console.warn("there are multiple candidates in the response, returning text from the first one.");
  let u = "",
   h = !1;
  const p = [];
  for (const m of (l =
   (a =
    (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0
     ? void 0
     : s.content) === null || a === void 0
    ? void 0
    : a.parts) !== null && l !== void 0
   ? l
   : []) {
   for (const [v, w] of Object.entries(m))
    v !== "text" && v !== "thought" && v !== "thoughtSignature" && (w !== null || w !== void 0) && p.push(v);
   if (typeof m.text == "string") {
    if (typeof m.thought == "boolean" && m.thought) continue;
    (h = !0), (u += m.text);
   }
  }
  return (
   p.length > 0 &&
    console.warn(
     `there are non-text parts ${p} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`
    ),
   h ? u : void 0
  );
 }
 get data() {
  var e, n, r, i, o, s, a, l;
  if (
   ((i =
    (r =
     (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0
      ? void 0
      : n.content) === null || r === void 0
     ? void 0
     : r.parts) === null || i === void 0
    ? void 0
    : i.length) === 0
  )
   return;
  this.candidates &&
   this.candidates.length > 1 &&
   console.warn("there are multiple candidates in the response, returning data from the first one.");
  let u = "";
  const h = [];
  for (const p of (l =
   (a =
    (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0
     ? void 0
     : s.content) === null || a === void 0
    ? void 0
    : a.parts) !== null && l !== void 0
   ? l
   : []) {
   for (const [m, v] of Object.entries(p)) m !== "inlineData" && (v !== null || v !== void 0) && h.push(m);
   p.inlineData && typeof p.inlineData.data == "string" && (u += atob(p.inlineData.data));
  }
  return (
   h.length > 0 &&
    console.warn(
     `there are non-data parts ${h} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`
    ),
   u.length > 0 ? btoa(u) : void 0
  );
 }
 get functionCalls() {
  var e, n, r, i, o, s, a, l;
  if (
   ((i =
    (r =
     (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0
      ? void 0
      : n.content) === null || r === void 0
     ? void 0
     : r.parts) === null || i === void 0
    ? void 0
    : i.length) === 0
  )
   return;
  this.candidates &&
   this.candidates.length > 1 &&
   console.warn("there are multiple candidates in the response, returning function calls from the first one.");
  const u =
   (l =
    (a =
     (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0
      ? void 0
      : s.content) === null || a === void 0
     ? void 0
     : a.parts) === null || l === void 0
    ? void 0
    : l
       .filter((h) => h.functionCall)
       .map((h) => h.functionCall)
       .filter((h) => h !== void 0);
  if ((u == null ? void 0 : u.length) !== 0) return u;
 }
 get executableCode() {
  var e, n, r, i, o, s, a, l, u;
  if (
   ((i =
    (r =
     (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0
      ? void 0
      : n.content) === null || r === void 0
     ? void 0
     : r.parts) === null || i === void 0
    ? void 0
    : i.length) === 0
  )
   return;
  this.candidates &&
   this.candidates.length > 1 &&
   console.warn("there are multiple candidates in the response, returning executable code from the first one.");
  const h =
   (l =
    (a =
     (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0
      ? void 0
      : s.content) === null || a === void 0
     ? void 0
     : a.parts) === null || l === void 0
    ? void 0
    : l
       .filter((p) => p.executableCode)
       .map((p) => p.executableCode)
       .filter((p) => p !== void 0);
  if ((h == null ? void 0 : h.length) !== 0)
   return (u = h == null ? void 0 : h[0]) === null || u === void 0 ? void 0 : u.code;
 }
 get codeExecutionResult() {
  var e, n, r, i, o, s, a, l, u;
  if (
   ((i =
    (r =
     (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0
      ? void 0
      : n.content) === null || r === void 0
     ? void 0
     : r.parts) === null || i === void 0
    ? void 0
    : i.length) === 0
  )
   return;
  this.candidates &&
   this.candidates.length > 1 &&
   console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
  const h =
   (l =
    (a =
     (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0
      ? void 0
      : s.content) === null || a === void 0
     ? void 0
     : a.parts) === null || l === void 0
    ? void 0
    : l
       .filter((p) => p.codeExecutionResult)
       .map((p) => p.codeExecutionResult)
       .filter((p) => p !== void 0);
  if ((h == null ? void 0 : h.length) !== 0)
   return (u = h == null ? void 0 : h[0]) === null || u === void 0 ? void 0 : u.output;
 }
}
class bT {}
class NT {}
class zG {}
class WG {}
class KG {}
class JG {}
class xT {}
class MT {}
class DT {}
class YG {}
class Pd {
 _fromAPIResponse({ apiResponse: e, _isVertexAI: n }) {
  const r = new Pd();
  let i;
  const o = e;
  return n ? (i = MG(o)) : (i = xG(o)), Object.assign(r, i), r;
 }
}
class LT {}
class VT {}
class UT {}
class OT {}
class QG {}
class XG {}
class jG {}
class mv {
 _fromAPIResponse({ apiResponse: e, _isVertexAI: n }) {
  const r = new mv(),
   o = BG(e);
  return Object.assign(r, o), r;
 }
}
class ZG {}
class e5 {}
class t5 {}
class n5 {}
class FT {}
class r5 {
 get text() {
  var e, n, r;
  let i = "",
   o = !1;
  const s = [];
  for (const a of (r =
   (n = (e = this.serverContent) === null || e === void 0 ? void 0 : e.modelTurn) === null || n === void 0
    ? void 0
    : n.parts) !== null && r !== void 0
   ? r
   : []) {
   for (const [l, u] of Object.entries(a)) l !== "text" && l !== "thought" && u !== null && s.push(l);
   if (typeof a.text == "string") {
    if (typeof a.thought == "boolean" && a.thought) continue;
    (o = !0), (i += a.text);
   }
  }
  return (
   s.length > 0 &&
    console.warn(
     `there are non-text parts ${s} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`
    ),
   o ? i : void 0
  );
 }
 get data() {
  var e, n, r;
  let i = "";
  const o = [];
  for (const s of (r =
   (n = (e = this.serverContent) === null || e === void 0 ? void 0 : e.modelTurn) === null || n === void 0
    ? void 0
    : n.parts) !== null && r !== void 0
   ? r
   : []) {
   for (const [a, l] of Object.entries(s)) a !== "inlineData" && l !== null && o.push(a);
   s.inlineData && typeof s.inlineData.data == "string" && (i += atob(s.inlineData.data));
  }
  return (
   o.length > 0 &&
    console.warn(
     `there are non-data parts ${o} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`
    ),
   i.length > 0 ? btoa(i) : void 0
  );
 }
}
class i5 {
 get audioChunk() {
  if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0)
   return this.serverContent.audioChunks[0];
 }
}
class gv {
 _fromAPIResponse({ apiResponse: e, _isVertexAI: n }) {
  const r = new gv(),
   o = xk(e);
  return Object.assign(r, o), r;
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function ye(t, e) {
 if (!e || typeof e != "string") throw new Error("model is required and must be a string");
 if (e.includes("..") || e.includes("?") || e.includes("&")) throw new Error("invalid model parameter");
 if (t.isVertexAI()) {
  if (e.startsWith("publishers/") || e.startsWith("projects/") || e.startsWith("models/")) return e;
  if (e.indexOf("/") >= 0) {
   const n = e.split("/", 2);
   return `publishers/${n[0]}/models/${n[1]}`;
  } else return `publishers/google/models/${e}`;
 } else return e.startsWith("models/") || e.startsWith("tunedModels/") ? e : `models/${e}`;
}
function Mk(t, e) {
 const n = ye(t, e);
 return n
  ? n.startsWith("publishers/") && t.isVertexAI()
    ? `projects/${t.getProject()}/locations/${t.getLocation()}/${n}`
    : n.startsWith("models/") && t.isVertexAI()
      ? `projects/${t.getProject()}/locations/${t.getLocation()}/publishers/google/${n}`
      : n
  : "";
}
function Dk(t) {
 return Array.isArray(t) ? t.map((e) => kd(e)) : [kd(t)];
}
function kd(t) {
 if (typeof t == "object" && t !== null) return t;
 throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof t}`);
}
function Lk(t) {
 const e = kd(t);
 if (e.mimeType && e.mimeType.startsWith("image/")) return e;
 throw new Error(`Unsupported mime type: ${e.mimeType}`);
}
function Vk(t) {
 const e = kd(t);
 if (e.mimeType && e.mimeType.startsWith("audio/")) return e;
 throw new Error(`Unsupported mime type: ${e.mimeType}`);
}
function BT(t) {
 if (t == null) throw new Error("PartUnion is required");
 if (typeof t == "object") return t;
 if (typeof t == "string") return { text: t };
 throw new Error(`Unsupported part type: ${typeof t}`);
}
function Uk(t) {
 if (t == null || (Array.isArray(t) && t.length === 0)) throw new Error("PartListUnion is required");
 return Array.isArray(t) ? t.map((e) => BT(e)) : [BT(t)];
}
function xm(t) {
 return t != null && typeof t == "object" && "parts" in t && Array.isArray(t.parts);
}
function $T(t) {
 return t != null && typeof t == "object" && "functionCall" in t;
}
function HT(t) {
 return t != null && typeof t == "object" && "functionResponse" in t;
}
function bt(t) {
 if (t == null) throw new Error("ContentUnion is required");
 return xm(t) ? t : { role: "user", parts: Uk(t) };
}
function yv(t, e) {
 if (!e) return [];
 if (t.isVertexAI() && Array.isArray(e))
  return e.flatMap((n) => {
   const r = bt(n);
   return r.parts && r.parts.length > 0 && r.parts[0].text !== void 0 ? [r.parts[0].text] : [];
  });
 if (t.isVertexAI()) {
  const n = bt(e);
  return n.parts && n.parts.length > 0 && n.parts[0].text !== void 0 ? [n.parts[0].text] : [];
 }
 return Array.isArray(e) ? e.map((n) => bt(n)) : [bt(e)];
}
function Sn(t) {
 if (t == null || (Array.isArray(t) && t.length === 0)) throw new Error("contents are required");
 if (!Array.isArray(t)) {
  if ($T(t) || HT(t))
   throw new Error(
    "To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them"
   );
  return [bt(t)];
 }
 const e = [],
  n = [],
  r = xm(t[0]);
 for (const i of t) {
  const o = xm(i);
  if (o != r)
   throw new Error(
    "Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them"
   );
  if (o) e.push(i);
  else {
   if ($T(i) || HT(i))
    throw new Error(
     "To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them"
    );
   n.push(i);
  }
 }
 return r || e.push({ role: "user", parts: Uk(n) }), e;
}
function o5(t, e) {
 t.includes("null") && (e.nullable = !0);
 const n = t.filter((r) => r !== "null");
 if (n.length === 1) e.type = Object.values(Rt).includes(n[0].toUpperCase()) ? n[0].toUpperCase() : Rt.TYPE_UNSPECIFIED;
 else {
  e.anyOf = [];
  for (const r of n)
   e.anyOf.push({ type: Object.values(Rt).includes(r.toUpperCase()) ? r.toUpperCase() : Rt.TYPE_UNSPECIFIED });
 }
}
function ys(t) {
 const e = {},
  n = ["items"],
  r = ["anyOf"],
  i = ["properties"];
 if (t.type && t.anyOf) throw new Error("type and anyOf cannot be both populated.");
 const o = t.anyOf;
 o != null &&
  o.length == 2 &&
  (o[0].type === "null" ? ((e.nullable = !0), (t = o[1])) : o[1].type === "null" && ((e.nullable = !0), (t = o[0]))),
  t.type instanceof Array && o5(t.type, e);
 for (const [s, a] of Object.entries(t))
  if (a != null)
   if (s == "type") {
    if (a === "null") throw new Error("type: null can not be the only possible type for the field.");
    if (a instanceof Array) continue;
    e.type = Object.values(Rt).includes(a.toUpperCase()) ? a.toUpperCase() : Rt.TYPE_UNSPECIFIED;
   } else if (n.includes(s)) e[s] = ys(a);
   else if (r.includes(s)) {
    const l = [];
    for (const u of a) {
     if (u.type == "null") {
      e.nullable = !0;
      continue;
     }
     l.push(ys(u));
    }
    e[s] = l;
   } else if (i.includes(s)) {
    const l = {};
    for (const [u, h] of Object.entries(a)) l[u] = ys(h);
    e[s] = l;
   } else {
    if (s === "additionalProperties") continue;
    e[s] = a;
   }
 return e;
}
function vv(t) {
 return ys(t);
}
function _v(t) {
 if (typeof t == "object") return t;
 if (typeof t == "string") return { voiceConfig: { prebuiltVoiceConfig: { voiceName: t } } };
 throw new Error(`Unsupported speechConfig type: ${typeof t}`);
}
function wv(t) {
 if ("multiSpeakerVoiceConfig" in t) throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
 return t;
}
function Qs(t) {
 if (t.functionDeclarations)
  for (const e of t.functionDeclarations)
   e.parameters &&
    (Object.keys(e.parameters).includes("$schema")
     ? e.parametersJsonSchema || ((e.parametersJsonSchema = e.parameters), delete e.parameters)
     : (e.parameters = ys(e.parameters))),
    e.response &&
     (Object.keys(e.response).includes("$schema")
      ? e.responseJsonSchema || ((e.responseJsonSchema = e.response), delete e.response)
      : (e.response = ys(e.response)));
 return t;
}
function Xs(t) {
 if (t == null) throw new Error("tools is required");
 if (!Array.isArray(t)) throw new Error("tools is required and must be an array of Tools");
 const e = [];
 for (const n of t) e.push(n);
 return e;
}
function s5(t, e, n, r = 1) {
 const i = !e.startsWith(`${n}/`) && e.split("/").length === r;
 return t.isVertexAI()
  ? e.startsWith("projects/")
    ? e
    : e.startsWith("locations/")
      ? `projects/${t.getProject()}/${e}`
      : e.startsWith(`${n}/`)
        ? `projects/${t.getProject()}/locations/${t.getLocation()}/${e}`
        : i
          ? `projects/${t.getProject()}/locations/${t.getLocation()}/${n}/${e}`
          : e
  : i
    ? `${n}/${e}`
    : e;
}
function Br(t, e) {
 if (typeof e != "string") throw new Error("name must be a string");
 return s5(t, e, "cachedContents");
}
function Ok(t) {
 switch (t) {
  case "STATE_UNSPECIFIED":
   return "JOB_STATE_UNSPECIFIED";
  case "CREATING":
   return "JOB_STATE_RUNNING";
  case "ACTIVE":
   return "JOB_STATE_SUCCEEDED";
  case "FAILED":
   return "JOB_STATE_FAILED";
  default:
   return t;
 }
}
function Vi(t) {
 return pv(t);
}
function a5(t) {
 return t != null && typeof t == "object" && "name" in t;
}
function l5(t) {
 return t != null && typeof t == "object" && "video" in t;
}
function u5(t) {
 return t != null && typeof t == "object" && "uri" in t;
}
function Fk(t) {
 var e;
 let n;
 if (
  (a5(t) && (n = t.name),
  !(u5(t) && ((n = t.uri), n === void 0)) &&
   !(l5(t) && ((n = (e = t.video) === null || e === void 0 ? void 0 : e.uri), n === void 0)))
 ) {
  if ((typeof t == "string" && (n = t), n === void 0))
   throw new Error("Could not extract file name from the provided input.");
  if (n.startsWith("https://")) {
   const i = n.split("files/")[1].match(/[a-z0-9]+/);
   if (i === null) throw new Error(`Could not extract file name from URI ${n}`);
   n = i[0];
  } else n.startsWith("files/") && (n = n.split("files/")[1]);
  return n;
 }
}
function Bk(t, e) {
 let n;
 return t.isVertexAI() ? (n = e ? "publishers/google/models" : "models") : (n = e ? "models" : "tunedModels"), n;
}
function $k(t) {
 for (const e of ["models", "tunedModels", "publisherModels"]) if (c5(t, e)) return t[e];
 return [];
}
function c5(t, e) {
 return t !== null && typeof t == "object" && e in t;
}
function d5(t, e = {}) {
 const n = t,
  r = { name: n.name, description: n.description, parametersJsonSchema: n.inputSchema };
 return (
  n.outputSchema && (r.responseJsonSchema = n.outputSchema),
  e.behavior && (r.behavior = e.behavior),
  { functionDeclarations: [r] }
 );
}
function f5(t, e = {}) {
 const n = [],
  r = new Set();
 for (const i of t) {
  const o = i.name;
  if (r.has(o))
   throw new Error(`Duplicate function name ${o} found in MCP tools. Please ensure function names are unique.`);
  r.add(o);
  const s = d5(i, e);
  s.functionDeclarations && n.push(...s.functionDeclarations);
 }
 return { functionDeclarations: n };
}
function Hk(t, e) {
 let n;
 if (typeof e == "string")
  if (t.isVertexAI())
   if (e.startsWith("gs://")) n = { format: "jsonl", gcsUri: [e] };
   else if (e.startsWith("bq://")) n = { format: "bigquery", bigqueryUri: e };
   else throw new Error(`Unsupported string source for Vertex AI: ${e}`);
  else if (e.startsWith("files/")) n = { fileName: e };
  else throw new Error(`Unsupported string source for Gemini API: ${e}`);
 else if (Array.isArray(e)) {
  if (t.isVertexAI()) throw new Error("InlinedRequest[] is not supported in Vertex AI.");
  n = { inlinedRequests: e };
 } else n = e;
 const r = [n.gcsUri, n.bigqueryUri].filter(Boolean).length,
  i = [n.inlinedRequests, n.fileName].filter(Boolean).length;
 if (t.isVertexAI()) {
  if (i > 0 || r !== 1) throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
 } else if (r > 0 || i !== 1)
  throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
 return n;
}
function h5(t) {
 if (typeof t != "string") return t;
 const e = t;
 if (e.startsWith("gs://")) return { format: "jsonl", gcsUri: e };
 if (e.startsWith("bq://")) return { format: "bigquery", bigqueryUri: e };
 throw new Error(`Unsupported destination: ${e}`);
}
function qk(t) {
 if (typeof t != "object" || t === null) return {};
 const e = t,
  n = e.inlinedResponses;
 if (typeof n != "object" || n === null) return t;
 const i = n.inlinedResponses;
 if (!Array.isArray(i) || i.length === 0) return t;
 let o = !1;
 for (const s of i) {
  if (typeof s != "object" || s === null) continue;
  const l = s.response;
  if (typeof l != "object" || l === null) continue;
  if (l.embedding !== void 0) {
   o = !0;
   break;
  }
 }
 return o && ((e.inlinedEmbedContentResponses = e.inlinedResponses), delete e.inlinedResponses), t;
}
function js(t, e) {
 const n = e;
 if (!t.isVertexAI()) {
  if (/batches\/[^/]+$/.test(n)) return n.split("/").pop();
  throw new Error(`Invalid batch job name: ${n}.`);
 }
 if (/^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/.test(n)) return n.split("/").pop();
 if (/^\d+$/.test(n)) return n;
 throw new Error(`Invalid batch job name: ${n}.`);
}
function Gk(t) {
 const e = t;
 return e === "BATCH_STATE_UNSPECIFIED"
  ? "JOB_STATE_UNSPECIFIED"
  : e === "BATCH_STATE_PENDING"
    ? "JOB_STATE_PENDING"
    : e === "BATCH_STATE_RUNNING"
      ? "JOB_STATE_RUNNING"
      : e === "BATCH_STATE_SUCCEEDED"
        ? "JOB_STATE_SUCCEEDED"
        : e === "BATCH_STATE_FAILED"
          ? "JOB_STATE_FAILED"
          : e === "BATCH_STATE_CANCELLED"
            ? "JOB_STATE_CANCELLED"
            : e === "BATCH_STATE_EXPIRED"
              ? "JOB_STATE_EXPIRED"
              : e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function p5(t) {
 const e = {},
  n = c(t, ["responsesFile"]);
 n != null && d(e, ["fileName"], n);
 const r = c(t, ["inlinedResponses", "inlinedResponses"]);
 if (r != null) {
  let o = r;
  Array.isArray(o) && (o = o.map((s) => J5(s))), d(e, ["inlinedResponses"], o);
 }
 const i = c(t, ["inlinedEmbedContentResponses", "inlinedResponses"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => s)), d(e, ["inlinedEmbedContentResponses"], o);
 }
 return e;
}
function m5(t) {
 const e = {},
  n = c(t, ["predictionsFormat"]);
 n != null && d(e, ["format"], n);
 const r = c(t, ["gcsDestination", "outputUriPrefix"]);
 r != null && d(e, ["gcsUri"], r);
 const i = c(t, ["bigqueryDestination", "outputUri"]);
 return i != null && d(e, ["bigqueryUri"], i), e;
}
function g5(t) {
 const e = {},
  n = c(t, ["format"]);
 n != null && d(e, ["predictionsFormat"], n);
 const r = c(t, ["gcsUri"]);
 r != null && d(e, ["gcsDestination", "outputUriPrefix"], r);
 const i = c(t, ["bigqueryUri"]);
 if ((i != null && d(e, ["bigqueryDestination", "outputUri"], i), c(t, ["fileName"]) !== void 0))
  throw new Error("fileName parameter is not supported in Vertex AI.");
 if (c(t, ["inlinedResponses"]) !== void 0)
  throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
 if (c(t, ["inlinedEmbedContentResponses"]) !== void 0)
  throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
 return e;
}
function Pc(t) {
 const e = {},
  n = c(t, ["name"]);
 n != null && d(e, ["name"], n);
 const r = c(t, ["metadata", "displayName"]);
 r != null && d(e, ["displayName"], r);
 const i = c(t, ["metadata", "state"]);
 i != null && d(e, ["state"], Gk(i));
 const o = c(t, ["metadata", "createTime"]);
 o != null && d(e, ["createTime"], o);
 const s = c(t, ["metadata", "endTime"]);
 s != null && d(e, ["endTime"], s);
 const a = c(t, ["metadata", "updateTime"]);
 a != null && d(e, ["updateTime"], a);
 const l = c(t, ["metadata", "model"]);
 l != null && d(e, ["model"], l);
 const u = c(t, ["metadata", "output"]);
 return u != null && d(e, ["dest"], p5(qk(u))), e;
}
function Mm(t) {
 const e = {},
  n = c(t, ["name"]);
 n != null && d(e, ["name"], n);
 const r = c(t, ["displayName"]);
 r != null && d(e, ["displayName"], r);
 const i = c(t, ["state"]);
 i != null && d(e, ["state"], Gk(i));
 const o = c(t, ["error"]);
 o != null && d(e, ["error"], o);
 const s = c(t, ["createTime"]);
 s != null && d(e, ["createTime"], s);
 const a = c(t, ["startTime"]);
 a != null && d(e, ["startTime"], a);
 const l = c(t, ["endTime"]);
 l != null && d(e, ["endTime"], l);
 const u = c(t, ["updateTime"]);
 u != null && d(e, ["updateTime"], u);
 const h = c(t, ["model"]);
 h != null && d(e, ["model"], h);
 const p = c(t, ["inputConfig"]);
 p != null && d(e, ["src"], y5(p));
 const m = c(t, ["outputConfig"]);
 m != null && d(e, ["dest"], m5(qk(m)));
 const v = c(t, ["completionStats"]);
 return v != null && d(e, ["completionStats"], v), e;
}
function y5(t) {
 const e = {},
  n = c(t, ["instancesFormat"]);
 n != null && d(e, ["format"], n);
 const r = c(t, ["gcsSource", "uris"]);
 r != null && d(e, ["gcsUri"], r);
 const i = c(t, ["bigquerySource", "inputUri"]);
 return i != null && d(e, ["bigqueryUri"], i), e;
}
function v5(t, e) {
 const n = {};
 if (c(e, ["format"]) !== void 0) throw new Error("format parameter is not supported in Gemini API.");
 if (c(e, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API.");
 if (c(e, ["bigqueryUri"]) !== void 0) throw new Error("bigqueryUri parameter is not supported in Gemini API.");
 const r = c(e, ["fileName"]);
 r != null && d(n, ["fileName"], r);
 const i = c(e, ["inlinedRequests"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => K5(t, s))), d(n, ["requests", "requests"], o);
 }
 return n;
}
function _5(t) {
 const e = {},
  n = c(t, ["format"]);
 n != null && d(e, ["instancesFormat"], n);
 const r = c(t, ["gcsUri"]);
 r != null && d(e, ["gcsSource", "uris"], r);
 const i = c(t, ["bigqueryUri"]);
 if ((i != null && d(e, ["bigquerySource", "inputUri"], i), c(t, ["fileName"]) !== void 0))
  throw new Error("fileName parameter is not supported in Vertex AI.");
 if (c(t, ["inlinedRequests"]) !== void 0) throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
 return e;
}
function w5(t) {
 const e = {},
  n = c(t, ["data"]);
 if ((n != null && d(e, ["data"], n), c(t, ["displayName"]) !== void 0))
  throw new Error("displayName parameter is not supported in Gemini API.");
 const r = c(t, ["mimeType"]);
 return r != null && d(e, ["mimeType"], r), e;
}
function E5(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], js(t, r)), n;
}
function T5(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], js(t, r)), n;
}
function I5(t) {
 const e = {},
  n = c(t, ["content"]);
 n != null && d(e, ["content"], n);
 const r = c(t, ["citationMetadata"]);
 r != null && d(e, ["citationMetadata"], S5(r));
 const i = c(t, ["tokenCount"]);
 i != null && d(e, ["tokenCount"], i);
 const o = c(t, ["finishReason"]);
 o != null && d(e, ["finishReason"], o);
 const s = c(t, ["avgLogprobs"]);
 s != null && d(e, ["avgLogprobs"], s);
 const a = c(t, ["groundingMetadata"]);
 a != null && d(e, ["groundingMetadata"], a);
 const l = c(t, ["index"]);
 l != null && d(e, ["index"], l);
 const u = c(t, ["logprobsResult"]);
 u != null && d(e, ["logprobsResult"], u);
 const h = c(t, ["safetyRatings"]);
 if (h != null) {
  let m = h;
  Array.isArray(m) && (m = m.map((v) => v)), d(e, ["safetyRatings"], m);
 }
 const p = c(t, ["urlContextMetadata"]);
 return p != null && d(e, ["urlContextMetadata"], p), e;
}
function S5(t) {
 const e = {},
  n = c(t, ["citationSources"]);
 if (n != null) {
  let r = n;
  Array.isArray(r) && (r = r.map((i) => i)), d(e, ["citations"], r);
 }
 return e;
}
function zk(t) {
 const e = {},
  n = c(t, ["parts"]);
 if (n != null) {
  let i = n;
  Array.isArray(i) && (i = i.map((o) => t3(o))), d(e, ["parts"], i);
 }
 const r = c(t, ["role"]);
 return r != null && d(e, ["role"], r), e;
}
function A5(t, e) {
 const n = {},
  r = c(t, ["displayName"]);
 if ((e !== void 0 && r != null && d(e, ["batch", "displayName"], r), c(t, ["dest"]) !== void 0))
  throw new Error("dest parameter is not supported in Gemini API.");
 return n;
}
function C5(t, e) {
 const n = {},
  r = c(t, ["displayName"]);
 e !== void 0 && r != null && d(e, ["displayName"], r);
 const i = c(t, ["dest"]);
 return e !== void 0 && i != null && d(e, ["outputConfig"], g5(h5(i))), n;
}
function qT(t, e) {
 const n = {},
  r = c(e, ["model"]);
 r != null && d(n, ["_url", "model"], ye(t, r));
 const i = c(e, ["src"]);
 i != null && d(n, ["batch", "inputConfig"], v5(t, Hk(t, i)));
 const o = c(e, ["config"]);
 return o != null && A5(o, n), n;
}
function R5(t, e) {
 const n = {},
  r = c(e, ["model"]);
 r != null && d(n, ["model"], ye(t, r));
 const i = c(e, ["src"]);
 i != null && d(n, ["inputConfig"], _5(Hk(t, i)));
 const o = c(e, ["config"]);
 return o != null && C5(o, n), n;
}
function P5(t, e) {
 const n = {},
  r = c(t, ["displayName"]);
 return e !== void 0 && r != null && d(e, ["batch", "displayName"], r), n;
}
function k5(t, e) {
 const n = {},
  r = c(e, ["model"]);
 r != null && d(n, ["_url", "model"], ye(t, r));
 const i = c(e, ["src"]);
 i != null && d(n, ["batch", "inputConfig"], V5(t, i));
 const o = c(e, ["config"]);
 return o != null && P5(o, n), n;
}
function b5(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], js(t, r)), n;
}
function N5(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], js(t, r)), n;
}
function x5(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["name"]);
 r != null && d(e, ["name"], r);
 const i = c(t, ["done"]);
 i != null && d(e, ["done"], i);
 const o = c(t, ["error"]);
 return o != null && d(e, ["error"], o), e;
}
function M5(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["name"]);
 r != null && d(e, ["name"], r);
 const i = c(t, ["done"]);
 i != null && d(e, ["done"], i);
 const o = c(t, ["error"]);
 return o != null && d(e, ["error"], o), e;
}
function D5(t, e) {
 const n = {},
  r = c(e, ["contents"]);
 if (r != null) {
  let o = yv(t, r);
  Array.isArray(o) && (o = o.map((s) => s)), d(n, ["requests[]", "request", "content"], o);
 }
 const i = c(e, ["config"]);
 return i != null && (d(n, ["_self"], L5(i, n)), bG(n, { "requests[].*": "requests[].request.*" })), n;
}
function L5(t, e) {
 const n = {},
  r = c(t, ["taskType"]);
 e !== void 0 && r != null && d(e, ["requests[]", "taskType"], r);
 const i = c(t, ["title"]);
 e !== void 0 && i != null && d(e, ["requests[]", "title"], i);
 const o = c(t, ["outputDimensionality"]);
 if ((e !== void 0 && o != null && d(e, ["requests[]", "outputDimensionality"], o), c(t, ["mimeType"]) !== void 0))
  throw new Error("mimeType parameter is not supported in Gemini API.");
 if (c(t, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API.");
 return n;
}
function V5(t, e) {
 const n = {},
  r = c(e, ["fileName"]);
 r != null && d(n, ["file_name"], r);
 const i = c(e, ["inlinedRequests"]);
 return i != null && d(n, ["requests"], D5(t, i)), n;
}
function U5(t) {
 const e = {};
 if (c(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
 const n = c(t, ["fileUri"]);
 n != null && d(e, ["fileUri"], n);
 const r = c(t, ["mimeType"]);
 return r != null && d(e, ["mimeType"], r), e;
}
function O5(t) {
 const e = {},
  n = c(t, ["id"]);
 n != null && d(e, ["id"], n);
 const r = c(t, ["args"]);
 r != null && d(e, ["args"], r);
 const i = c(t, ["name"]);
 if ((i != null && d(e, ["name"], i), c(t, ["partialArgs"]) !== void 0))
  throw new Error("partialArgs parameter is not supported in Gemini API.");
 if (c(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
 return e;
}
function F5(t) {
 const e = {},
  n = c(t, ["allowedFunctionNames"]);
 n != null && d(e, ["allowedFunctionNames"], n);
 const r = c(t, ["mode"]);
 if ((r != null && d(e, ["mode"], r), c(t, ["streamFunctionCallArguments"]) !== void 0))
  throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
 return e;
}
function B5(t, e, n) {
 const r = {},
  i = c(e, ["systemInstruction"]);
 n !== void 0 && i != null && d(n, ["systemInstruction"], zk(bt(i)));
 const o = c(e, ["temperature"]);
 o != null && d(r, ["temperature"], o);
 const s = c(e, ["topP"]);
 s != null && d(r, ["topP"], s);
 const a = c(e, ["topK"]);
 a != null && d(r, ["topK"], a);
 const l = c(e, ["candidateCount"]);
 l != null && d(r, ["candidateCount"], l);
 const u = c(e, ["maxOutputTokens"]);
 u != null && d(r, ["maxOutputTokens"], u);
 const h = c(e, ["stopSequences"]);
 h != null && d(r, ["stopSequences"], h);
 const p = c(e, ["responseLogprobs"]);
 p != null && d(r, ["responseLogprobs"], p);
 const m = c(e, ["logprobs"]);
 m != null && d(r, ["logprobs"], m);
 const v = c(e, ["presencePenalty"]);
 v != null && d(r, ["presencePenalty"], v);
 const w = c(e, ["frequencyPenalty"]);
 w != null && d(r, ["frequencyPenalty"], w);
 const C = c(e, ["seed"]);
 C != null && d(r, ["seed"], C);
 const A = c(e, ["responseMimeType"]);
 A != null && d(r, ["responseMimeType"], A);
 const T = c(e, ["responseSchema"]);
 T != null && d(r, ["responseSchema"], vv(T));
 const _ = c(e, ["responseJsonSchema"]);
 if ((_ != null && d(r, ["responseJsonSchema"], _), c(e, ["routingConfig"]) !== void 0))
  throw new Error("routingConfig parameter is not supported in Gemini API.");
 if (c(e, ["modelSelectionConfig"]) !== void 0)
  throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
 const E = c(e, ["safetySettings"]);
 if (n !== void 0 && E != null) {
  let b = E;
  Array.isArray(b) && (b = b.map((se) => n3(se))), d(n, ["safetySettings"], b);
 }
 const N = c(e, ["tools"]);
 if (n !== void 0 && N != null) {
  let b = Xs(N);
  Array.isArray(b) && (b = b.map((se) => i3(Qs(se)))), d(n, ["tools"], b);
 }
 const M = c(e, ["toolConfig"]);
 if ((n !== void 0 && M != null && d(n, ["toolConfig"], r3(M)), c(e, ["labels"]) !== void 0))
  throw new Error("labels parameter is not supported in Gemini API.");
 const F = c(e, ["cachedContent"]);
 n !== void 0 && F != null && d(n, ["cachedContent"], Br(t, F));
 const P = c(e, ["responseModalities"]);
 P != null && d(r, ["responseModalities"], P);
 const I = c(e, ["mediaResolution"]);
 I != null && d(r, ["mediaResolution"], I);
 const R = c(e, ["speechConfig"]);
 if ((R != null && d(r, ["speechConfig"], _v(R)), c(e, ["audioTimestamp"]) !== void 0))
  throw new Error("audioTimestamp parameter is not supported in Gemini API.");
 const k = c(e, ["thinkingConfig"]);
 k != null && d(r, ["thinkingConfig"], k);
 const x = c(e, ["imageConfig"]);
 x != null && d(r, ["imageConfig"], W5(x));
 const D = c(e, ["enableEnhancedCivicAnswers"]);
 if ((D != null && d(r, ["enableEnhancedCivicAnswers"], D), c(e, ["modelArmorConfig"]) !== void 0))
  throw new Error("modelArmorConfig parameter is not supported in Gemini API.");
 return r;
}
function $5(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["candidates"]);
 if (r != null) {
  let l = r;
  Array.isArray(l) && (l = l.map((u) => I5(u))), d(e, ["candidates"], l);
 }
 const i = c(t, ["modelVersion"]);
 i != null && d(e, ["modelVersion"], i);
 const o = c(t, ["promptFeedback"]);
 o != null && d(e, ["promptFeedback"], o);
 const s = c(t, ["responseId"]);
 s != null && d(e, ["responseId"], s);
 const a = c(t, ["usageMetadata"]);
 return a != null && d(e, ["usageMetadata"], a), e;
}
function H5(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], js(t, r)), n;
}
function q5(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], js(t, r)), n;
}
function G5(t) {
 const e = {};
 if (c(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
 const n = c(t, ["enableWidget"]);
 return n != null && d(e, ["enableWidget"], n), e;
}
function z5(t) {
 const e = {};
 if (c(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
 if (c(t, ["blockingConfidence"]) !== void 0)
  throw new Error("blockingConfidence parameter is not supported in Gemini API.");
 const n = c(t, ["timeRangeFilter"]);
 return n != null && d(e, ["timeRangeFilter"], n), e;
}
function W5(t) {
 const e = {},
  n = c(t, ["aspectRatio"]);
 n != null && d(e, ["aspectRatio"], n);
 const r = c(t, ["imageSize"]);
 if ((r != null && d(e, ["imageSize"], r), c(t, ["personGeneration"]) !== void 0))
  throw new Error("personGeneration parameter is not supported in Gemini API.");
 if (c(t, ["outputMimeType"]) !== void 0) throw new Error("outputMimeType parameter is not supported in Gemini API.");
 if (c(t, ["outputCompressionQuality"]) !== void 0)
  throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
 return e;
}
function K5(t, e) {
 const n = {},
  r = c(e, ["model"]);
 r != null && d(n, ["request", "model"], ye(t, r));
 const i = c(e, ["contents"]);
 if (i != null) {
  let a = Sn(i);
  Array.isArray(a) && (a = a.map((l) => zk(l))), d(n, ["request", "contents"], a);
 }
 const o = c(e, ["metadata"]);
 o != null && d(n, ["metadata"], o);
 const s = c(e, ["config"]);
 return s != null && d(n, ["request", "generationConfig"], B5(t, s, c(n, ["request"], {}))), n;
}
function J5(t) {
 const e = {},
  n = c(t, ["response"]);
 n != null && d(e, ["response"], $5(n));
 const r = c(t, ["metadata"]);
 r != null && d(e, ["metadata"], r);
 const i = c(t, ["error"]);
 return i != null && d(e, ["error"], i), e;
}
function Y5(t, e) {
 const n = {},
  r = c(t, ["pageSize"]);
 e !== void 0 && r != null && d(e, ["_query", "pageSize"], r);
 const i = c(t, ["pageToken"]);
 if ((e !== void 0 && i != null && d(e, ["_query", "pageToken"], i), c(t, ["filter"]) !== void 0))
  throw new Error("filter parameter is not supported in Gemini API.");
 return n;
}
function Q5(t, e) {
 const n = {},
  r = c(t, ["pageSize"]);
 e !== void 0 && r != null && d(e, ["_query", "pageSize"], r);
 const i = c(t, ["pageToken"]);
 e !== void 0 && i != null && d(e, ["_query", "pageToken"], i);
 const o = c(t, ["filter"]);
 return e !== void 0 && o != null && d(e, ["_query", "filter"], o), n;
}
function X5(t) {
 const e = {},
  n = c(t, ["config"]);
 return n != null && Y5(n, e), e;
}
function j5(t) {
 const e = {},
  n = c(t, ["config"]);
 return n != null && Q5(n, e), e;
}
function Z5(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["nextPageToken"]);
 r != null && d(e, ["nextPageToken"], r);
 const i = c(t, ["operations"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => Pc(s))), d(e, ["batchJobs"], o);
 }
 return e;
}
function e3(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["nextPageToken"]);
 r != null && d(e, ["nextPageToken"], r);
 const i = c(t, ["batchPredictionJobs"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => Mm(s))), d(e, ["batchJobs"], o);
 }
 return e;
}
function t3(t) {
 const e = {},
  n = c(t, ["mediaResolution"]);
 n != null && d(e, ["mediaResolution"], n);
 const r = c(t, ["codeExecutionResult"]);
 r != null && d(e, ["codeExecutionResult"], r);
 const i = c(t, ["executableCode"]);
 i != null && d(e, ["executableCode"], i);
 const o = c(t, ["fileData"]);
 o != null && d(e, ["fileData"], U5(o));
 const s = c(t, ["functionCall"]);
 s != null && d(e, ["functionCall"], O5(s));
 const a = c(t, ["functionResponse"]);
 a != null && d(e, ["functionResponse"], a);
 const l = c(t, ["inlineData"]);
 l != null && d(e, ["inlineData"], w5(l));
 const u = c(t, ["text"]);
 u != null && d(e, ["text"], u);
 const h = c(t, ["thought"]);
 h != null && d(e, ["thought"], h);
 const p = c(t, ["thoughtSignature"]);
 p != null && d(e, ["thoughtSignature"], p);
 const m = c(t, ["videoMetadata"]);
 return m != null && d(e, ["videoMetadata"], m), e;
}
function n3(t) {
 const e = {},
  n = c(t, ["category"]);
 if ((n != null && d(e, ["category"], n), c(t, ["method"]) !== void 0))
  throw new Error("method parameter is not supported in Gemini API.");
 const r = c(t, ["threshold"]);
 return r != null && d(e, ["threshold"], r), e;
}
function r3(t) {
 const e = {},
  n = c(t, ["retrievalConfig"]);
 n != null && d(e, ["retrievalConfig"], n);
 const r = c(t, ["functionCallingConfig"]);
 return r != null && d(e, ["functionCallingConfig"], F5(r)), e;
}
function i3(t) {
 const e = {};
 if (c(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
 const n = c(t, ["computerUse"]);
 n != null && d(e, ["computerUse"], n);
 const r = c(t, ["fileSearch"]);
 r != null && d(e, ["fileSearch"], r);
 const i = c(t, ["codeExecution"]);
 if ((i != null && d(e, ["codeExecution"], i), c(t, ["enterpriseWebSearch"]) !== void 0))
  throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
 const o = c(t, ["functionDeclarations"]);
 if (o != null) {
  let h = o;
  Array.isArray(h) && (h = h.map((p) => p)), d(e, ["functionDeclarations"], h);
 }
 const s = c(t, ["googleMaps"]);
 s != null && d(e, ["googleMaps"], G5(s));
 const a = c(t, ["googleSearch"]);
 a != null && d(e, ["googleSearch"], z5(a));
 const l = c(t, ["googleSearchRetrieval"]);
 l != null && d(e, ["googleSearchRetrieval"], l);
 const u = c(t, ["urlContext"]);
 return u != null && d(e, ["urlContext"], u), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ var Dr;
(function (t) {
 (t.PAGED_ITEM_BATCH_JOBS = "batchJobs"),
  (t.PAGED_ITEM_MODELS = "models"),
  (t.PAGED_ITEM_TUNING_JOBS = "tuningJobs"),
  (t.PAGED_ITEM_FILES = "files"),
  (t.PAGED_ITEM_CACHED_CONTENTS = "cachedContents"),
  (t.PAGED_ITEM_FILE_SEARCH_STORES = "fileSearchStores"),
  (t.PAGED_ITEM_DOCUMENTS = "documents");
})(Dr || (Dr = {}));
class Mo {
 constructor(e, n, r, i) {
  (this.pageInternal = []), (this.paramsInternal = {}), (this.requestInternal = n), this.init(e, r, i);
 }
 init(e, n, r) {
  var i, o;
  (this.nameInternal = e),
   (this.pageInternal = n[this.nameInternal] || []),
   (this.sdkHttpResponseInternal = n == null ? void 0 : n.sdkHttpResponse),
   (this.idxInternal = 0);
  let s = { config: {} };
  !r || Object.keys(r).length === 0
   ? (s = { config: {} })
   : typeof r == "object"
     ? (s = Object.assign({}, r))
     : (s = r),
   s.config && (s.config.pageToken = n.nextPageToken),
   (this.paramsInternal = s),
   (this.pageInternalSize =
    (o = (i = s.config) === null || i === void 0 ? void 0 : i.pageSize) !== null && o !== void 0
     ? o
     : this.pageInternal.length);
 }
 initNextPage(e) {
  this.init(this.nameInternal, e, this.paramsInternal);
 }
 get page() {
  return this.pageInternal;
 }
 get name() {
  return this.nameInternal;
 }
 get pageSize() {
  return this.pageInternalSize;
 }
 get sdkHttpResponse() {
  return this.sdkHttpResponseInternal;
 }
 get params() {
  return this.paramsInternal;
 }
 get pageLength() {
  return this.pageInternal.length;
 }
 getItem(e) {
  return this.pageInternal[e];
 }
 [Symbol.asyncIterator]() {
  return {
   next: async () => {
    if (this.idxInternal >= this.pageLength)
     if (this.hasNextPage()) await this.nextPage();
     else return { value: void 0, done: !0 };
    const e = this.getItem(this.idxInternal);
    return (this.idxInternal += 1), { value: e, done: !1 };
   },
   return: async () => ({ value: void 0, done: !0 }),
  };
 }
 async nextPage() {
  if (!this.hasNextPage()) throw new Error("No more pages to fetch.");
  const e = await this.requestInternal(this.params);
  return this.initNextPage(e), this.page;
 }
 hasNextPage() {
  var e;
  return ((e = this.params.config) === null || e === void 0 ? void 0 : e.pageToken) !== void 0;
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class o3 extends Fr {
 constructor(e) {
  super(),
   (this.apiClient = e),
   (this.list = async (n = {}) =>
    new Mo(Dr.PAGED_ITEM_BATCH_JOBS, (r) => this.listInternal(r), await this.listInternal(n), n)),
   (this.create = async (n) => (
    this.apiClient.isVertexAI() && (n.config = this.formatDestination(n.src, n.config)), this.createInternal(n)
   )),
   (this.createEmbeddings = async (n) => {
    if (
     (console.warn("batches.createEmbeddings() is experimental and may change without notice."),
     this.apiClient.isVertexAI())
    )
     throw new Error("Vertex AI does not support batches.createEmbeddings.");
    return this.createEmbeddingsInternal(n);
   });
 }
 createInlinedGenerateContentRequest(e) {
  const n = qT(this.apiClient, e),
   r = n._url,
   i = K("{model}:batchGenerateContent", r),
   a = n.batch.inputConfig.requests,
   l = a.requests,
   u = [];
  for (const h of l) {
   const p = Object.assign({}, h);
   if (p.systemInstruction) {
    const m = p.systemInstruction;
    delete p.systemInstruction;
    const v = p.request;
    (v.systemInstruction = m), (p.request = v);
   }
   u.push(p);
  }
  return (a.requests = u), delete n.config, delete n._url, delete n._query, { path: i, body: n };
 }
 getGcsUri(e) {
  if (typeof e == "string") return e.startsWith("gs://") ? e : void 0;
  if (!Array.isArray(e) && e.gcsUri && e.gcsUri.length > 0) return e.gcsUri[0];
 }
 getBigqueryUri(e) {
  if (typeof e == "string") return e.startsWith("bq://") ? e : void 0;
  if (!Array.isArray(e)) return e.bigqueryUri;
 }
 formatDestination(e, n) {
  const r = n ? Object.assign({}, n) : {},
   i = Date.now().toString();
  if ((r.displayName || (r.displayName = `genaiBatchJob_${i}`), r.dest === void 0)) {
   const o = this.getGcsUri(e),
    s = this.getBigqueryUri(e);
   if (o) o.endsWith(".jsonl") ? (r.dest = `${o.slice(0, -6)}/dest`) : (r.dest = `${o}_dest_${i}`);
   else if (s) r.dest = `${s}_dest_${i}`;
   else throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
  }
  return r;
 }
 async createInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = R5(this.apiClient, e);
   return (
    (a = K("batchPredictionJobs", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => Mm(h))
   );
  } else {
   const u = qT(this.apiClient, e);
   return (
    (a = K("{model}:batchGenerateContent", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => Pc(h))
   );
  }
 }
 async createEmbeddingsInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = k5(this.apiClient, e);
   return (
    (o = K("{model}:asyncBatchEmbedContent", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => Pc(l))
   );
  }
 }
 async get(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = q5(this.apiClient, e);
   return (
    (a = K("batchPredictionJobs/{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => Mm(h))
   );
  } else {
   const u = H5(this.apiClient, e);
   return (
    (a = K("batches/{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => Pc(h))
   );
  }
 }
 async cancel(e) {
  var n, r, i, o;
  let s = "",
   a = {};
  if (this.apiClient.isVertexAI()) {
   const l = T5(this.apiClient, e);
   (s = K("batchPredictionJobs/{name}:cancel", l._url)),
    (a = l._query),
    delete l._url,
    delete l._query,
    await this.apiClient.request({
     path: s,
     queryParams: a,
     body: JSON.stringify(l),
     httpMethod: "POST",
     httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
     abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
    });
  } else {
   const l = E5(this.apiClient, e);
   (s = K("batches/{name}:cancel", l._url)),
    (a = l._query),
    delete l._url,
    delete l._query,
    await this.apiClient.request({
     path: s,
     queryParams: a,
     body: JSON.stringify(l),
     httpMethod: "POST",
     httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
     abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
    });
  }
 }
 async listInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = j5(e);
   return (
    (a = K("batchPredictionJobs", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = e3(h),
      m = new FT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = X5(e);
   return (
    (a = K("batches", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = Z5(h),
      m = new FT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async delete(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = N5(this.apiClient, e);
   return (
    (a = K("batchPredictionJobs/{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "DELETE",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => M5(h))
   );
  } else {
   const u = b5(this.apiClient, e);
   return (
    (a = K("batches/{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "DELETE",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => x5(h))
   );
  }
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function s3(t) {
 const e = {},
  n = c(t, ["data"]);
 if ((n != null && d(e, ["data"], n), c(t, ["displayName"]) !== void 0))
  throw new Error("displayName parameter is not supported in Gemini API.");
 const r = c(t, ["mimeType"]);
 return r != null && d(e, ["mimeType"], r), e;
}
function GT(t) {
 const e = {},
  n = c(t, ["parts"]);
 if (n != null) {
  let i = n;
  Array.isArray(i) && (i = i.map((o) => k3(o))), d(e, ["parts"], i);
 }
 const r = c(t, ["role"]);
 return r != null && d(e, ["role"], r), e;
}
function a3(t, e) {
 const n = {},
  r = c(t, ["ttl"]);
 e !== void 0 && r != null && d(e, ["ttl"], r);
 const i = c(t, ["expireTime"]);
 e !== void 0 && i != null && d(e, ["expireTime"], i);
 const o = c(t, ["displayName"]);
 e !== void 0 && o != null && d(e, ["displayName"], o);
 const s = c(t, ["contents"]);
 if (e !== void 0 && s != null) {
  let h = Sn(s);
  Array.isArray(h) && (h = h.map((p) => GT(p))), d(e, ["contents"], h);
 }
 const a = c(t, ["systemInstruction"]);
 e !== void 0 && a != null && d(e, ["systemInstruction"], GT(bt(a)));
 const l = c(t, ["tools"]);
 if (e !== void 0 && l != null) {
  let h = l;
  Array.isArray(h) && (h = h.map((p) => N3(p))), d(e, ["tools"], h);
 }
 const u = c(t, ["toolConfig"]);
 if ((e !== void 0 && u != null && d(e, ["toolConfig"], b3(u)), c(t, ["kmsKeyName"]) !== void 0))
  throw new Error("kmsKeyName parameter is not supported in Gemini API.");
 return n;
}
function l3(t, e) {
 const n = {},
  r = c(t, ["ttl"]);
 e !== void 0 && r != null && d(e, ["ttl"], r);
 const i = c(t, ["expireTime"]);
 e !== void 0 && i != null && d(e, ["expireTime"], i);
 const o = c(t, ["displayName"]);
 e !== void 0 && o != null && d(e, ["displayName"], o);
 const s = c(t, ["contents"]);
 if (e !== void 0 && s != null) {
  let p = Sn(s);
  Array.isArray(p) && (p = p.map((m) => m)), d(e, ["contents"], p);
 }
 const a = c(t, ["systemInstruction"]);
 e !== void 0 && a != null && d(e, ["systemInstruction"], bt(a));
 const l = c(t, ["tools"]);
 if (e !== void 0 && l != null) {
  let p = l;
  Array.isArray(p) && (p = p.map((m) => x3(m))), d(e, ["tools"], p);
 }
 const u = c(t, ["toolConfig"]);
 e !== void 0 && u != null && d(e, ["toolConfig"], u);
 const h = c(t, ["kmsKeyName"]);
 return e !== void 0 && h != null && d(e, ["encryption_spec", "kmsKeyName"], h), n;
}
function u3(t, e) {
 const n = {},
  r = c(e, ["model"]);
 r != null && d(n, ["model"], Mk(t, r));
 const i = c(e, ["config"]);
 return i != null && a3(i, n), n;
}
function c3(t, e) {
 const n = {},
  r = c(e, ["model"]);
 r != null && d(n, ["model"], Mk(t, r));
 const i = c(e, ["config"]);
 return i != null && l3(i, n), n;
}
function d3(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], Br(t, r)), n;
}
function f3(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], Br(t, r)), n;
}
function h3(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 return n != null && d(e, ["sdkHttpResponse"], n), e;
}
function p3(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 return n != null && d(e, ["sdkHttpResponse"], n), e;
}
function m3(t) {
 const e = {};
 if (c(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
 const n = c(t, ["fileUri"]);
 n != null && d(e, ["fileUri"], n);
 const r = c(t, ["mimeType"]);
 return r != null && d(e, ["mimeType"], r), e;
}
function g3(t) {
 const e = {},
  n = c(t, ["id"]);
 n != null && d(e, ["id"], n);
 const r = c(t, ["args"]);
 r != null && d(e, ["args"], r);
 const i = c(t, ["name"]);
 if ((i != null && d(e, ["name"], i), c(t, ["partialArgs"]) !== void 0))
  throw new Error("partialArgs parameter is not supported in Gemini API.");
 if (c(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
 return e;
}
function y3(t) {
 const e = {},
  n = c(t, ["allowedFunctionNames"]);
 n != null && d(e, ["allowedFunctionNames"], n);
 const r = c(t, ["mode"]);
 if ((r != null && d(e, ["mode"], r), c(t, ["streamFunctionCallArguments"]) !== void 0))
  throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
 return e;
}
function v3(t) {
 const e = {},
  n = c(t, ["description"]);
 n != null && d(e, ["description"], n);
 const r = c(t, ["name"]);
 r != null && d(e, ["name"], r);
 const i = c(t, ["parameters"]);
 i != null && d(e, ["parameters"], i);
 const o = c(t, ["parametersJsonSchema"]);
 o != null && d(e, ["parametersJsonSchema"], o);
 const s = c(t, ["response"]);
 s != null && d(e, ["response"], s);
 const a = c(t, ["responseJsonSchema"]);
 if ((a != null && d(e, ["responseJsonSchema"], a), c(t, ["behavior"]) !== void 0))
  throw new Error("behavior parameter is not supported in Vertex AI.");
 return e;
}
function _3(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], Br(t, r)), n;
}
function w3(t, e) {
 const n = {},
  r = c(e, ["name"]);
 return r != null && d(n, ["_url", "name"], Br(t, r)), n;
}
function E3(t) {
 const e = {};
 if (c(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
 const n = c(t, ["enableWidget"]);
 return n != null && d(e, ["enableWidget"], n), e;
}
function T3(t) {
 const e = {};
 if (c(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
 if (c(t, ["blockingConfidence"]) !== void 0)
  throw new Error("blockingConfidence parameter is not supported in Gemini API.");
 const n = c(t, ["timeRangeFilter"]);
 return n != null && d(e, ["timeRangeFilter"], n), e;
}
function I3(t, e) {
 const n = {},
  r = c(t, ["pageSize"]);
 e !== void 0 && r != null && d(e, ["_query", "pageSize"], r);
 const i = c(t, ["pageToken"]);
 return e !== void 0 && i != null && d(e, ["_query", "pageToken"], i), n;
}
function S3(t, e) {
 const n = {},
  r = c(t, ["pageSize"]);
 e !== void 0 && r != null && d(e, ["_query", "pageSize"], r);
 const i = c(t, ["pageToken"]);
 return e !== void 0 && i != null && d(e, ["_query", "pageToken"], i), n;
}
function A3(t) {
 const e = {},
  n = c(t, ["config"]);
 return n != null && I3(n, e), e;
}
function C3(t) {
 const e = {},
  n = c(t, ["config"]);
 return n != null && S3(n, e), e;
}
function R3(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["nextPageToken"]);
 r != null && d(e, ["nextPageToken"], r);
 const i = c(t, ["cachedContents"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => s)), d(e, ["cachedContents"], o);
 }
 return e;
}
function P3(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["nextPageToken"]);
 r != null && d(e, ["nextPageToken"], r);
 const i = c(t, ["cachedContents"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => s)), d(e, ["cachedContents"], o);
 }
 return e;
}
function k3(t) {
 const e = {},
  n = c(t, ["mediaResolution"]);
 n != null && d(e, ["mediaResolution"], n);
 const r = c(t, ["codeExecutionResult"]);
 r != null && d(e, ["codeExecutionResult"], r);
 const i = c(t, ["executableCode"]);
 i != null && d(e, ["executableCode"], i);
 const o = c(t, ["fileData"]);
 o != null && d(e, ["fileData"], m3(o));
 const s = c(t, ["functionCall"]);
 s != null && d(e, ["functionCall"], g3(s));
 const a = c(t, ["functionResponse"]);
 a != null && d(e, ["functionResponse"], a);
 const l = c(t, ["inlineData"]);
 l != null && d(e, ["inlineData"], s3(l));
 const u = c(t, ["text"]);
 u != null && d(e, ["text"], u);
 const h = c(t, ["thought"]);
 h != null && d(e, ["thought"], h);
 const p = c(t, ["thoughtSignature"]);
 p != null && d(e, ["thoughtSignature"], p);
 const m = c(t, ["videoMetadata"]);
 return m != null && d(e, ["videoMetadata"], m), e;
}
function b3(t) {
 const e = {},
  n = c(t, ["retrievalConfig"]);
 n != null && d(e, ["retrievalConfig"], n);
 const r = c(t, ["functionCallingConfig"]);
 return r != null && d(e, ["functionCallingConfig"], y3(r)), e;
}
function N3(t) {
 const e = {};
 if (c(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
 const n = c(t, ["computerUse"]);
 n != null && d(e, ["computerUse"], n);
 const r = c(t, ["fileSearch"]);
 r != null && d(e, ["fileSearch"], r);
 const i = c(t, ["codeExecution"]);
 if ((i != null && d(e, ["codeExecution"], i), c(t, ["enterpriseWebSearch"]) !== void 0))
  throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
 const o = c(t, ["functionDeclarations"]);
 if (o != null) {
  let h = o;
  Array.isArray(h) && (h = h.map((p) => p)), d(e, ["functionDeclarations"], h);
 }
 const s = c(t, ["googleMaps"]);
 s != null && d(e, ["googleMaps"], E3(s));
 const a = c(t, ["googleSearch"]);
 a != null && d(e, ["googleSearch"], T3(a));
 const l = c(t, ["googleSearchRetrieval"]);
 l != null && d(e, ["googleSearchRetrieval"], l);
 const u = c(t, ["urlContext"]);
 return u != null && d(e, ["urlContext"], u), e;
}
function x3(t) {
 const e = {},
  n = c(t, ["retrieval"]);
 n != null && d(e, ["retrieval"], n);
 const r = c(t, ["computerUse"]);
 if ((r != null && d(e, ["computerUse"], r), c(t, ["fileSearch"]) !== void 0))
  throw new Error("fileSearch parameter is not supported in Vertex AI.");
 const i = c(t, ["codeExecution"]);
 i != null && d(e, ["codeExecution"], i);
 const o = c(t, ["enterpriseWebSearch"]);
 o != null && d(e, ["enterpriseWebSearch"], o);
 const s = c(t, ["functionDeclarations"]);
 if (s != null) {
  let p = s;
  Array.isArray(p) && (p = p.map((m) => v3(m))), d(e, ["functionDeclarations"], p);
 }
 const a = c(t, ["googleMaps"]);
 a != null && d(e, ["googleMaps"], a);
 const l = c(t, ["googleSearch"]);
 l != null && d(e, ["googleSearch"], l);
 const u = c(t, ["googleSearchRetrieval"]);
 u != null && d(e, ["googleSearchRetrieval"], u);
 const h = c(t, ["urlContext"]);
 return h != null && d(e, ["urlContext"], h), e;
}
function M3(t, e) {
 const n = {},
  r = c(t, ["ttl"]);
 e !== void 0 && r != null && d(e, ["ttl"], r);
 const i = c(t, ["expireTime"]);
 return e !== void 0 && i != null && d(e, ["expireTime"], i), n;
}
function D3(t, e) {
 const n = {},
  r = c(t, ["ttl"]);
 e !== void 0 && r != null && d(e, ["ttl"], r);
 const i = c(t, ["expireTime"]);
 return e !== void 0 && i != null && d(e, ["expireTime"], i), n;
}
function L3(t, e) {
 const n = {},
  r = c(e, ["name"]);
 r != null && d(n, ["_url", "name"], Br(t, r));
 const i = c(e, ["config"]);
 return i != null && M3(i, n), n;
}
function V3(t, e) {
 const n = {},
  r = c(e, ["name"]);
 r != null && d(n, ["_url", "name"], Br(t, r));
 const i = c(e, ["config"]);
 return i != null && D3(i, n), n;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class U3 extends Fr {
 constructor(e) {
  super(),
   (this.apiClient = e),
   (this.list = async (n = {}) =>
    new Mo(Dr.PAGED_ITEM_CACHED_CONTENTS, (r) => this.listInternal(r), await this.listInternal(n), n));
 }
 async create(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = c3(this.apiClient, e);
   return (
    (a = K("cachedContents", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => h)
   );
  } else {
   const u = u3(this.apiClient, e);
   return (
    (a = K("cachedContents", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => h)
   );
  }
 }
 async get(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = w3(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => h)
   );
  } else {
   const u = _3(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => h)
   );
  }
 }
 async delete(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = f3(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "DELETE",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = p3(h),
      m = new UT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = d3(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "DELETE",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = h3(h),
      m = new UT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async update(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = V3(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "PATCH",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => h)
   );
  } else {
   const u = L3(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "PATCH",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => h)
   );
  }
 }
 async listInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = C3(e);
   return (
    (a = K("cachedContents", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = P3(h),
      m = new OT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = A3(e);
   return (
    (a = K("cachedContents", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = R3(h),
      m = new OT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
}
function bd(t, e) {
 var n = {};
 for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
 if (t != null && typeof Object.getOwnPropertySymbols == "function")
  for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
   e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
 return n;
}
function zT(t) {
 var e = typeof Symbol == "function" && Symbol.iterator,
  n = e && t[e],
  r = 0;
 if (n) return n.call(t);
 if (t && typeof t.length == "number")
  return {
   next: function () {
    return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
   },
  };
 throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function ie(t) {
 return this instanceof ie ? ((this.v = t), this) : new ie(t);
}
function Fn(t, e, n) {
 if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
 var r = n.apply(t, e || []),
  i,
  o = [];
 return (
  (i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype)),
  a("next"),
  a("throw"),
  a("return", s),
  (i[Symbol.asyncIterator] = function () {
   return this;
  }),
  i
 );
 function s(v) {
  return function (w) {
   return Promise.resolve(w).then(v, p);
  };
 }
 function a(v, w) {
  r[v] &&
   ((i[v] = function (C) {
    return new Promise(function (A, T) {
     o.push([v, C, A, T]) > 1 || l(v, C);
    });
   }),
   w && (i[v] = w(i[v])));
 }
 function l(v, w) {
  try {
   u(r[v](w));
  } catch (C) {
   m(o[0][3], C);
  }
 }
 function u(v) {
  v.value instanceof ie ? Promise.resolve(v.value.v).then(h, p) : m(o[0][2], v);
 }
 function h(v) {
  l("next", v);
 }
 function p(v) {
  l("throw", v);
 }
 function m(v, w) {
  v(w), o.shift(), o.length && l(o[0][0], o[0][1]);
 }
}
function Bn(t) {
 if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
 var e = t[Symbol.asyncIterator],
  n;
 return e
  ? e.call(t)
  : ((t = typeof zT == "function" ? zT(t) : t[Symbol.iterator]()),
    (n = {}),
    r("next"),
    r("throw"),
    r("return"),
    (n[Symbol.asyncIterator] = function () {
     return this;
    }),
    n);
 function r(o) {
  n[o] =
   t[o] &&
   function (s) {
    return new Promise(function (a, l) {
     (s = t[o](s)), i(a, l, s.done, s.value);
    });
   };
 }
 function i(o, s, a, l) {
  Promise.resolve(l).then(function (u) {
   o({ value: u, done: a });
  }, s);
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function O3(t) {
 var e;
 if (t.candidates == null || t.candidates.length === 0) return !1;
 const n = (e = t.candidates[0]) === null || e === void 0 ? void 0 : e.content;
 return n === void 0 ? !1 : Wk(n);
}
function Wk(t) {
 if (t.parts === void 0 || t.parts.length === 0) return !1;
 for (const e of t.parts) if (e === void 0 || Object.keys(e).length === 0) return !1;
 return !0;
}
function F3(t) {
 if (t.length !== 0) {
  for (const e of t)
   if (e.role !== "user" && e.role !== "model") throw new Error(`Role must be user or model, but got ${e.role}.`);
 }
}
function WT(t) {
 if (t === void 0 || t.length === 0) return [];
 const e = [],
  n = t.length;
 let r = 0;
 for (; r < n; )
  if (t[r].role === "user") e.push(t[r]), r++;
  else {
   const i = [];
   let o = !0;
   for (; r < n && t[r].role === "model"; ) i.push(t[r]), o && !Wk(t[r]) && (o = !1), r++;
   o ? e.push(...i) : e.pop();
  }
 return e;
}
class B3 {
 constructor(e, n) {
  (this.modelsModule = e), (this.apiClient = n);
 }
 create(e) {
  return new $3(this.apiClient, this.modelsModule, e.model, e.config, structuredClone(e.history));
 }
}
class $3 {
 constructor(e, n, r, i = {}, o = []) {
  (this.apiClient = e),
   (this.modelsModule = n),
   (this.model = r),
   (this.config = i),
   (this.history = o),
   (this.sendPromise = Promise.resolve()),
   F3(o);
 }
 async sendMessage(e) {
  var n;
  await this.sendPromise;
  const r = bt(e.message),
   i = this.modelsModule.generateContent({
    model: this.model,
    contents: this.getHistory(!0).concat(r),
    config: (n = e.config) !== null && n !== void 0 ? n : this.config,
   });
  return (
   (this.sendPromise = (async () => {
    var o, s, a;
    const l = await i,
     u =
      (s = (o = l.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0 ? void 0 : s.content,
     h = l.automaticFunctionCallingHistory,
     p = this.getHistory(!0).length;
    let m = [];
    h != null && (m = (a = h.slice(p)) !== null && a !== void 0 ? a : []);
    const v = u ? [u] : [];
    this.recordHistory(r, v, m);
   })()),
   await this.sendPromise.catch(() => {
    this.sendPromise = Promise.resolve();
   }),
   i
  );
 }
 async sendMessageStream(e) {
  var n;
  await this.sendPromise;
  const r = bt(e.message),
   i = this.modelsModule.generateContentStream({
    model: this.model,
    contents: this.getHistory(!0).concat(r),
    config: (n = e.config) !== null && n !== void 0 ? n : this.config,
   });
  this.sendPromise = i.then(() => {}).catch(() => {});
  const o = await i;
  return this.processStreamResponse(o, r);
 }
 getHistory(e = !1) {
  const n = e ? WT(this.history) : this.history;
  return structuredClone(n);
 }
 processStreamResponse(e, n) {
  return Fn(this, arguments, function* () {
   var i, o, s, a, l, u;
   const h = [];
   try {
    for (var p = !0, m = Bn(e), v; (v = yield ie(m.next())), (i = v.done), !i; p = !0) {
     (a = v.value), (p = !1);
     const w = a;
     if (O3(w)) {
      const C =
       (u = (l = w.candidates) === null || l === void 0 ? void 0 : l[0]) === null || u === void 0 ? void 0 : u.content;
      C !== void 0 && h.push(C);
     }
     yield yield ie(w);
    }
   } catch (w) {
    o = { error: w };
   } finally {
    try {
     !p && !i && (s = m.return) && (yield ie(s.call(m)));
    } finally {
     if (o) throw o.error;
    }
   }
   this.recordHistory(n, h);
  });
 }
 recordHistory(e, n, r) {
  let i = [];
  n.length > 0 && n.every((o) => o.role !== void 0) ? (i = n) : i.push({ role: "model", parts: [] }),
   r && r.length > 0 ? this.history.push(...WT(r)) : this.history.push(e),
   this.history.push(...i);
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class Nl extends Error {
 constructor(e) {
  super(e.message), (this.name = "ApiError"), (this.status = e.status), Object.setPrototypeOf(this, Nl.prototype);
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function H3(t) {
 const e = {},
  n = c(t, ["file"]);
 return n != null && d(e, ["file"], n), e;
}
function q3(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 return n != null && d(e, ["sdkHttpResponse"], n), e;
}
function G3(t) {
 const e = {},
  n = c(t, ["name"]);
 return n != null && d(e, ["_url", "file"], Fk(n)), e;
}
function z3(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 return n != null && d(e, ["sdkHttpResponse"], n), e;
}
function W3(t) {
 const e = {},
  n = c(t, ["name"]);
 return n != null && d(e, ["_url", "file"], Fk(n)), e;
}
function K3(t) {
 const e = {},
  n = c(t, ["uris"]);
 return n != null && d(e, ["uris"], n), e;
}
function J3(t, e) {
 const n = {},
  r = c(t, ["pageSize"]);
 e !== void 0 && r != null && d(e, ["_query", "pageSize"], r);
 const i = c(t, ["pageToken"]);
 return e !== void 0 && i != null && d(e, ["_query", "pageToken"], i), n;
}
function Y3(t) {
 const e = {},
  n = c(t, ["config"]);
 return n != null && J3(n, e), e;
}
function Q3(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["nextPageToken"]);
 r != null && d(e, ["nextPageToken"], r);
 const i = c(t, ["files"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => s)), d(e, ["files"], o);
 }
 return e;
}
function X3(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["files"]);
 if (r != null) {
  let i = r;
  Array.isArray(i) && (i = i.map((o) => o)), d(e, ["files"], i);
 }
 return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class j3 extends Fr {
 constructor(e) {
  super(),
   (this.apiClient = e),
   (this.list = async (n = {}) =>
    new Mo(Dr.PAGED_ITEM_FILES, (r) => this.listInternal(r), await this.listInternal(n), n));
 }
 async upload(e) {
  if (this.apiClient.isVertexAI())
   throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
  return this.apiClient.uploadFile(e.file, e.config).then((n) => n);
 }
 async download(e) {
  await this.apiClient.downloadFile(e);
 }
 async registerFiles(e) {
  throw new Error("registerFiles is only supported in Node.js environments.");
 }
 async _registerFiles(e) {
  return this.registerFilesInternal(e);
 }
 async listInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = Y3(e);
   return (
    (o = K("files", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) =>
      l.json().then((u) => {
       const h = u;
       return (h.sdkHttpResponse = { headers: l.headers }), h;
      })
     )),
    i.then((l) => {
     const u = Q3(l),
      h = new ZG();
     return Object.assign(h, u), h;
    })
   );
  }
 }
 async createInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = H3(e);
   return (
    (o = K("upload/v1beta/files", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => {
     const u = q3(l),
      h = new e5();
     return Object.assign(h, u), h;
    })
   );
  }
 }
 async get(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = W3(e);
   return (
    (o = K("files/{file}", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => l)
   );
  }
 }
 async delete(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = G3(e);
   return (
    (o = K("files/{file}", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "DELETE",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) =>
      l.json().then((u) => {
       const h = u;
       return (h.sdkHttpResponse = { headers: l.headers }), h;
      })
     )),
    i.then((l) => {
     const u = z3(l),
      h = new t5();
     return Object.assign(h, u), h;
    })
   );
  }
 }
 async registerFilesInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = K3(e);
   return (
    (o = K("files:register", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => {
     const u = X3(l),
      h = new n5();
     return Object.assign(h, u), h;
    })
   );
  }
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function kc(t) {
 const e = {},
  n = c(t, ["data"]);
 if ((n != null && d(e, ["data"], n), c(t, ["displayName"]) !== void 0))
  throw new Error("displayName parameter is not supported in Gemini API.");
 const r = c(t, ["mimeType"]);
 return r != null && d(e, ["mimeType"], r), e;
}
function Z3(t) {
 const e = {},
  n = c(t, ["parts"]);
 if (n != null) {
  let i = n;
  Array.isArray(i) && (i = i.map((o) => mz(o))), d(e, ["parts"], i);
 }
 const r = c(t, ["role"]);
 return r != null && d(e, ["role"], r), e;
}
function ez(t) {
 const e = {};
 if (c(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
 const n = c(t, ["fileUri"]);
 n != null && d(e, ["fileUri"], n);
 const r = c(t, ["mimeType"]);
 return r != null && d(e, ["mimeType"], r), e;
}
function tz(t) {
 const e = {},
  n = c(t, ["id"]);
 n != null && d(e, ["id"], n);
 const r = c(t, ["args"]);
 r != null && d(e, ["args"], r);
 const i = c(t, ["name"]);
 if ((i != null && d(e, ["name"], i), c(t, ["partialArgs"]) !== void 0))
  throw new Error("partialArgs parameter is not supported in Gemini API.");
 if (c(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
 return e;
}
function nz(t) {
 const e = {},
  n = c(t, ["description"]);
 n != null && d(e, ["description"], n);
 const r = c(t, ["name"]);
 r != null && d(e, ["name"], r);
 const i = c(t, ["parameters"]);
 i != null && d(e, ["parameters"], i);
 const o = c(t, ["parametersJsonSchema"]);
 o != null && d(e, ["parametersJsonSchema"], o);
 const s = c(t, ["response"]);
 s != null && d(e, ["response"], s);
 const a = c(t, ["responseJsonSchema"]);
 if ((a != null && d(e, ["responseJsonSchema"], a), c(t, ["behavior"]) !== void 0))
  throw new Error("behavior parameter is not supported in Vertex AI.");
 return e;
}
function rz(t) {
 const e = {},
  n = c(t, ["modelSelectionConfig"]);
 n != null && d(e, ["modelConfig"], n);
 const r = c(t, ["responseJsonSchema"]);
 r != null && d(e, ["responseJsonSchema"], r);
 const i = c(t, ["audioTimestamp"]);
 i != null && d(e, ["audioTimestamp"], i);
 const o = c(t, ["candidateCount"]);
 o != null && d(e, ["candidateCount"], o);
 const s = c(t, ["enableAffectiveDialog"]);
 s != null && d(e, ["enableAffectiveDialog"], s);
 const a = c(t, ["frequencyPenalty"]);
 a != null && d(e, ["frequencyPenalty"], a);
 const l = c(t, ["logprobs"]);
 l != null && d(e, ["logprobs"], l);
 const u = c(t, ["maxOutputTokens"]);
 u != null && d(e, ["maxOutputTokens"], u);
 const h = c(t, ["mediaResolution"]);
 h != null && d(e, ["mediaResolution"], h);
 const p = c(t, ["presencePenalty"]);
 p != null && d(e, ["presencePenalty"], p);
 const m = c(t, ["responseLogprobs"]);
 m != null && d(e, ["responseLogprobs"], m);
 const v = c(t, ["responseMimeType"]);
 v != null && d(e, ["responseMimeType"], v);
 const w = c(t, ["responseModalities"]);
 w != null && d(e, ["responseModalities"], w);
 const C = c(t, ["responseSchema"]);
 C != null && d(e, ["responseSchema"], C);
 const A = c(t, ["routingConfig"]);
 A != null && d(e, ["routingConfig"], A);
 const T = c(t, ["seed"]);
 T != null && d(e, ["seed"], T);
 const _ = c(t, ["speechConfig"]);
 _ != null && d(e, ["speechConfig"], _);
 const E = c(t, ["stopSequences"]);
 E != null && d(e, ["stopSequences"], E);
 const N = c(t, ["temperature"]);
 N != null && d(e, ["temperature"], N);
 const M = c(t, ["thinkingConfig"]);
 M != null && d(e, ["thinkingConfig"], M);
 const F = c(t, ["topK"]);
 F != null && d(e, ["topK"], F);
 const P = c(t, ["topP"]);
 if ((P != null && d(e, ["topP"], P), c(t, ["enableEnhancedCivicAnswers"]) !== void 0))
  throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
 return e;
}
function iz(t) {
 const e = {};
 if (c(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
 const n = c(t, ["enableWidget"]);
 return n != null && d(e, ["enableWidget"], n), e;
}
function oz(t) {
 const e = {};
 if (c(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
 if (c(t, ["blockingConfidence"]) !== void 0)
  throw new Error("blockingConfidence parameter is not supported in Gemini API.");
 const n = c(t, ["timeRangeFilter"]);
 return n != null && d(e, ["timeRangeFilter"], n), e;
}
function sz(t, e) {
 const n = {},
  r = c(t, ["generationConfig"]);
 e !== void 0 && r != null && d(e, ["setup", "generationConfig"], r);
 const i = c(t, ["responseModalities"]);
 e !== void 0 && i != null && d(e, ["setup", "generationConfig", "responseModalities"], i);
 const o = c(t, ["temperature"]);
 e !== void 0 && o != null && d(e, ["setup", "generationConfig", "temperature"], o);
 const s = c(t, ["topP"]);
 e !== void 0 && s != null && d(e, ["setup", "generationConfig", "topP"], s);
 const a = c(t, ["topK"]);
 e !== void 0 && a != null && d(e, ["setup", "generationConfig", "topK"], a);
 const l = c(t, ["maxOutputTokens"]);
 e !== void 0 && l != null && d(e, ["setup", "generationConfig", "maxOutputTokens"], l);
 const u = c(t, ["mediaResolution"]);
 e !== void 0 && u != null && d(e, ["setup", "generationConfig", "mediaResolution"], u);
 const h = c(t, ["seed"]);
 e !== void 0 && h != null && d(e, ["setup", "generationConfig", "seed"], h);
 const p = c(t, ["speechConfig"]);
 e !== void 0 && p != null && d(e, ["setup", "generationConfig", "speechConfig"], wv(p));
 const m = c(t, ["thinkingConfig"]);
 e !== void 0 && m != null && d(e, ["setup", "generationConfig", "thinkingConfig"], m);
 const v = c(t, ["enableAffectiveDialog"]);
 e !== void 0 && v != null && d(e, ["setup", "generationConfig", "enableAffectiveDialog"], v);
 const w = c(t, ["systemInstruction"]);
 e !== void 0 && w != null && d(e, ["setup", "systemInstruction"], Z3(bt(w)));
 const C = c(t, ["tools"]);
 if (e !== void 0 && C != null) {
  let F = Xs(C);
  Array.isArray(F) && (F = F.map((P) => yz(Qs(P)))), d(e, ["setup", "tools"], F);
 }
 const A = c(t, ["sessionResumption"]);
 e !== void 0 && A != null && d(e, ["setup", "sessionResumption"], gz(A));
 const T = c(t, ["inputAudioTranscription"]);
 e !== void 0 && T != null && d(e, ["setup", "inputAudioTranscription"], T);
 const _ = c(t, ["outputAudioTranscription"]);
 e !== void 0 && _ != null && d(e, ["setup", "outputAudioTranscription"], _);
 const E = c(t, ["realtimeInputConfig"]);
 e !== void 0 && E != null && d(e, ["setup", "realtimeInputConfig"], E);
 const N = c(t, ["contextWindowCompression"]);
 e !== void 0 && N != null && d(e, ["setup", "contextWindowCompression"], N);
 const M = c(t, ["proactivity"]);
 if ((e !== void 0 && M != null && d(e, ["setup", "proactivity"], M), c(t, ["explicitVadSignal"]) !== void 0))
  throw new Error("explicitVadSignal parameter is not supported in Gemini API.");
 return n;
}
function az(t, e) {
 const n = {},
  r = c(t, ["generationConfig"]);
 e !== void 0 && r != null && d(e, ["setup", "generationConfig"], rz(r));
 const i = c(t, ["responseModalities"]);
 e !== void 0 && i != null && d(e, ["setup", "generationConfig", "responseModalities"], i);
 const o = c(t, ["temperature"]);
 e !== void 0 && o != null && d(e, ["setup", "generationConfig", "temperature"], o);
 const s = c(t, ["topP"]);
 e !== void 0 && s != null && d(e, ["setup", "generationConfig", "topP"], s);
 const a = c(t, ["topK"]);
 e !== void 0 && a != null && d(e, ["setup", "generationConfig", "topK"], a);
 const l = c(t, ["maxOutputTokens"]);
 e !== void 0 && l != null && d(e, ["setup", "generationConfig", "maxOutputTokens"], l);
 const u = c(t, ["mediaResolution"]);
 e !== void 0 && u != null && d(e, ["setup", "generationConfig", "mediaResolution"], u);
 const h = c(t, ["seed"]);
 e !== void 0 && h != null && d(e, ["setup", "generationConfig", "seed"], h);
 const p = c(t, ["speechConfig"]);
 e !== void 0 && p != null && d(e, ["setup", "generationConfig", "speechConfig"], wv(p));
 const m = c(t, ["thinkingConfig"]);
 e !== void 0 && m != null && d(e, ["setup", "generationConfig", "thinkingConfig"], m);
 const v = c(t, ["enableAffectiveDialog"]);
 e !== void 0 && v != null && d(e, ["setup", "generationConfig", "enableAffectiveDialog"], v);
 const w = c(t, ["systemInstruction"]);
 e !== void 0 && w != null && d(e, ["setup", "systemInstruction"], bt(w));
 const C = c(t, ["tools"]);
 if (e !== void 0 && C != null) {
  let P = Xs(C);
  Array.isArray(P) && (P = P.map((I) => vz(Qs(I)))), d(e, ["setup", "tools"], P);
 }
 const A = c(t, ["sessionResumption"]);
 e !== void 0 && A != null && d(e, ["setup", "sessionResumption"], A);
 const T = c(t, ["inputAudioTranscription"]);
 e !== void 0 && T != null && d(e, ["setup", "inputAudioTranscription"], T);
 const _ = c(t, ["outputAudioTranscription"]);
 e !== void 0 && _ != null && d(e, ["setup", "outputAudioTranscription"], _);
 const E = c(t, ["realtimeInputConfig"]);
 e !== void 0 && E != null && d(e, ["setup", "realtimeInputConfig"], E);
 const N = c(t, ["contextWindowCompression"]);
 e !== void 0 && N != null && d(e, ["setup", "contextWindowCompression"], N);
 const M = c(t, ["proactivity"]);
 e !== void 0 && M != null && d(e, ["setup", "proactivity"], M);
 const F = c(t, ["explicitVadSignal"]);
 return e !== void 0 && F != null && d(e, ["setup", "explicitVadSignal"], F), n;
}
function lz(t, e) {
 const n = {},
  r = c(e, ["model"]);
 r != null && d(n, ["setup", "model"], ye(t, r));
 const i = c(e, ["config"]);
 return i != null && d(n, ["config"], sz(i, n)), n;
}
function uz(t, e) {
 const n = {},
  r = c(e, ["model"]);
 r != null && d(n, ["setup", "model"], ye(t, r));
 const i = c(e, ["config"]);
 return i != null && d(n, ["config"], az(i, n)), n;
}
function cz(t) {
 const e = {},
  n = c(t, ["musicGenerationConfig"]);
 return n != null && d(e, ["musicGenerationConfig"], n), e;
}
function dz(t) {
 const e = {},
  n = c(t, ["weightedPrompts"]);
 if (n != null) {
  let r = n;
  Array.isArray(r) && (r = r.map((i) => i)), d(e, ["weightedPrompts"], r);
 }
 return e;
}
function fz(t) {
 const e = {},
  n = c(t, ["media"]);
 if (n != null) {
  let u = Dk(n);
  Array.isArray(u) && (u = u.map((h) => kc(h))), d(e, ["mediaChunks"], u);
 }
 const r = c(t, ["audio"]);
 r != null && d(e, ["audio"], kc(Vk(r)));
 const i = c(t, ["audioStreamEnd"]);
 i != null && d(e, ["audioStreamEnd"], i);
 const o = c(t, ["video"]);
 o != null && d(e, ["video"], kc(Lk(o)));
 const s = c(t, ["text"]);
 s != null && d(e, ["text"], s);
 const a = c(t, ["activityStart"]);
 a != null && d(e, ["activityStart"], a);
 const l = c(t, ["activityEnd"]);
 return l != null && d(e, ["activityEnd"], l), e;
}
function hz(t) {
 const e = {},
  n = c(t, ["media"]);
 if (n != null) {
  let u = Dk(n);
  Array.isArray(u) && (u = u.map((h) => h)), d(e, ["mediaChunks"], u);
 }
 const r = c(t, ["audio"]);
 r != null && d(e, ["audio"], Vk(r));
 const i = c(t, ["audioStreamEnd"]);
 i != null && d(e, ["audioStreamEnd"], i);
 const o = c(t, ["video"]);
 o != null && d(e, ["video"], Lk(o));
 const s = c(t, ["text"]);
 s != null && d(e, ["text"], s);
 const a = c(t, ["activityStart"]);
 a != null && d(e, ["activityStart"], a);
 const l = c(t, ["activityEnd"]);
 return l != null && d(e, ["activityEnd"], l), e;
}
function pz(t) {
 const e = {},
  n = c(t, ["setupComplete"]);
 n != null && d(e, ["setupComplete"], n);
 const r = c(t, ["serverContent"]);
 r != null && d(e, ["serverContent"], r);
 const i = c(t, ["toolCall"]);
 i != null && d(e, ["toolCall"], i);
 const o = c(t, ["toolCallCancellation"]);
 o != null && d(e, ["toolCallCancellation"], o);
 const s = c(t, ["usageMetadata"]);
 s != null && d(e, ["usageMetadata"], _z(s));
 const a = c(t, ["goAway"]);
 a != null && d(e, ["goAway"], a);
 const l = c(t, ["sessionResumptionUpdate"]);
 l != null && d(e, ["sessionResumptionUpdate"], l);
 const u = c(t, ["voiceActivityDetectionSignal"]);
 u != null && d(e, ["voiceActivityDetectionSignal"], u);
 const h = c(t, ["voiceActivity"]);
 return h != null && d(e, ["voiceActivity"], wz(h)), e;
}
function mz(t) {
 const e = {},
  n = c(t, ["mediaResolution"]);
 n != null && d(e, ["mediaResolution"], n);
 const r = c(t, ["codeExecutionResult"]);
 r != null && d(e, ["codeExecutionResult"], r);
 const i = c(t, ["executableCode"]);
 i != null && d(e, ["executableCode"], i);
 const o = c(t, ["fileData"]);
 o != null && d(e, ["fileData"], ez(o));
 const s = c(t, ["functionCall"]);
 s != null && d(e, ["functionCall"], tz(s));
 const a = c(t, ["functionResponse"]);
 a != null && d(e, ["functionResponse"], a);
 const l = c(t, ["inlineData"]);
 l != null && d(e, ["inlineData"], kc(l));
 const u = c(t, ["text"]);
 u != null && d(e, ["text"], u);
 const h = c(t, ["thought"]);
 h != null && d(e, ["thought"], h);
 const p = c(t, ["thoughtSignature"]);
 p != null && d(e, ["thoughtSignature"], p);
 const m = c(t, ["videoMetadata"]);
 return m != null && d(e, ["videoMetadata"], m), e;
}
function gz(t) {
 const e = {},
  n = c(t, ["handle"]);
 if ((n != null && d(e, ["handle"], n), c(t, ["transparent"]) !== void 0))
  throw new Error("transparent parameter is not supported in Gemini API.");
 return e;
}
function yz(t) {
 const e = {};
 if (c(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
 const n = c(t, ["computerUse"]);
 n != null && d(e, ["computerUse"], n);
 const r = c(t, ["fileSearch"]);
 r != null && d(e, ["fileSearch"], r);
 const i = c(t, ["codeExecution"]);
 if ((i != null && d(e, ["codeExecution"], i), c(t, ["enterpriseWebSearch"]) !== void 0))
  throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
 const o = c(t, ["functionDeclarations"]);
 if (o != null) {
  let h = o;
  Array.isArray(h) && (h = h.map((p) => p)), d(e, ["functionDeclarations"], h);
 }
 const s = c(t, ["googleMaps"]);
 s != null && d(e, ["googleMaps"], iz(s));
 const a = c(t, ["googleSearch"]);
 a != null && d(e, ["googleSearch"], oz(a));
 const l = c(t, ["googleSearchRetrieval"]);
 l != null && d(e, ["googleSearchRetrieval"], l);
 const u = c(t, ["urlContext"]);
 return u != null && d(e, ["urlContext"], u), e;
}
function vz(t) {
 const e = {},
  n = c(t, ["retrieval"]);
 n != null && d(e, ["retrieval"], n);
 const r = c(t, ["computerUse"]);
 if ((r != null && d(e, ["computerUse"], r), c(t, ["fileSearch"]) !== void 0))
  throw new Error("fileSearch parameter is not supported in Vertex AI.");
 const i = c(t, ["codeExecution"]);
 i != null && d(e, ["codeExecution"], i);
 const o = c(t, ["enterpriseWebSearch"]);
 o != null && d(e, ["enterpriseWebSearch"], o);
 const s = c(t, ["functionDeclarations"]);
 if (s != null) {
  let p = s;
  Array.isArray(p) && (p = p.map((m) => nz(m))), d(e, ["functionDeclarations"], p);
 }
 const a = c(t, ["googleMaps"]);
 a != null && d(e, ["googleMaps"], a);
 const l = c(t, ["googleSearch"]);
 l != null && d(e, ["googleSearch"], l);
 const u = c(t, ["googleSearchRetrieval"]);
 u != null && d(e, ["googleSearchRetrieval"], u);
 const h = c(t, ["urlContext"]);
 return h != null && d(e, ["urlContext"], h), e;
}
function _z(t) {
 const e = {},
  n = c(t, ["promptTokenCount"]);
 n != null && d(e, ["promptTokenCount"], n);
 const r = c(t, ["cachedContentTokenCount"]);
 r != null && d(e, ["cachedContentTokenCount"], r);
 const i = c(t, ["candidatesTokenCount"]);
 i != null && d(e, ["responseTokenCount"], i);
 const o = c(t, ["toolUsePromptTokenCount"]);
 o != null && d(e, ["toolUsePromptTokenCount"], o);
 const s = c(t, ["thoughtsTokenCount"]);
 s != null && d(e, ["thoughtsTokenCount"], s);
 const a = c(t, ["totalTokenCount"]);
 a != null && d(e, ["totalTokenCount"], a);
 const l = c(t, ["promptTokensDetails"]);
 if (l != null) {
  let v = l;
  Array.isArray(v) && (v = v.map((w) => w)), d(e, ["promptTokensDetails"], v);
 }
 const u = c(t, ["cacheTokensDetails"]);
 if (u != null) {
  let v = u;
  Array.isArray(v) && (v = v.map((w) => w)), d(e, ["cacheTokensDetails"], v);
 }
 const h = c(t, ["candidatesTokensDetails"]);
 if (h != null) {
  let v = h;
  Array.isArray(v) && (v = v.map((w) => w)), d(e, ["responseTokensDetails"], v);
 }
 const p = c(t, ["toolUsePromptTokensDetails"]);
 if (p != null) {
  let v = p;
  Array.isArray(v) && (v = v.map((w) => w)), d(e, ["toolUsePromptTokensDetails"], v);
 }
 const m = c(t, ["trafficType"]);
 return m != null && d(e, ["trafficType"], m), e;
}
function wz(t) {
 const e = {},
  n = c(t, ["type"]);
 return n != null && d(e, ["voiceActivityType"], n), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function Ez(t, e) {
 const n = {},
  r = c(t, ["data"]);
 if ((r != null && d(n, ["data"], r), c(t, ["displayName"]) !== void 0))
  throw new Error("displayName parameter is not supported in Gemini API.");
 const i = c(t, ["mimeType"]);
 return i != null && d(n, ["mimeType"], i), n;
}
function Tz(t, e) {
 const n = {},
  r = c(t, ["content"]);
 r != null && d(n, ["content"], r);
 const i = c(t, ["citationMetadata"]);
 i != null && d(n, ["citationMetadata"], Iz(i));
 const o = c(t, ["tokenCount"]);
 o != null && d(n, ["tokenCount"], o);
 const s = c(t, ["finishReason"]);
 s != null && d(n, ["finishReason"], s);
 const a = c(t, ["avgLogprobs"]);
 a != null && d(n, ["avgLogprobs"], a);
 const l = c(t, ["groundingMetadata"]);
 l != null && d(n, ["groundingMetadata"], l);
 const u = c(t, ["index"]);
 u != null && d(n, ["index"], u);
 const h = c(t, ["logprobsResult"]);
 h != null && d(n, ["logprobsResult"], h);
 const p = c(t, ["safetyRatings"]);
 if (p != null) {
  let v = p;
  Array.isArray(v) && (v = v.map((w) => w)), d(n, ["safetyRatings"], v);
 }
 const m = c(t, ["urlContextMetadata"]);
 return m != null && d(n, ["urlContextMetadata"], m), n;
}
function Iz(t, e) {
 const n = {},
  r = c(t, ["citationSources"]);
 if (r != null) {
  let i = r;
  Array.isArray(i) && (i = i.map((o) => o)), d(n, ["citations"], i);
 }
 return n;
}
function Sz(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["contents"]);
 if (o != null) {
  let s = Sn(o);
  Array.isArray(s) && (s = s.map((a) => a)), d(r, ["contents"], s);
 }
 return r;
}
function Az(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["tokensInfo"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => s)), d(n, ["tokensInfo"], o);
 }
 return n;
}
function Cz(t, e) {
 const n = {},
  r = c(t, ["values"]);
 r != null && d(n, ["values"], r);
 const i = c(t, ["statistics"]);
 return i != null && d(n, ["statistics"], Rz(i)), n;
}
function Rz(t, e) {
 const n = {},
  r = c(t, ["truncated"]);
 r != null && d(n, ["truncated"], r);
 const i = c(t, ["token_count"]);
 return i != null && d(n, ["tokenCount"], i), n;
}
function Pf(t, e) {
 const n = {},
  r = c(t, ["parts"]);
 if (r != null) {
  let o = r;
  Array.isArray(o) && (o = o.map((s) => V6(s))), d(n, ["parts"], o);
 }
 const i = c(t, ["role"]);
 return i != null && d(n, ["role"], i), n;
}
function Pz(t, e) {
 const n = {},
  r = c(t, ["controlType"]);
 r != null && d(n, ["controlType"], r);
 const i = c(t, ["enableControlImageComputation"]);
 return i != null && d(n, ["computeControl"], i), n;
}
function kz(t, e) {
 const n = {};
 if (c(t, ["systemInstruction"]) !== void 0)
  throw new Error("systemInstruction parameter is not supported in Gemini API.");
 if (c(t, ["tools"]) !== void 0) throw new Error("tools parameter is not supported in Gemini API.");
 if (c(t, ["generationConfig"]) !== void 0)
  throw new Error("generationConfig parameter is not supported in Gemini API.");
 return n;
}
function bz(t, e, n) {
 const r = {},
  i = c(t, ["systemInstruction"]);
 e !== void 0 && i != null && d(e, ["systemInstruction"], bt(i));
 const o = c(t, ["tools"]);
 if (e !== void 0 && o != null) {
  let a = o;
  Array.isArray(a) && (a = a.map((l) => Qk(l))), d(e, ["tools"], a);
 }
 const s = c(t, ["generationConfig"]);
 return e !== void 0 && s != null && d(e, ["generationConfig"], E6(s)), r;
}
function Nz(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["contents"]);
 if (o != null) {
  let a = Sn(o);
  Array.isArray(a) && (a = a.map((l) => Pf(l))), d(r, ["contents"], a);
 }
 const s = c(e, ["config"]);
 return s != null && kz(s), r;
}
function xz(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["contents"]);
 if (o != null) {
  let a = Sn(o);
  Array.isArray(a) && (a = a.map((l) => l)), d(r, ["contents"], a);
 }
 const s = c(e, ["config"]);
 return s != null && bz(s, r), r;
}
function Mz(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["totalTokens"]);
 i != null && d(n, ["totalTokens"], i);
 const o = c(t, ["cachedContentTokenCount"]);
 return o != null && d(n, ["cachedContentTokenCount"], o), n;
}
function Dz(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["totalTokens"]);
 return i != null && d(n, ["totalTokens"], i), n;
}
function Lz(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 return i != null && d(r, ["_url", "name"], ye(t, i)), r;
}
function Vz(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 return i != null && d(r, ["_url", "name"], ye(t, i)), r;
}
function Uz(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 return r != null && d(n, ["sdkHttpResponse"], r), n;
}
function Oz(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 return r != null && d(n, ["sdkHttpResponse"], r), n;
}
function Fz(t, e, n) {
 const r = {},
  i = c(t, ["outputGcsUri"]);
 e !== void 0 && i != null && d(e, ["parameters", "storageUri"], i);
 const o = c(t, ["negativePrompt"]);
 e !== void 0 && o != null && d(e, ["parameters", "negativePrompt"], o);
 const s = c(t, ["numberOfImages"]);
 e !== void 0 && s != null && d(e, ["parameters", "sampleCount"], s);
 const a = c(t, ["aspectRatio"]);
 e !== void 0 && a != null && d(e, ["parameters", "aspectRatio"], a);
 const l = c(t, ["guidanceScale"]);
 e !== void 0 && l != null && d(e, ["parameters", "guidanceScale"], l);
 const u = c(t, ["seed"]);
 e !== void 0 && u != null && d(e, ["parameters", "seed"], u);
 const h = c(t, ["safetyFilterLevel"]);
 e !== void 0 && h != null && d(e, ["parameters", "safetySetting"], h);
 const p = c(t, ["personGeneration"]);
 e !== void 0 && p != null && d(e, ["parameters", "personGeneration"], p);
 const m = c(t, ["includeSafetyAttributes"]);
 e !== void 0 && m != null && d(e, ["parameters", "includeSafetyAttributes"], m);
 const v = c(t, ["includeRaiReason"]);
 e !== void 0 && v != null && d(e, ["parameters", "includeRaiReason"], v);
 const w = c(t, ["language"]);
 e !== void 0 && w != null && d(e, ["parameters", "language"], w);
 const C = c(t, ["outputMimeType"]);
 e !== void 0 && C != null && d(e, ["parameters", "outputOptions", "mimeType"], C);
 const A = c(t, ["outputCompressionQuality"]);
 e !== void 0 && A != null && d(e, ["parameters", "outputOptions", "compressionQuality"], A);
 const T = c(t, ["addWatermark"]);
 e !== void 0 && T != null && d(e, ["parameters", "addWatermark"], T);
 const _ = c(t, ["labels"]);
 e !== void 0 && _ != null && d(e, ["labels"], _);
 const E = c(t, ["editMode"]);
 e !== void 0 && E != null && d(e, ["parameters", "editMode"], E);
 const N = c(t, ["baseSteps"]);
 return e !== void 0 && N != null && d(e, ["parameters", "editConfig", "baseSteps"], N), r;
}
function Bz(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["prompt"]);
 o != null && d(r, ["instances[0]", "prompt"], o);
 const s = c(e, ["referenceImages"]);
 if (s != null) {
  let l = s;
  Array.isArray(l) && (l = l.map((u) => H6(u))), d(r, ["instances[0]", "referenceImages"], l);
 }
 const a = c(e, ["config"]);
 return a != null && Fz(a, r), r;
}
function $z(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["predictions"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => kf(s))), d(n, ["generatedImages"], o);
 }
 return n;
}
function Hz(t, e, n) {
 const r = {},
  i = c(t, ["taskType"]);
 e !== void 0 && i != null && d(e, ["requests[]", "taskType"], i);
 const o = c(t, ["title"]);
 e !== void 0 && o != null && d(e, ["requests[]", "title"], o);
 const s = c(t, ["outputDimensionality"]);
 if ((e !== void 0 && s != null && d(e, ["requests[]", "outputDimensionality"], s), c(t, ["mimeType"]) !== void 0))
  throw new Error("mimeType parameter is not supported in Gemini API.");
 if (c(t, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API.");
 return r;
}
function qz(t, e, n) {
 const r = {},
  i = c(t, ["taskType"]);
 e !== void 0 && i != null && d(e, ["instances[]", "task_type"], i);
 const o = c(t, ["title"]);
 e !== void 0 && o != null && d(e, ["instances[]", "title"], o);
 const s = c(t, ["outputDimensionality"]);
 e !== void 0 && s != null && d(e, ["parameters", "outputDimensionality"], s);
 const a = c(t, ["mimeType"]);
 e !== void 0 && a != null && d(e, ["instances[]", "mimeType"], a);
 const l = c(t, ["autoTruncate"]);
 return e !== void 0 && l != null && d(e, ["parameters", "autoTruncate"], l), r;
}
function Gz(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["contents"]);
 if (o != null) {
  let l = yv(t, o);
  Array.isArray(l) && (l = l.map((u) => u)), d(r, ["requests[]", "content"], l);
 }
 const s = c(e, ["config"]);
 s != null && Hz(s, r);
 const a = c(e, ["model"]);
 return a !== void 0 && d(r, ["requests[]", "model"], ye(t, a)), r;
}
function zz(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["contents"]);
 if (o != null) {
  let a = yv(t, o);
  Array.isArray(a) && (a = a.map((l) => l)), d(r, ["instances[]", "content"], a);
 }
 const s = c(e, ["config"]);
 return s != null && qz(s, r), r;
}
function Wz(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["embeddings"]);
 if (i != null) {
  let s = i;
  Array.isArray(s) && (s = s.map((a) => a)), d(n, ["embeddings"], s);
 }
 const o = c(t, ["metadata"]);
 return o != null && d(n, ["metadata"], o), n;
}
function Kz(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["predictions[]", "embeddings"]);
 if (i != null) {
  let s = i;
  Array.isArray(s) && (s = s.map((a) => Cz(a))), d(n, ["embeddings"], s);
 }
 const o = c(t, ["metadata"]);
 return o != null && d(n, ["metadata"], o), n;
}
function Jz(t, e) {
 const n = {},
  r = c(t, ["endpoint"]);
 r != null && d(n, ["name"], r);
 const i = c(t, ["deployedModelId"]);
 return i != null && d(n, ["deployedModelId"], i), n;
}
function Yz(t, e) {
 const n = {};
 if (c(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
 const r = c(t, ["fileUri"]);
 r != null && d(n, ["fileUri"], r);
 const i = c(t, ["mimeType"]);
 return i != null && d(n, ["mimeType"], i), n;
}
function Qz(t, e) {
 const n = {},
  r = c(t, ["id"]);
 r != null && d(n, ["id"], r);
 const i = c(t, ["args"]);
 i != null && d(n, ["args"], i);
 const o = c(t, ["name"]);
 if ((o != null && d(n, ["name"], o), c(t, ["partialArgs"]) !== void 0))
  throw new Error("partialArgs parameter is not supported in Gemini API.");
 if (c(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
 return n;
}
function Xz(t, e) {
 const n = {},
  r = c(t, ["allowedFunctionNames"]);
 r != null && d(n, ["allowedFunctionNames"], r);
 const i = c(t, ["mode"]);
 if ((i != null && d(n, ["mode"], i), c(t, ["streamFunctionCallArguments"]) !== void 0))
  throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
 return n;
}
function jz(t, e) {
 const n = {},
  r = c(t, ["description"]);
 r != null && d(n, ["description"], r);
 const i = c(t, ["name"]);
 i != null && d(n, ["name"], i);
 const o = c(t, ["parameters"]);
 o != null && d(n, ["parameters"], o);
 const s = c(t, ["parametersJsonSchema"]);
 s != null && d(n, ["parametersJsonSchema"], s);
 const a = c(t, ["response"]);
 a != null && d(n, ["response"], a);
 const l = c(t, ["responseJsonSchema"]);
 if ((l != null && d(n, ["responseJsonSchema"], l), c(t, ["behavior"]) !== void 0))
  throw new Error("behavior parameter is not supported in Vertex AI.");
 return n;
}
function Zz(t, e, n, r) {
 const i = {},
  o = c(e, ["systemInstruction"]);
 n !== void 0 && o != null && d(n, ["systemInstruction"], Pf(bt(o)));
 const s = c(e, ["temperature"]);
 s != null && d(i, ["temperature"], s);
 const a = c(e, ["topP"]);
 a != null && d(i, ["topP"], a);
 const l = c(e, ["topK"]);
 l != null && d(i, ["topK"], l);
 const u = c(e, ["candidateCount"]);
 u != null && d(i, ["candidateCount"], u);
 const h = c(e, ["maxOutputTokens"]);
 h != null && d(i, ["maxOutputTokens"], h);
 const p = c(e, ["stopSequences"]);
 p != null && d(i, ["stopSequences"], p);
 const m = c(e, ["responseLogprobs"]);
 m != null && d(i, ["responseLogprobs"], m);
 const v = c(e, ["logprobs"]);
 v != null && d(i, ["logprobs"], v);
 const w = c(e, ["presencePenalty"]);
 w != null && d(i, ["presencePenalty"], w);
 const C = c(e, ["frequencyPenalty"]);
 C != null && d(i, ["frequencyPenalty"], C);
 const A = c(e, ["seed"]);
 A != null && d(i, ["seed"], A);
 const T = c(e, ["responseMimeType"]);
 T != null && d(i, ["responseMimeType"], T);
 const _ = c(e, ["responseSchema"]);
 _ != null && d(i, ["responseSchema"], vv(_));
 const E = c(e, ["responseJsonSchema"]);
 if ((E != null && d(i, ["responseJsonSchema"], E), c(e, ["routingConfig"]) !== void 0))
  throw new Error("routingConfig parameter is not supported in Gemini API.");
 if (c(e, ["modelSelectionConfig"]) !== void 0)
  throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
 const N = c(e, ["safetySettings"]);
 if (n !== void 0 && N != null) {
  let se = N;
  Array.isArray(se) && (se = se.map((Jt) => q6(Jt))), d(n, ["safetySettings"], se);
 }
 const M = c(e, ["tools"]);
 if (n !== void 0 && M != null) {
  let se = Xs(M);
  Array.isArray(se) && (se = se.map((Jt) => Q6(Qs(Jt)))), d(n, ["tools"], se);
 }
 const F = c(e, ["toolConfig"]);
 if ((n !== void 0 && F != null && d(n, ["toolConfig"], Y6(F)), c(e, ["labels"]) !== void 0))
  throw new Error("labels parameter is not supported in Gemini API.");
 const P = c(e, ["cachedContent"]);
 n !== void 0 && P != null && d(n, ["cachedContent"], Br(t, P));
 const I = c(e, ["responseModalities"]);
 I != null && d(i, ["responseModalities"], I);
 const R = c(e, ["mediaResolution"]);
 R != null && d(i, ["mediaResolution"], R);
 const k = c(e, ["speechConfig"]);
 if ((k != null && d(i, ["speechConfig"], _v(k)), c(e, ["audioTimestamp"]) !== void 0))
  throw new Error("audioTimestamp parameter is not supported in Gemini API.");
 const x = c(e, ["thinkingConfig"]);
 x != null && d(i, ["thinkingConfig"], x);
 const D = c(e, ["imageConfig"]);
 D != null && d(i, ["imageConfig"], C6(D));
 const b = c(e, ["enableEnhancedCivicAnswers"]);
 if ((b != null && d(i, ["enableEnhancedCivicAnswers"], b), c(e, ["modelArmorConfig"]) !== void 0))
  throw new Error("modelArmorConfig parameter is not supported in Gemini API.");
 return i;
}
function e6(t, e, n, r) {
 const i = {},
  o = c(e, ["systemInstruction"]);
 n !== void 0 && o != null && d(n, ["systemInstruction"], bt(o));
 const s = c(e, ["temperature"]);
 s != null && d(i, ["temperature"], s);
 const a = c(e, ["topP"]);
 a != null && d(i, ["topP"], a);
 const l = c(e, ["topK"]);
 l != null && d(i, ["topK"], l);
 const u = c(e, ["candidateCount"]);
 u != null && d(i, ["candidateCount"], u);
 const h = c(e, ["maxOutputTokens"]);
 h != null && d(i, ["maxOutputTokens"], h);
 const p = c(e, ["stopSequences"]);
 p != null && d(i, ["stopSequences"], p);
 const m = c(e, ["responseLogprobs"]);
 m != null && d(i, ["responseLogprobs"], m);
 const v = c(e, ["logprobs"]);
 v != null && d(i, ["logprobs"], v);
 const w = c(e, ["presencePenalty"]);
 w != null && d(i, ["presencePenalty"], w);
 const C = c(e, ["frequencyPenalty"]);
 C != null && d(i, ["frequencyPenalty"], C);
 const A = c(e, ["seed"]);
 A != null && d(i, ["seed"], A);
 const T = c(e, ["responseMimeType"]);
 T != null && d(i, ["responseMimeType"], T);
 const _ = c(e, ["responseSchema"]);
 _ != null && d(i, ["responseSchema"], vv(_));
 const E = c(e, ["responseJsonSchema"]);
 E != null && d(i, ["responseJsonSchema"], E);
 const N = c(e, ["routingConfig"]);
 N != null && d(i, ["routingConfig"], N);
 const M = c(e, ["modelSelectionConfig"]);
 M != null && d(i, ["modelConfig"], M);
 const F = c(e, ["safetySettings"]);
 if (n !== void 0 && F != null) {
  let z = F;
  Array.isArray(z) && (z = z.map((Z) => Z)), d(n, ["safetySettings"], z);
 }
 const P = c(e, ["tools"]);
 if (n !== void 0 && P != null) {
  let z = Xs(P);
  Array.isArray(z) && (z = z.map((Z) => Qk(Qs(Z)))), d(n, ["tools"], z);
 }
 const I = c(e, ["toolConfig"]);
 n !== void 0 && I != null && d(n, ["toolConfig"], I);
 const R = c(e, ["labels"]);
 n !== void 0 && R != null && d(n, ["labels"], R);
 const k = c(e, ["cachedContent"]);
 n !== void 0 && k != null && d(n, ["cachedContent"], Br(t, k));
 const x = c(e, ["responseModalities"]);
 x != null && d(i, ["responseModalities"], x);
 const D = c(e, ["mediaResolution"]);
 D != null && d(i, ["mediaResolution"], D);
 const b = c(e, ["speechConfig"]);
 b != null && d(i, ["speechConfig"], _v(b));
 const se = c(e, ["audioTimestamp"]);
 se != null && d(i, ["audioTimestamp"], se);
 const Jt = c(e, ["thinkingConfig"]);
 Jt != null && d(i, ["thinkingConfig"], Jt);
 const $r = c(e, ["imageConfig"]);
 if (($r != null && d(i, ["imageConfig"], R6($r)), c(e, ["enableEnhancedCivicAnswers"]) !== void 0))
  throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
 const _n = c(e, ["modelArmorConfig"]);
 return n !== void 0 && _n != null && d(n, ["modelArmorConfig"], _n), i;
}
function KT(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["contents"]);
 if (o != null) {
  let a = Sn(o);
  Array.isArray(a) && (a = a.map((l) => Pf(l))), d(r, ["contents"], a);
 }
 const s = c(e, ["config"]);
 return s != null && d(r, ["generationConfig"], Zz(t, s, r)), r;
}
function JT(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["contents"]);
 if (o != null) {
  let a = Sn(o);
  Array.isArray(a) && (a = a.map((l) => l)), d(r, ["contents"], a);
 }
 const s = c(e, ["config"]);
 return s != null && d(r, ["generationConfig"], e6(t, s, r)), r;
}
function YT(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["candidates"]);
 if (i != null) {
  let u = i;
  Array.isArray(u) && (u = u.map((h) => Tz(h))), d(n, ["candidates"], u);
 }
 const o = c(t, ["modelVersion"]);
 o != null && d(n, ["modelVersion"], o);
 const s = c(t, ["promptFeedback"]);
 s != null && d(n, ["promptFeedback"], s);
 const a = c(t, ["responseId"]);
 a != null && d(n, ["responseId"], a);
 const l = c(t, ["usageMetadata"]);
 return l != null && d(n, ["usageMetadata"], l), n;
}
function QT(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["candidates"]);
 if (i != null) {
  let h = i;
  Array.isArray(h) && (h = h.map((p) => p)), d(n, ["candidates"], h);
 }
 const o = c(t, ["createTime"]);
 o != null && d(n, ["createTime"], o);
 const s = c(t, ["modelVersion"]);
 s != null && d(n, ["modelVersion"], s);
 const a = c(t, ["promptFeedback"]);
 a != null && d(n, ["promptFeedback"], a);
 const l = c(t, ["responseId"]);
 l != null && d(n, ["responseId"], l);
 const u = c(t, ["usageMetadata"]);
 return u != null && d(n, ["usageMetadata"], u), n;
}
function t6(t, e, n) {
 const r = {};
 if (c(t, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API.");
 if (c(t, ["negativePrompt"]) !== void 0) throw new Error("negativePrompt parameter is not supported in Gemini API.");
 const i = c(t, ["numberOfImages"]);
 e !== void 0 && i != null && d(e, ["parameters", "sampleCount"], i);
 const o = c(t, ["aspectRatio"]);
 e !== void 0 && o != null && d(e, ["parameters", "aspectRatio"], o);
 const s = c(t, ["guidanceScale"]);
 if ((e !== void 0 && s != null && d(e, ["parameters", "guidanceScale"], s), c(t, ["seed"]) !== void 0))
  throw new Error("seed parameter is not supported in Gemini API.");
 const a = c(t, ["safetyFilterLevel"]);
 e !== void 0 && a != null && d(e, ["parameters", "safetySetting"], a);
 const l = c(t, ["personGeneration"]);
 e !== void 0 && l != null && d(e, ["parameters", "personGeneration"], l);
 const u = c(t, ["includeSafetyAttributes"]);
 e !== void 0 && u != null && d(e, ["parameters", "includeSafetyAttributes"], u);
 const h = c(t, ["includeRaiReason"]);
 e !== void 0 && h != null && d(e, ["parameters", "includeRaiReason"], h);
 const p = c(t, ["language"]);
 e !== void 0 && p != null && d(e, ["parameters", "language"], p);
 const m = c(t, ["outputMimeType"]);
 e !== void 0 && m != null && d(e, ["parameters", "outputOptions", "mimeType"], m);
 const v = c(t, ["outputCompressionQuality"]);
 if (
  (e !== void 0 && v != null && d(e, ["parameters", "outputOptions", "compressionQuality"], v),
  c(t, ["addWatermark"]) !== void 0)
 )
  throw new Error("addWatermark parameter is not supported in Gemini API.");
 if (c(t, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API.");
 const w = c(t, ["imageSize"]);
 if ((e !== void 0 && w != null && d(e, ["parameters", "sampleImageSize"], w), c(t, ["enhancePrompt"]) !== void 0))
  throw new Error("enhancePrompt parameter is not supported in Gemini API.");
 return r;
}
function n6(t, e, n) {
 const r = {},
  i = c(t, ["outputGcsUri"]);
 e !== void 0 && i != null && d(e, ["parameters", "storageUri"], i);
 const o = c(t, ["negativePrompt"]);
 e !== void 0 && o != null && d(e, ["parameters", "negativePrompt"], o);
 const s = c(t, ["numberOfImages"]);
 e !== void 0 && s != null && d(e, ["parameters", "sampleCount"], s);
 const a = c(t, ["aspectRatio"]);
 e !== void 0 && a != null && d(e, ["parameters", "aspectRatio"], a);
 const l = c(t, ["guidanceScale"]);
 e !== void 0 && l != null && d(e, ["parameters", "guidanceScale"], l);
 const u = c(t, ["seed"]);
 e !== void 0 && u != null && d(e, ["parameters", "seed"], u);
 const h = c(t, ["safetyFilterLevel"]);
 e !== void 0 && h != null && d(e, ["parameters", "safetySetting"], h);
 const p = c(t, ["personGeneration"]);
 e !== void 0 && p != null && d(e, ["parameters", "personGeneration"], p);
 const m = c(t, ["includeSafetyAttributes"]);
 e !== void 0 && m != null && d(e, ["parameters", "includeSafetyAttributes"], m);
 const v = c(t, ["includeRaiReason"]);
 e !== void 0 && v != null && d(e, ["parameters", "includeRaiReason"], v);
 const w = c(t, ["language"]);
 e !== void 0 && w != null && d(e, ["parameters", "language"], w);
 const C = c(t, ["outputMimeType"]);
 e !== void 0 && C != null && d(e, ["parameters", "outputOptions", "mimeType"], C);
 const A = c(t, ["outputCompressionQuality"]);
 e !== void 0 && A != null && d(e, ["parameters", "outputOptions", "compressionQuality"], A);
 const T = c(t, ["addWatermark"]);
 e !== void 0 && T != null && d(e, ["parameters", "addWatermark"], T);
 const _ = c(t, ["labels"]);
 e !== void 0 && _ != null && d(e, ["labels"], _);
 const E = c(t, ["imageSize"]);
 e !== void 0 && E != null && d(e, ["parameters", "sampleImageSize"], E);
 const N = c(t, ["enhancePrompt"]);
 return e !== void 0 && N != null && d(e, ["parameters", "enhancePrompt"], N), r;
}
function r6(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["prompt"]);
 o != null && d(r, ["instances[0]", "prompt"], o);
 const s = c(e, ["config"]);
 return s != null && t6(s, r), r;
}
function i6(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["prompt"]);
 o != null && d(r, ["instances[0]", "prompt"], o);
 const s = c(e, ["config"]);
 return s != null && n6(s, r), r;
}
function o6(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["predictions"]);
 if (i != null) {
  let s = i;
  Array.isArray(s) && (s = s.map((a) => y6(a))), d(n, ["generatedImages"], s);
 }
 const o = c(t, ["positivePromptSafetyAttributes"]);
 return o != null && d(n, ["positivePromptSafetyAttributes"], Jk(o)), n;
}
function s6(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["predictions"]);
 if (i != null) {
  let s = i;
  Array.isArray(s) && (s = s.map((a) => kf(a))), d(n, ["generatedImages"], s);
 }
 const o = c(t, ["positivePromptSafetyAttributes"]);
 return o != null && d(n, ["positivePromptSafetyAttributes"], Yk(o)), n;
}
function a6(t, e, n) {
 const r = {},
  i = c(t, ["numberOfVideos"]);
 if ((e !== void 0 && i != null && d(e, ["parameters", "sampleCount"], i), c(t, ["outputGcsUri"]) !== void 0))
  throw new Error("outputGcsUri parameter is not supported in Gemini API.");
 if (c(t, ["fps"]) !== void 0) throw new Error("fps parameter is not supported in Gemini API.");
 const o = c(t, ["durationSeconds"]);
 if ((e !== void 0 && o != null && d(e, ["parameters", "durationSeconds"], o), c(t, ["seed"]) !== void 0))
  throw new Error("seed parameter is not supported in Gemini API.");
 const s = c(t, ["aspectRatio"]);
 e !== void 0 && s != null && d(e, ["parameters", "aspectRatio"], s);
 const a = c(t, ["resolution"]);
 e !== void 0 && a != null && d(e, ["parameters", "resolution"], a);
 const l = c(t, ["personGeneration"]);
 if ((e !== void 0 && l != null && d(e, ["parameters", "personGeneration"], l), c(t, ["pubsubTopic"]) !== void 0))
  throw new Error("pubsubTopic parameter is not supported in Gemini API.");
 const u = c(t, ["negativePrompt"]);
 e !== void 0 && u != null && d(e, ["parameters", "negativePrompt"], u);
 const h = c(t, ["enhancePrompt"]);
 if ((e !== void 0 && h != null && d(e, ["parameters", "enhancePrompt"], h), c(t, ["generateAudio"]) !== void 0))
  throw new Error("generateAudio parameter is not supported in Gemini API.");
 const p = c(t, ["lastFrame"]);
 e !== void 0 && p != null && d(e, ["instances[0]", "lastFrame"], bf(p));
 const m = c(t, ["referenceImages"]);
 if (e !== void 0 && m != null) {
  let v = m;
  Array.isArray(v) && (v = v.map((w) => u9(w))), d(e, ["instances[0]", "referenceImages"], v);
 }
 if (c(t, ["mask"]) !== void 0) throw new Error("mask parameter is not supported in Gemini API.");
 if (c(t, ["compressionQuality"]) !== void 0)
  throw new Error("compressionQuality parameter is not supported in Gemini API.");
 return r;
}
function l6(t, e, n) {
 const r = {},
  i = c(t, ["numberOfVideos"]);
 e !== void 0 && i != null && d(e, ["parameters", "sampleCount"], i);
 const o = c(t, ["outputGcsUri"]);
 e !== void 0 && o != null && d(e, ["parameters", "storageUri"], o);
 const s = c(t, ["fps"]);
 e !== void 0 && s != null && d(e, ["parameters", "fps"], s);
 const a = c(t, ["durationSeconds"]);
 e !== void 0 && a != null && d(e, ["parameters", "durationSeconds"], a);
 const l = c(t, ["seed"]);
 e !== void 0 && l != null && d(e, ["parameters", "seed"], l);
 const u = c(t, ["aspectRatio"]);
 e !== void 0 && u != null && d(e, ["parameters", "aspectRatio"], u);
 const h = c(t, ["resolution"]);
 e !== void 0 && h != null && d(e, ["parameters", "resolution"], h);
 const p = c(t, ["personGeneration"]);
 e !== void 0 && p != null && d(e, ["parameters", "personGeneration"], p);
 const m = c(t, ["pubsubTopic"]);
 e !== void 0 && m != null && d(e, ["parameters", "pubsubTopic"], m);
 const v = c(t, ["negativePrompt"]);
 e !== void 0 && v != null && d(e, ["parameters", "negativePrompt"], v);
 const w = c(t, ["enhancePrompt"]);
 e !== void 0 && w != null && d(e, ["parameters", "enhancePrompt"], w);
 const C = c(t, ["generateAudio"]);
 e !== void 0 && C != null && d(e, ["parameters", "generateAudio"], C);
 const A = c(t, ["lastFrame"]);
 e !== void 0 && A != null && d(e, ["instances[0]", "lastFrame"], Wn(A));
 const T = c(t, ["referenceImages"]);
 if (e !== void 0 && T != null) {
  let N = T;
  Array.isArray(N) && (N = N.map((M) => c9(M))), d(e, ["instances[0]", "referenceImages"], N);
 }
 const _ = c(t, ["mask"]);
 e !== void 0 && _ != null && d(e, ["instances[0]", "mask"], l9(_));
 const E = c(t, ["compressionQuality"]);
 return e !== void 0 && E != null && d(e, ["parameters", "compressionQuality"], E), r;
}
function u6(t, e) {
 const n = {},
  r = c(t, ["name"]);
 r != null && d(n, ["name"], r);
 const i = c(t, ["metadata"]);
 i != null && d(n, ["metadata"], i);
 const o = c(t, ["done"]);
 o != null && d(n, ["done"], o);
 const s = c(t, ["error"]);
 s != null && d(n, ["error"], s);
 const a = c(t, ["response", "generateVideoResponse"]);
 return a != null && d(n, ["response"], h6(a)), n;
}
function c6(t, e) {
 const n = {},
  r = c(t, ["name"]);
 r != null && d(n, ["name"], r);
 const i = c(t, ["metadata"]);
 i != null && d(n, ["metadata"], i);
 const o = c(t, ["done"]);
 o != null && d(n, ["done"], o);
 const s = c(t, ["error"]);
 s != null && d(n, ["error"], s);
 const a = c(t, ["response"]);
 return a != null && d(n, ["response"], p6(a)), n;
}
function d6(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["prompt"]);
 o != null && d(r, ["instances[0]", "prompt"], o);
 const s = c(e, ["image"]);
 s != null && d(r, ["instances[0]", "image"], bf(s));
 const a = c(e, ["video"]);
 a != null && d(r, ["instances[0]", "video"], Xk(a));
 const l = c(e, ["source"]);
 l != null && m6(l, r);
 const u = c(e, ["config"]);
 return u != null && a6(u, r), r;
}
function f6(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["prompt"]);
 o != null && d(r, ["instances[0]", "prompt"], o);
 const s = c(e, ["image"]);
 s != null && d(r, ["instances[0]", "image"], Wn(s));
 const a = c(e, ["video"]);
 a != null && d(r, ["instances[0]", "video"], jk(a));
 const l = c(e, ["source"]);
 l != null && g6(l, r);
 const u = c(e, ["config"]);
 return u != null && l6(u, r), r;
}
function h6(t, e) {
 const n = {},
  r = c(t, ["generatedSamples"]);
 if (r != null) {
  let s = r;
  Array.isArray(s) && (s = s.map((a) => _6(a))), d(n, ["generatedVideos"], s);
 }
 const i = c(t, ["raiMediaFilteredCount"]);
 i != null && d(n, ["raiMediaFilteredCount"], i);
 const o = c(t, ["raiMediaFilteredReasons"]);
 return o != null && d(n, ["raiMediaFilteredReasons"], o), n;
}
function p6(t, e) {
 const n = {},
  r = c(t, ["videos"]);
 if (r != null) {
  let s = r;
  Array.isArray(s) && (s = s.map((a) => w6(a))), d(n, ["generatedVideos"], s);
 }
 const i = c(t, ["raiMediaFilteredCount"]);
 i != null && d(n, ["raiMediaFilteredCount"], i);
 const o = c(t, ["raiMediaFilteredReasons"]);
 return o != null && d(n, ["raiMediaFilteredReasons"], o), n;
}
function m6(t, e, n) {
 const r = {},
  i = c(t, ["prompt"]);
 e !== void 0 && i != null && d(e, ["instances[0]", "prompt"], i);
 const o = c(t, ["image"]);
 e !== void 0 && o != null && d(e, ["instances[0]", "image"], bf(o));
 const s = c(t, ["video"]);
 return e !== void 0 && s != null && d(e, ["instances[0]", "video"], Xk(s)), r;
}
function g6(t, e, n) {
 const r = {},
  i = c(t, ["prompt"]);
 e !== void 0 && i != null && d(e, ["instances[0]", "prompt"], i);
 const o = c(t, ["image"]);
 e !== void 0 && o != null && d(e, ["instances[0]", "image"], Wn(o));
 const s = c(t, ["video"]);
 return e !== void 0 && s != null && d(e, ["instances[0]", "video"], jk(s)), r;
}
function y6(t, e) {
 const n = {},
  r = c(t, ["_self"]);
 r != null && d(n, ["image"], P6(r));
 const i = c(t, ["raiFilteredReason"]);
 i != null && d(n, ["raiFilteredReason"], i);
 const o = c(t, ["_self"]);
 return o != null && d(n, ["safetyAttributes"], Jk(o)), n;
}
function kf(t, e) {
 const n = {},
  r = c(t, ["_self"]);
 r != null && d(n, ["image"], Kk(r));
 const i = c(t, ["raiFilteredReason"]);
 i != null && d(n, ["raiFilteredReason"], i);
 const o = c(t, ["_self"]);
 o != null && d(n, ["safetyAttributes"], Yk(o));
 const s = c(t, ["prompt"]);
 return s != null && d(n, ["enhancedPrompt"], s), n;
}
function v6(t, e) {
 const n = {},
  r = c(t, ["_self"]);
 r != null && d(n, ["mask"], Kk(r));
 const i = c(t, ["labels"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => s)), d(n, ["labels"], o);
 }
 return n;
}
function _6(t, e) {
 const n = {},
  r = c(t, ["video"]);
 return r != null && d(n, ["video"], s9(r)), n;
}
function w6(t, e) {
 const n = {},
  r = c(t, ["_self"]);
 return r != null && d(n, ["video"], a9(r)), n;
}
function E6(t, e) {
 const n = {},
  r = c(t, ["modelSelectionConfig"]);
 r != null && d(n, ["modelConfig"], r);
 const i = c(t, ["responseJsonSchema"]);
 i != null && d(n, ["responseJsonSchema"], i);
 const o = c(t, ["audioTimestamp"]);
 o != null && d(n, ["audioTimestamp"], o);
 const s = c(t, ["candidateCount"]);
 s != null && d(n, ["candidateCount"], s);
 const a = c(t, ["enableAffectiveDialog"]);
 a != null && d(n, ["enableAffectiveDialog"], a);
 const l = c(t, ["frequencyPenalty"]);
 l != null && d(n, ["frequencyPenalty"], l);
 const u = c(t, ["logprobs"]);
 u != null && d(n, ["logprobs"], u);
 const h = c(t, ["maxOutputTokens"]);
 h != null && d(n, ["maxOutputTokens"], h);
 const p = c(t, ["mediaResolution"]);
 p != null && d(n, ["mediaResolution"], p);
 const m = c(t, ["presencePenalty"]);
 m != null && d(n, ["presencePenalty"], m);
 const v = c(t, ["responseLogprobs"]);
 v != null && d(n, ["responseLogprobs"], v);
 const w = c(t, ["responseMimeType"]);
 w != null && d(n, ["responseMimeType"], w);
 const C = c(t, ["responseModalities"]);
 C != null && d(n, ["responseModalities"], C);
 const A = c(t, ["responseSchema"]);
 A != null && d(n, ["responseSchema"], A);
 const T = c(t, ["routingConfig"]);
 T != null && d(n, ["routingConfig"], T);
 const _ = c(t, ["seed"]);
 _ != null && d(n, ["seed"], _);
 const E = c(t, ["speechConfig"]);
 E != null && d(n, ["speechConfig"], E);
 const N = c(t, ["stopSequences"]);
 N != null && d(n, ["stopSequences"], N);
 const M = c(t, ["temperature"]);
 M != null && d(n, ["temperature"], M);
 const F = c(t, ["thinkingConfig"]);
 F != null && d(n, ["thinkingConfig"], F);
 const P = c(t, ["topK"]);
 P != null && d(n, ["topK"], P);
 const I = c(t, ["topP"]);
 if ((I != null && d(n, ["topP"], I), c(t, ["enableEnhancedCivicAnswers"]) !== void 0))
  throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
 return n;
}
function T6(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 return i != null && d(r, ["_url", "name"], ye(t, i)), r;
}
function I6(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 return i != null && d(r, ["_url", "name"], ye(t, i)), r;
}
function S6(t, e) {
 const n = {};
 if (c(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
 const r = c(t, ["enableWidget"]);
 return r != null && d(n, ["enableWidget"], r), n;
}
function A6(t, e) {
 const n = {};
 if (c(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
 if (c(t, ["blockingConfidence"]) !== void 0)
  throw new Error("blockingConfidence parameter is not supported in Gemini API.");
 const r = c(t, ["timeRangeFilter"]);
 return r != null && d(n, ["timeRangeFilter"], r), n;
}
function C6(t, e) {
 const n = {},
  r = c(t, ["aspectRatio"]);
 r != null && d(n, ["aspectRatio"], r);
 const i = c(t, ["imageSize"]);
 if ((i != null && d(n, ["imageSize"], i), c(t, ["personGeneration"]) !== void 0))
  throw new Error("personGeneration parameter is not supported in Gemini API.");
 if (c(t, ["outputMimeType"]) !== void 0) throw new Error("outputMimeType parameter is not supported in Gemini API.");
 if (c(t, ["outputCompressionQuality"]) !== void 0)
  throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
 return n;
}
function R6(t, e) {
 const n = {},
  r = c(t, ["aspectRatio"]);
 r != null && d(n, ["aspectRatio"], r);
 const i = c(t, ["imageSize"]);
 i != null && d(n, ["imageSize"], i);
 const o = c(t, ["personGeneration"]);
 o != null && d(n, ["personGeneration"], o);
 const s = c(t, ["outputMimeType"]);
 s != null && d(n, ["imageOutputOptions", "mimeType"], s);
 const a = c(t, ["outputCompressionQuality"]);
 return a != null && d(n, ["imageOutputOptions", "compressionQuality"], a), n;
}
function P6(t, e) {
 const n = {},
  r = c(t, ["bytesBase64Encoded"]);
 r != null && d(n, ["imageBytes"], Vi(r));
 const i = c(t, ["mimeType"]);
 return i != null && d(n, ["mimeType"], i), n;
}
function Kk(t, e) {
 const n = {},
  r = c(t, ["gcsUri"]);
 r != null && d(n, ["gcsUri"], r);
 const i = c(t, ["bytesBase64Encoded"]);
 i != null && d(n, ["imageBytes"], Vi(i));
 const o = c(t, ["mimeType"]);
 return o != null && d(n, ["mimeType"], o), n;
}
function bf(t, e) {
 const n = {};
 if (c(t, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API.");
 const r = c(t, ["imageBytes"]);
 r != null && d(n, ["bytesBase64Encoded"], Vi(r));
 const i = c(t, ["mimeType"]);
 return i != null && d(n, ["mimeType"], i), n;
}
function Wn(t, e) {
 const n = {},
  r = c(t, ["gcsUri"]);
 r != null && d(n, ["gcsUri"], r);
 const i = c(t, ["imageBytes"]);
 i != null && d(n, ["bytesBase64Encoded"], Vi(i));
 const o = c(t, ["mimeType"]);
 return o != null && d(n, ["mimeType"], o), n;
}
function k6(t, e, n, r) {
 const i = {},
  o = c(e, ["pageSize"]);
 n !== void 0 && o != null && d(n, ["_query", "pageSize"], o);
 const s = c(e, ["pageToken"]);
 n !== void 0 && s != null && d(n, ["_query", "pageToken"], s);
 const a = c(e, ["filter"]);
 n !== void 0 && a != null && d(n, ["_query", "filter"], a);
 const l = c(e, ["queryBase"]);
 return n !== void 0 && l != null && d(n, ["_url", "models_url"], Bk(t, l)), i;
}
function b6(t, e, n, r) {
 const i = {},
  o = c(e, ["pageSize"]);
 n !== void 0 && o != null && d(n, ["_query", "pageSize"], o);
 const s = c(e, ["pageToken"]);
 n !== void 0 && s != null && d(n, ["_query", "pageToken"], s);
 const a = c(e, ["filter"]);
 n !== void 0 && a != null && d(n, ["_query", "filter"], a);
 const l = c(e, ["queryBase"]);
 return n !== void 0 && l != null && d(n, ["_url", "models_url"], Bk(t, l)), i;
}
function N6(t, e, n) {
 const r = {},
  i = c(e, ["config"]);
 return i != null && k6(t, i, r), r;
}
function x6(t, e, n) {
 const r = {},
  i = c(e, ["config"]);
 return i != null && b6(t, i, r), r;
}
function M6(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["nextPageToken"]);
 i != null && d(n, ["nextPageToken"], i);
 const o = c(t, ["_self"]);
 if (o != null) {
  let s = $k(o);
  Array.isArray(s) && (s = s.map((a) => Dm(a))), d(n, ["models"], s);
 }
 return n;
}
function D6(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["nextPageToken"]);
 i != null && d(n, ["nextPageToken"], i);
 const o = c(t, ["_self"]);
 if (o != null) {
  let s = $k(o);
  Array.isArray(s) && (s = s.map((a) => Lm(a))), d(n, ["models"], s);
 }
 return n;
}
function L6(t, e) {
 const n = {},
  r = c(t, ["maskMode"]);
 r != null && d(n, ["maskMode"], r);
 const i = c(t, ["segmentationClasses"]);
 i != null && d(n, ["maskClasses"], i);
 const o = c(t, ["maskDilation"]);
 return o != null && d(n, ["dilation"], o), n;
}
function Dm(t, e) {
 const n = {},
  r = c(t, ["name"]);
 r != null && d(n, ["name"], r);
 const i = c(t, ["displayName"]);
 i != null && d(n, ["displayName"], i);
 const o = c(t, ["description"]);
 o != null && d(n, ["description"], o);
 const s = c(t, ["version"]);
 s != null && d(n, ["version"], s);
 const a = c(t, ["_self"]);
 a != null && d(n, ["tunedModelInfo"], X6(a));
 const l = c(t, ["inputTokenLimit"]);
 l != null && d(n, ["inputTokenLimit"], l);
 const u = c(t, ["outputTokenLimit"]);
 u != null && d(n, ["outputTokenLimit"], u);
 const h = c(t, ["supportedGenerationMethods"]);
 h != null && d(n, ["supportedActions"], h);
 const p = c(t, ["temperature"]);
 p != null && d(n, ["temperature"], p);
 const m = c(t, ["maxTemperature"]);
 m != null && d(n, ["maxTemperature"], m);
 const v = c(t, ["topP"]);
 v != null && d(n, ["topP"], v);
 const w = c(t, ["topK"]);
 w != null && d(n, ["topK"], w);
 const C = c(t, ["thinking"]);
 return C != null && d(n, ["thinking"], C), n;
}
function Lm(t, e) {
 const n = {},
  r = c(t, ["name"]);
 r != null && d(n, ["name"], r);
 const i = c(t, ["displayName"]);
 i != null && d(n, ["displayName"], i);
 const o = c(t, ["description"]);
 o != null && d(n, ["description"], o);
 const s = c(t, ["versionId"]);
 s != null && d(n, ["version"], s);
 const a = c(t, ["deployedModels"]);
 if (a != null) {
  let m = a;
  Array.isArray(m) && (m = m.map((v) => Jz(v))), d(n, ["endpoints"], m);
 }
 const l = c(t, ["labels"]);
 l != null && d(n, ["labels"], l);
 const u = c(t, ["_self"]);
 u != null && d(n, ["tunedModelInfo"], j6(u));
 const h = c(t, ["defaultCheckpointId"]);
 h != null && d(n, ["defaultCheckpointId"], h);
 const p = c(t, ["checkpoints"]);
 if (p != null) {
  let m = p;
  Array.isArray(m) && (m = m.map((v) => v)), d(n, ["checkpoints"], m);
 }
 return n;
}
function V6(t, e) {
 const n = {},
  r = c(t, ["mediaResolution"]);
 r != null && d(n, ["mediaResolution"], r);
 const i = c(t, ["codeExecutionResult"]);
 i != null && d(n, ["codeExecutionResult"], i);
 const o = c(t, ["executableCode"]);
 o != null && d(n, ["executableCode"], o);
 const s = c(t, ["fileData"]);
 s != null && d(n, ["fileData"], Yz(s));
 const a = c(t, ["functionCall"]);
 a != null && d(n, ["functionCall"], Qz(a));
 const l = c(t, ["functionResponse"]);
 l != null && d(n, ["functionResponse"], l);
 const u = c(t, ["inlineData"]);
 u != null && d(n, ["inlineData"], Ez(u));
 const h = c(t, ["text"]);
 h != null && d(n, ["text"], h);
 const p = c(t, ["thought"]);
 p != null && d(n, ["thought"], p);
 const m = c(t, ["thoughtSignature"]);
 m != null && d(n, ["thoughtSignature"], m);
 const v = c(t, ["videoMetadata"]);
 return v != null && d(n, ["videoMetadata"], v), n;
}
function U6(t, e) {
 const n = {},
  r = c(t, ["productImage"]);
 return r != null && d(n, ["image"], Wn(r)), n;
}
function O6(t, e, n) {
 const r = {},
  i = c(t, ["numberOfImages"]);
 e !== void 0 && i != null && d(e, ["parameters", "sampleCount"], i);
 const o = c(t, ["baseSteps"]);
 e !== void 0 && o != null && d(e, ["parameters", "baseSteps"], o);
 const s = c(t, ["outputGcsUri"]);
 e !== void 0 && s != null && d(e, ["parameters", "storageUri"], s);
 const a = c(t, ["seed"]);
 e !== void 0 && a != null && d(e, ["parameters", "seed"], a);
 const l = c(t, ["safetyFilterLevel"]);
 e !== void 0 && l != null && d(e, ["parameters", "safetySetting"], l);
 const u = c(t, ["personGeneration"]);
 e !== void 0 && u != null && d(e, ["parameters", "personGeneration"], u);
 const h = c(t, ["addWatermark"]);
 e !== void 0 && h != null && d(e, ["parameters", "addWatermark"], h);
 const p = c(t, ["outputMimeType"]);
 e !== void 0 && p != null && d(e, ["parameters", "outputOptions", "mimeType"], p);
 const m = c(t, ["outputCompressionQuality"]);
 e !== void 0 && m != null && d(e, ["parameters", "outputOptions", "compressionQuality"], m);
 const v = c(t, ["enhancePrompt"]);
 e !== void 0 && v != null && d(e, ["parameters", "enhancePrompt"], v);
 const w = c(t, ["labels"]);
 return e !== void 0 && w != null && d(e, ["labels"], w), r;
}
function F6(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["source"]);
 o != null && $6(o, r);
 const s = c(e, ["config"]);
 return s != null && O6(s, r), r;
}
function B6(t, e) {
 const n = {},
  r = c(t, ["predictions"]);
 if (r != null) {
  let i = r;
  Array.isArray(i) && (i = i.map((o) => kf(o))), d(n, ["generatedImages"], i);
 }
 return n;
}
function $6(t, e, n) {
 const r = {},
  i = c(t, ["prompt"]);
 e !== void 0 && i != null && d(e, ["instances[0]", "prompt"], i);
 const o = c(t, ["personImage"]);
 e !== void 0 && o != null && d(e, ["instances[0]", "personImage", "image"], Wn(o));
 const s = c(t, ["productImages"]);
 if (e !== void 0 && s != null) {
  let a = s;
  Array.isArray(a) && (a = a.map((l) => U6(l))), d(e, ["instances[0]", "productImages"], a);
 }
 return r;
}
function H6(t, e) {
 const n = {},
  r = c(t, ["referenceImage"]);
 r != null && d(n, ["referenceImage"], Wn(r));
 const i = c(t, ["referenceId"]);
 i != null && d(n, ["referenceId"], i);
 const o = c(t, ["referenceType"]);
 o != null && d(n, ["referenceType"], o);
 const s = c(t, ["maskImageConfig"]);
 s != null && d(n, ["maskImageConfig"], L6(s));
 const a = c(t, ["controlImageConfig"]);
 a != null && d(n, ["controlImageConfig"], Pz(a));
 const l = c(t, ["styleImageConfig"]);
 l != null && d(n, ["styleImageConfig"], l);
 const u = c(t, ["subjectImageConfig"]);
 return u != null && d(n, ["subjectImageConfig"], u), n;
}
function Jk(t, e) {
 const n = {},
  r = c(t, ["safetyAttributes", "categories"]);
 r != null && d(n, ["categories"], r);
 const i = c(t, ["safetyAttributes", "scores"]);
 i != null && d(n, ["scores"], i);
 const o = c(t, ["contentType"]);
 return o != null && d(n, ["contentType"], o), n;
}
function Yk(t, e) {
 const n = {},
  r = c(t, ["safetyAttributes", "categories"]);
 r != null && d(n, ["categories"], r);
 const i = c(t, ["safetyAttributes", "scores"]);
 i != null && d(n, ["scores"], i);
 const o = c(t, ["contentType"]);
 return o != null && d(n, ["contentType"], o), n;
}
function q6(t, e) {
 const n = {},
  r = c(t, ["category"]);
 if ((r != null && d(n, ["category"], r), c(t, ["method"]) !== void 0))
  throw new Error("method parameter is not supported in Gemini API.");
 const i = c(t, ["threshold"]);
 return i != null && d(n, ["threshold"], i), n;
}
function G6(t, e) {
 const n = {},
  r = c(t, ["image"]);
 return r != null && d(n, ["image"], Wn(r)), n;
}
function z6(t, e, n) {
 const r = {},
  i = c(t, ["mode"]);
 e !== void 0 && i != null && d(e, ["parameters", "mode"], i);
 const o = c(t, ["maxPredictions"]);
 e !== void 0 && o != null && d(e, ["parameters", "maxPredictions"], o);
 const s = c(t, ["confidenceThreshold"]);
 e !== void 0 && s != null && d(e, ["parameters", "confidenceThreshold"], s);
 const a = c(t, ["maskDilation"]);
 e !== void 0 && a != null && d(e, ["parameters", "maskDilation"], a);
 const l = c(t, ["binaryColorThreshold"]);
 e !== void 0 && l != null && d(e, ["parameters", "binaryColorThreshold"], l);
 const u = c(t, ["labels"]);
 return e !== void 0 && u != null && d(e, ["labels"], u), r;
}
function W6(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["source"]);
 o != null && J6(o, r);
 const s = c(e, ["config"]);
 return s != null && z6(s, r), r;
}
function K6(t, e) {
 const n = {},
  r = c(t, ["predictions"]);
 if (r != null) {
  let i = r;
  Array.isArray(i) && (i = i.map((o) => v6(o))), d(n, ["generatedMasks"], i);
 }
 return n;
}
function J6(t, e, n) {
 const r = {},
  i = c(t, ["prompt"]);
 e !== void 0 && i != null && d(e, ["instances[0]", "prompt"], i);
 const o = c(t, ["image"]);
 e !== void 0 && o != null && d(e, ["instances[0]", "image"], Wn(o));
 const s = c(t, ["scribbleImage"]);
 return e !== void 0 && s != null && d(e, ["instances[0]", "scribble"], G6(s)), r;
}
function Y6(t, e) {
 const n = {},
  r = c(t, ["retrievalConfig"]);
 r != null && d(n, ["retrievalConfig"], r);
 const i = c(t, ["functionCallingConfig"]);
 return i != null && d(n, ["functionCallingConfig"], Xz(i)), n;
}
function Q6(t, e) {
 const n = {};
 if (c(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
 const r = c(t, ["computerUse"]);
 r != null && d(n, ["computerUse"], r);
 const i = c(t, ["fileSearch"]);
 i != null && d(n, ["fileSearch"], i);
 const o = c(t, ["codeExecution"]);
 if ((o != null && d(n, ["codeExecution"], o), c(t, ["enterpriseWebSearch"]) !== void 0))
  throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
 const s = c(t, ["functionDeclarations"]);
 if (s != null) {
  let p = s;
  Array.isArray(p) && (p = p.map((m) => m)), d(n, ["functionDeclarations"], p);
 }
 const a = c(t, ["googleMaps"]);
 a != null && d(n, ["googleMaps"], S6(a));
 const l = c(t, ["googleSearch"]);
 l != null && d(n, ["googleSearch"], A6(l));
 const u = c(t, ["googleSearchRetrieval"]);
 u != null && d(n, ["googleSearchRetrieval"], u);
 const h = c(t, ["urlContext"]);
 return h != null && d(n, ["urlContext"], h), n;
}
function Qk(t, e) {
 const n = {},
  r = c(t, ["retrieval"]);
 r != null && d(n, ["retrieval"], r);
 const i = c(t, ["computerUse"]);
 if ((i != null && d(n, ["computerUse"], i), c(t, ["fileSearch"]) !== void 0))
  throw new Error("fileSearch parameter is not supported in Vertex AI.");
 const o = c(t, ["codeExecution"]);
 o != null && d(n, ["codeExecution"], o);
 const s = c(t, ["enterpriseWebSearch"]);
 s != null && d(n, ["enterpriseWebSearch"], s);
 const a = c(t, ["functionDeclarations"]);
 if (a != null) {
  let m = a;
  Array.isArray(m) && (m = m.map((v) => jz(v))), d(n, ["functionDeclarations"], m);
 }
 const l = c(t, ["googleMaps"]);
 l != null && d(n, ["googleMaps"], l);
 const u = c(t, ["googleSearch"]);
 u != null && d(n, ["googleSearch"], u);
 const h = c(t, ["googleSearchRetrieval"]);
 h != null && d(n, ["googleSearchRetrieval"], h);
 const p = c(t, ["urlContext"]);
 return p != null && d(n, ["urlContext"], p), n;
}
function X6(t, e) {
 const n = {},
  r = c(t, ["baseModel"]);
 r != null && d(n, ["baseModel"], r);
 const i = c(t, ["createTime"]);
 i != null && d(n, ["createTime"], i);
 const o = c(t, ["updateTime"]);
 return o != null && d(n, ["updateTime"], o), n;
}
function j6(t, e) {
 const n = {},
  r = c(t, ["labels", "google-vertex-llm-tuning-base-model-id"]);
 r != null && d(n, ["baseModel"], r);
 const i = c(t, ["createTime"]);
 i != null && d(n, ["createTime"], i);
 const o = c(t, ["updateTime"]);
 return o != null && d(n, ["updateTime"], o), n;
}
function Z6(t, e, n) {
 const r = {},
  i = c(t, ["displayName"]);
 e !== void 0 && i != null && d(e, ["displayName"], i);
 const o = c(t, ["description"]);
 e !== void 0 && o != null && d(e, ["description"], o);
 const s = c(t, ["defaultCheckpointId"]);
 return e !== void 0 && s != null && d(e, ["defaultCheckpointId"], s), r;
}
function e9(t, e, n) {
 const r = {},
  i = c(t, ["displayName"]);
 e !== void 0 && i != null && d(e, ["displayName"], i);
 const o = c(t, ["description"]);
 e !== void 0 && o != null && d(e, ["description"], o);
 const s = c(t, ["defaultCheckpointId"]);
 return e !== void 0 && s != null && d(e, ["defaultCheckpointId"], s), r;
}
function t9(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "name"], ye(t, i));
 const o = c(e, ["config"]);
 return o != null && Z6(o, r), r;
}
function n9(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["config"]);
 return o != null && e9(o, r), r;
}
function r9(t, e, n) {
 const r = {},
  i = c(t, ["outputGcsUri"]);
 e !== void 0 && i != null && d(e, ["parameters", "storageUri"], i);
 const o = c(t, ["safetyFilterLevel"]);
 e !== void 0 && o != null && d(e, ["parameters", "safetySetting"], o);
 const s = c(t, ["personGeneration"]);
 e !== void 0 && s != null && d(e, ["parameters", "personGeneration"], s);
 const a = c(t, ["includeRaiReason"]);
 e !== void 0 && a != null && d(e, ["parameters", "includeRaiReason"], a);
 const l = c(t, ["outputMimeType"]);
 e !== void 0 && l != null && d(e, ["parameters", "outputOptions", "mimeType"], l);
 const u = c(t, ["outputCompressionQuality"]);
 e !== void 0 && u != null && d(e, ["parameters", "outputOptions", "compressionQuality"], u);
 const h = c(t, ["enhanceInputImage"]);
 e !== void 0 && h != null && d(e, ["parameters", "upscaleConfig", "enhanceInputImage"], h);
 const p = c(t, ["imagePreservationFactor"]);
 e !== void 0 && p != null && d(e, ["parameters", "upscaleConfig", "imagePreservationFactor"], p);
 const m = c(t, ["labels"]);
 e !== void 0 && m != null && d(e, ["labels"], m);
 const v = c(t, ["numberOfImages"]);
 e !== void 0 && v != null && d(e, ["parameters", "sampleCount"], v);
 const w = c(t, ["mode"]);
 return e !== void 0 && w != null && d(e, ["parameters", "mode"], w), r;
}
function i9(t, e, n) {
 const r = {},
  i = c(e, ["model"]);
 i != null && d(r, ["_url", "model"], ye(t, i));
 const o = c(e, ["image"]);
 o != null && d(r, ["instances[0]", "image"], Wn(o));
 const s = c(e, ["upscaleFactor"]);
 s != null && d(r, ["parameters", "upscaleConfig", "upscaleFactor"], s);
 const a = c(e, ["config"]);
 return a != null && r9(a, r), r;
}
function o9(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["predictions"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => kf(s))), d(n, ["generatedImages"], o);
 }
 return n;
}
function s9(t, e) {
 const n = {},
  r = c(t, ["uri"]);
 r != null && d(n, ["uri"], r);
 const i = c(t, ["encodedVideo"]);
 i != null && d(n, ["videoBytes"], Vi(i));
 const o = c(t, ["encoding"]);
 return o != null && d(n, ["mimeType"], o), n;
}
function a9(t, e) {
 const n = {},
  r = c(t, ["gcsUri"]);
 r != null && d(n, ["uri"], r);
 const i = c(t, ["bytesBase64Encoded"]);
 i != null && d(n, ["videoBytes"], Vi(i));
 const o = c(t, ["mimeType"]);
 return o != null && d(n, ["mimeType"], o), n;
}
function l9(t, e) {
 const n = {},
  r = c(t, ["image"]);
 r != null && d(n, ["_self"], Wn(r));
 const i = c(t, ["maskMode"]);
 return i != null && d(n, ["maskMode"], i), n;
}
function u9(t, e) {
 const n = {},
  r = c(t, ["image"]);
 r != null && d(n, ["image"], bf(r));
 const i = c(t, ["referenceType"]);
 return i != null && d(n, ["referenceType"], i), n;
}
function c9(t, e) {
 const n = {},
  r = c(t, ["image"]);
 r != null && d(n, ["image"], Wn(r));
 const i = c(t, ["referenceType"]);
 return i != null && d(n, ["referenceType"], i), n;
}
function Xk(t, e) {
 const n = {},
  r = c(t, ["uri"]);
 r != null && d(n, ["uri"], r);
 const i = c(t, ["videoBytes"]);
 i != null && d(n, ["encodedVideo"], Vi(i));
 const o = c(t, ["mimeType"]);
 return o != null && d(n, ["encoding"], o), n;
}
function jk(t, e) {
 const n = {},
  r = c(t, ["uri"]);
 r != null && d(n, ["gcsUri"], r);
 const i = c(t, ["videoBytes"]);
 i != null && d(n, ["bytesBase64Encoded"], Vi(i));
 const o = c(t, ["mimeType"]);
 return o != null && d(n, ["mimeType"], o), n;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function d9(t, e) {
 const n = {},
  r = c(t, ["displayName"]);
 return e !== void 0 && r != null && d(e, ["displayName"], r), n;
}
function f9(t) {
 const e = {},
  n = c(t, ["config"]);
 return n != null && d9(n, e), e;
}
function h9(t, e) {
 const n = {},
  r = c(t, ["force"]);
 return e !== void 0 && r != null && d(e, ["_query", "force"], r), n;
}
function p9(t) {
 const e = {},
  n = c(t, ["name"]);
 n != null && d(e, ["_url", "name"], n);
 const r = c(t, ["config"]);
 return r != null && h9(r, e), e;
}
function m9(t) {
 const e = {},
  n = c(t, ["name"]);
 return n != null && d(e, ["_url", "name"], n), e;
}
function g9(t, e) {
 const n = {},
  r = c(t, ["customMetadata"]);
 if (e !== void 0 && r != null) {
  let o = r;
  Array.isArray(o) && (o = o.map((s) => s)), d(e, ["customMetadata"], o);
 }
 const i = c(t, ["chunkingConfig"]);
 return e !== void 0 && i != null && d(e, ["chunkingConfig"], i), n;
}
function y9(t) {
 const e = {},
  n = c(t, ["name"]);
 n != null && d(e, ["name"], n);
 const r = c(t, ["metadata"]);
 r != null && d(e, ["metadata"], r);
 const i = c(t, ["done"]);
 i != null && d(e, ["done"], i);
 const o = c(t, ["error"]);
 o != null && d(e, ["error"], o);
 const s = c(t, ["response"]);
 return s != null && d(e, ["response"], _9(s)), e;
}
function v9(t) {
 const e = {},
  n = c(t, ["fileSearchStoreName"]);
 n != null && d(e, ["_url", "file_search_store_name"], n);
 const r = c(t, ["fileName"]);
 r != null && d(e, ["fileName"], r);
 const i = c(t, ["config"]);
 return i != null && g9(i, e), e;
}
function _9(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["parent"]);
 r != null && d(e, ["parent"], r);
 const i = c(t, ["documentName"]);
 return i != null && d(e, ["documentName"], i), e;
}
function w9(t, e) {
 const n = {},
  r = c(t, ["pageSize"]);
 e !== void 0 && r != null && d(e, ["_query", "pageSize"], r);
 const i = c(t, ["pageToken"]);
 return e !== void 0 && i != null && d(e, ["_query", "pageToken"], i), n;
}
function E9(t) {
 const e = {},
  n = c(t, ["config"]);
 return n != null && w9(n, e), e;
}
function T9(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["nextPageToken"]);
 r != null && d(e, ["nextPageToken"], r);
 const i = c(t, ["fileSearchStores"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => s)), d(e, ["fileSearchStores"], o);
 }
 return e;
}
function Zk(t, e) {
 const n = {},
  r = c(t, ["mimeType"]);
 e !== void 0 && r != null && d(e, ["mimeType"], r);
 const i = c(t, ["displayName"]);
 e !== void 0 && i != null && d(e, ["displayName"], i);
 const o = c(t, ["customMetadata"]);
 if (e !== void 0 && o != null) {
  let a = o;
  Array.isArray(a) && (a = a.map((l) => l)), d(e, ["customMetadata"], a);
 }
 const s = c(t, ["chunkingConfig"]);
 return e !== void 0 && s != null && d(e, ["chunkingConfig"], s), n;
}
function I9(t) {
 const e = {},
  n = c(t, ["fileSearchStoreName"]);
 n != null && d(e, ["_url", "file_search_store_name"], n);
 const r = c(t, ["config"]);
 return r != null && Zk(r, e), e;
}
function S9(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 return n != null && d(e, ["sdkHttpResponse"], n), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const A9 = "Content-Type",
 C9 = "X-Server-Timeout",
 R9 = "User-Agent",
 Vm = "x-goog-api-client",
 P9 = "1.39.0",
 k9 = `google-genai-sdk/${P9}`,
 b9 = "v1beta1",
 N9 = "v1beta";
class x9 {
 constructor(e) {
  var n, r, i;
  (this.clientOptions = Object.assign({}, e)),
   (this.customBaseUrl = (n = e.httpOptions) === null || n === void 0 ? void 0 : n.baseUrl),
   this.clientOptions.vertexai &&
    (this.clientOptions.project && this.clientOptions.location
     ? (this.clientOptions.apiKey = void 0)
     : this.clientOptions.apiKey && ((this.clientOptions.project = void 0), (this.clientOptions.location = void 0)));
  const o = {};
  if (this.clientOptions.vertexai) {
   if (
    (!this.clientOptions.location &&
     !this.clientOptions.apiKey &&
     !this.customBaseUrl &&
     (this.clientOptions.location = "global"),
    !((this.clientOptions.project && this.clientOptions.location) || this.clientOptions.apiKey) && !this.customBaseUrl)
   )
    throw new Error(
     "Authentication is not set up. Please provide either a project and location, or an API key, or a custom base URL."
    );
   const a = (e.project && e.location) || !!e.apiKey;
   this.customBaseUrl && !a
    ? ((o.baseUrl = this.customBaseUrl), (this.clientOptions.project = void 0), (this.clientOptions.location = void 0))
    : this.clientOptions.apiKey || this.clientOptions.location === "global"
      ? (o.baseUrl = "https://aiplatform.googleapis.com/")
      : this.clientOptions.project &&
        this.clientOptions.location &&
        (o.baseUrl = `https://${this.clientOptions.location}-aiplatform.googleapis.com/`),
    (o.apiVersion = (r = this.clientOptions.apiVersion) !== null && r !== void 0 ? r : b9);
  } else {
   if (!this.clientOptions.apiKey)
    throw new Nl({ message: "API key must be set when using the Gemini API.", status: 403 });
   (o.apiVersion = (i = this.clientOptions.apiVersion) !== null && i !== void 0 ? i : N9),
    (o.baseUrl = "https://generativelanguage.googleapis.com/");
  }
  (o.headers = this.getDefaultHeaders()),
   (this.clientOptions.httpOptions = o),
   e.httpOptions && (this.clientOptions.httpOptions = this.patchHttpOptions(o, e.httpOptions));
 }
 isVertexAI() {
  var e;
  return (e = this.clientOptions.vertexai) !== null && e !== void 0 ? e : !1;
 }
 getProject() {
  return this.clientOptions.project;
 }
 getLocation() {
  return this.clientOptions.location;
 }
 getCustomBaseUrl() {
  return this.customBaseUrl;
 }
 async getAuthHeaders() {
  const e = new Headers();
  return await this.clientOptions.auth.addAuthHeaders(e), e;
 }
 getApiVersion() {
  if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0)
   return this.clientOptions.httpOptions.apiVersion;
  throw new Error("API version is not set.");
 }
 getBaseUrl() {
  if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0)
   return this.clientOptions.httpOptions.baseUrl;
  throw new Error("Base URL is not set.");
 }
 getRequestUrl() {
  return this.getRequestUrlInternal(this.clientOptions.httpOptions);
 }
 getHeaders() {
  if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0)
   return this.clientOptions.httpOptions.headers;
  throw new Error("Headers are not set.");
 }
 getRequestUrlInternal(e) {
  if (!e || e.baseUrl === void 0 || e.apiVersion === void 0) throw new Error("HTTP options are not correctly set.");
  const r = [e.baseUrl.endsWith("/") ? e.baseUrl.slice(0, -1) : e.baseUrl];
  return e.apiVersion && e.apiVersion !== "" && r.push(e.apiVersion), r.join("/");
 }
 getBaseResourcePath() {
  return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
 }
 getApiKey() {
  return this.clientOptions.apiKey;
 }
 getWebsocketBaseUrl() {
  const e = this.getBaseUrl(),
   n = new URL(e);
  return (n.protocol = n.protocol == "http:" ? "ws" : "wss"), n.toString();
 }
 setBaseUrl(e) {
  if (this.clientOptions.httpOptions) this.clientOptions.httpOptions.baseUrl = e;
  else throw new Error("HTTP options are not correctly set.");
 }
 constructUrl(e, n, r) {
  const i = [this.getRequestUrlInternal(n)];
  return r && i.push(this.getBaseResourcePath()), e !== "" && i.push(e), new URL(`${i.join("/")}`);
 }
 shouldPrependVertexProjectPath(e, n) {
  return !(
   (n.baseUrl && n.baseUrlResourceScope === bm.COLLECTION) ||
   this.clientOptions.apiKey ||
   !this.clientOptions.vertexai ||
   e.path.startsWith("projects/") ||
   (e.httpMethod === "GET" && e.path.startsWith("publishers/google/models"))
  );
 }
 async request(e) {
  let n = this.clientOptions.httpOptions;
  e.httpOptions && (n = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions));
  const r = this.shouldPrependVertexProjectPath(e, n),
   i = this.constructUrl(e.path, n, r);
  if (e.queryParams) for (const [s, a] of Object.entries(e.queryParams)) i.searchParams.append(s, String(a));
  let o = {};
  if (e.httpMethod === "GET") {
   if (e.body && e.body !== "{}")
    throw new Error("Request body should be empty for GET request, but got non empty request body");
  } else o.body = e.body;
  return (
   (o = await this.includeExtraHttpOptionsToRequestInit(o, n, i.toString(), e.abortSignal)),
   this.unaryApiCall(i, o, e.httpMethod)
  );
 }
 patchHttpOptions(e, n) {
  const r = JSON.parse(JSON.stringify(e));
  for (const [i, o] of Object.entries(n))
   typeof o == "object" ? (r[i] = Object.assign(Object.assign({}, r[i]), o)) : o !== void 0 && (r[i] = o);
  return r;
 }
 async requestStream(e) {
  let n = this.clientOptions.httpOptions;
  e.httpOptions && (n = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions));
  const r = this.shouldPrependVertexProjectPath(e, n),
   i = this.constructUrl(e.path, n, r);
  (!i.searchParams.has("alt") || i.searchParams.get("alt") !== "sse") && i.searchParams.set("alt", "sse");
  let o = {};
  return (
   (o.body = e.body),
   (o = await this.includeExtraHttpOptionsToRequestInit(o, n, i.toString(), e.abortSignal)),
   this.streamApiCall(i, o, e.httpMethod)
  );
 }
 async includeExtraHttpOptionsToRequestInit(e, n, r, i) {
  if ((n && n.timeout) || i) {
   const o = new AbortController(),
    s = o.signal;
   if (n.timeout && (n == null ? void 0 : n.timeout) > 0) {
    const a = setTimeout(() => o.abort(), n.timeout);
    a && typeof a.unref == "function" && a.unref();
   }
   i &&
    i.addEventListener("abort", () => {
     o.abort();
    }),
    (e.signal = s);
  }
  return n && n.extraBody !== null && M9(e, n.extraBody), (e.headers = await this.getHeadersInternal(n, r)), e;
 }
 async unaryApiCall(e, n, r) {
  return this.apiCall(e.toString(), Object.assign(Object.assign({}, n), { method: r }))
   .then(async (i) => (await XT(i), new Nm(i)))
   .catch((i) => {
    throw i instanceof Error ? i : new Error(JSON.stringify(i));
   });
 }
 async streamApiCall(e, n, r) {
  return this.apiCall(e.toString(), Object.assign(Object.assign({}, n), { method: r }))
   .then(async (i) => (await XT(i), this.processStreamResponse(i)))
   .catch((i) => {
    throw i instanceof Error ? i : new Error(JSON.stringify(i));
   });
 }
 processStreamResponse(e) {
  return Fn(this, arguments, function* () {
   var r;
   const i = (r = e == null ? void 0 : e.body) === null || r === void 0 ? void 0 : r.getReader(),
    o = new TextDecoder("utf-8");
   if (!i) throw new Error("Response body is empty");
   try {
    let s = "";
    const a = "data:",
     l = [
      `

`,
      "\r\r",
      `\r
\r
`,
     ];
    for (;;) {
     const { done: u, value: h } = yield ie(i.read());
     if (u) {
      if (s.trim().length > 0) throw new Error("Incomplete JSON segment at the end");
      break;
     }
     const p = o.decode(h, { stream: !0 });
     try {
      const w = JSON.parse(p);
      if ("error" in w) {
       const C = JSON.parse(JSON.stringify(w.error)),
        A = C.status,
        T = C.code,
        _ = `got status: ${A}. ${JSON.stringify(w)}`;
       if (T >= 400 && T < 600) throw new Nl({ message: _, status: T });
      }
     } catch (w) {
      if (w.name === "ApiError") throw w;
     }
     s += p;
     let m = -1,
      v = 0;
     for (;;) {
      (m = -1), (v = 0);
      for (const A of l) {
       const T = s.indexOf(A);
       T !== -1 && (m === -1 || T < m) && ((m = T), (v = A.length));
      }
      if (m === -1) break;
      const w = s.substring(0, m);
      s = s.substring(m + v);
      const C = w.trim();
      if (C.startsWith(a)) {
       const A = C.substring(a.length).trim();
       try {
        const T = new Response(A, {
         headers: e == null ? void 0 : e.headers,
         status: e == null ? void 0 : e.status,
         statusText: e == null ? void 0 : e.statusText,
        });
        yield yield ie(new Nm(T));
       } catch (T) {
        throw new Error(`exception parsing stream chunk ${A}. ${T}`);
       }
      }
     }
    }
   } finally {
    i.releaseLock();
   }
  });
 }
 async apiCall(e, n) {
  return fetch(e, n).catch((r) => {
   throw new Error(`exception ${r} sending request`);
  });
 }
 getDefaultHeaders() {
  const e = {},
   n = k9 + " " + this.clientOptions.userAgentExtra;
  return (e[R9] = n), (e[Vm] = n), (e[A9] = "application/json"), e;
 }
 async getHeadersInternal(e, n) {
  const r = new Headers();
  if (e && e.headers) {
   for (const [i, o] of Object.entries(e.headers)) r.append(i, o);
   e.timeout && e.timeout > 0 && r.append(C9, String(Math.ceil(e.timeout / 1e3)));
  }
  return await this.clientOptions.auth.addAuthHeaders(r, n), r;
 }
 getFileName(e) {
  var n;
  let r = "";
  return (
   typeof e == "string" &&
    ((r = e.replace(/[/\\]+$/, "")), (r = (n = r.split(/[/\\]/).pop()) !== null && n !== void 0 ? n : "")),
   r
  );
 }
 async uploadFile(e, n) {
  var r;
  const i = {};
  n != null && ((i.mimeType = n.mimeType), (i.name = n.name), (i.displayName = n.displayName)),
   i.name && !i.name.startsWith("files/") && (i.name = `files/${i.name}`);
  const o = this.clientOptions.uploader,
   s = await o.stat(e);
  i.sizeBytes = String(s.size);
  const a = (r = n == null ? void 0 : n.mimeType) !== null && r !== void 0 ? r : s.type;
  if (a === void 0 || a === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
  i.mimeType = a;
  const l = { file: i },
   u = this.getFileName(e),
   h = K("upload/v1beta/files", l._url),
   p = await this.fetchUploadUrl(h, i.sizeBytes, i.mimeType, u, l, n == null ? void 0 : n.httpOptions);
  return o.upload(e, p, this);
 }
 async uploadFileToFileSearchStore(e, n, r) {
  var i;
  const o = this.clientOptions.uploader,
   s = await o.stat(n),
   a = String(s.size),
   l = (i = r == null ? void 0 : r.mimeType) !== null && i !== void 0 ? i : s.type;
  if (l === void 0 || l === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
  const u = `upload/v1beta/${e}:uploadToFileSearchStore`,
   h = this.getFileName(n),
   p = {};
  r != null && Zk(r, p);
  const m = await this.fetchUploadUrl(u, a, l, h, p, r == null ? void 0 : r.httpOptions);
  return o.uploadToFileSearchStore(n, m, this);
 }
 async downloadFile(e) {
  await this.clientOptions.downloader.download(e, this);
 }
 async fetchUploadUrl(e, n, r, i, o, s) {
  var a;
  let l = {};
  s
   ? (l = s)
   : (l = {
      apiVersion: "",
      headers: Object.assign(
       {
        "Content-Type": "application/json",
        "X-Goog-Upload-Protocol": "resumable",
        "X-Goog-Upload-Command": "start",
        "X-Goog-Upload-Header-Content-Length": `${n}`,
        "X-Goog-Upload-Header-Content-Type": `${r}`,
       },
       i ? { "X-Goog-Upload-File-Name": i } : {}
      ),
     });
  const u = await this.request({ path: e, body: JSON.stringify(o), httpMethod: "POST", httpOptions: l });
  if (!u || !(u != null && u.headers))
   throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
  const h = (a = u == null ? void 0 : u.headers) === null || a === void 0 ? void 0 : a["x-goog-upload-url"];
  if (h === void 0)
   throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
  return h;
 }
}
async function XT(t) {
 var e;
 if (t === void 0) throw new Error("response is undefined");
 if (!t.ok) {
  const n = t.status;
  let r;
  !((e = t.headers.get("content-type")) === null || e === void 0) && e.includes("application/json")
   ? (r = await t.json())
   : (r = { error: { message: await t.text(), code: t.status, status: t.statusText } });
  const i = JSON.stringify(r);
  throw n >= 400 && n < 600 ? new Nl({ message: i, status: n }) : new Error(i);
 }
}
function M9(t, e) {
 if (!e || Object.keys(e).length === 0) return;
 if (t.body instanceof Blob) {
  console.warn(
   "includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies."
  );
  return;
 }
 let n = {};
 if (typeof t.body == "string" && t.body.length > 0)
  try {
   const o = JSON.parse(t.body);
   if (typeof o == "object" && o !== null && !Array.isArray(o)) n = o;
   else {
    console.warn(
     "includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body."
    );
    return;
   }
  } catch {
   console.warn(
    "includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body."
   );
   return;
  }
 function r(o, s) {
  const a = Object.assign({}, o);
  for (const l in s)
   if (Object.prototype.hasOwnProperty.call(s, l)) {
    const u = s[l],
     h = a[l];
    u && typeof u == "object" && !Array.isArray(u) && h && typeof h == "object" && !Array.isArray(h)
     ? (a[l] = r(h, u))
     : (h &&
        u &&
        typeof h != typeof u &&
        console.warn(
         `includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${l}". Original type: ${typeof h}, New type: ${typeof u}. Overwriting.`
        ),
       (a[l] = u));
   }
  return a;
 }
 const i = r(n, e);
 t.body = JSON.stringify(i);
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const D9 = "mcp_used/unknown";
let L9 = !1;
function eb(t) {
 for (const e of t) if (V9(e) || (typeof e == "object" && "inputSchema" in e)) return !0;
 return L9;
}
function tb(t) {
 var e;
 const n = (e = t[Vm]) !== null && e !== void 0 ? e : "";
 t[Vm] = (n + ` ${D9}`).trimStart();
}
function V9(t) {
 return t !== null && typeof t == "object" && t instanceof Ev;
}
function U9(t) {
 return Fn(this, arguments, function* (n, r = 100) {
  let i,
   o = 0;
  for (; o < r; ) {
   const s = yield ie(n.listTools({ cursor: i }));
   for (const a of s.tools) yield yield ie(a), o++;
   if (!s.nextCursor) break;
   i = s.nextCursor;
  }
 });
}
class Ev {
 constructor(e = [], n) {
  (this.mcpTools = []), (this.functionNameToMcpClient = {}), (this.mcpClients = e), (this.config = n);
 }
 static create(e, n) {
  return new Ev(e, n);
 }
 async initialize() {
  var e, n, r, i;
  if (this.mcpTools.length > 0) return;
  const o = {},
   s = [];
  for (const h of this.mcpClients)
   try {
    for (var a = !0, l = ((n = void 0), Bn(U9(h))), u; (u = await l.next()), (e = u.done), !e; a = !0) {
     (i = u.value), (a = !1);
     const p = i;
     s.push(p);
     const m = p.name;
     if (o[m])
      throw new Error(`Duplicate function name ${m} found in MCP tools. Please ensure function names are unique.`);
     o[m] = h;
    }
   } catch (p) {
    n = { error: p };
   } finally {
    try {
     !a && !e && (r = l.return) && (await r.call(l));
    } finally {
     if (n) throw n.error;
    }
   }
  (this.mcpTools = s), (this.functionNameToMcpClient = o);
 }
 async tool() {
  return await this.initialize(), f5(this.mcpTools, this.config);
 }
 async callTool(e) {
  await this.initialize();
  const n = [];
  for (const r of e)
   if (r.name in this.functionNameToMcpClient) {
    const i = this.functionNameToMcpClient[r.name];
    let o;
    this.config.timeout && (o = { timeout: this.config.timeout });
    const s = await i.callTool({ name: r.name, arguments: r.args }, void 0, o);
    n.push({ functionResponse: { name: r.name, response: s.isError ? { error: s } : s } });
   }
  return n;
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ async function O9(t, e, n) {
 const r = new i5();
 let i;
 n.data instanceof Blob ? (i = JSON.parse(await n.data.text())) : (i = JSON.parse(n.data)), Object.assign(r, i), e(r);
}
class F9 {
 constructor(e, n, r) {
  (this.apiClient = e), (this.auth = n), (this.webSocketFactory = r);
 }
 async connect(e) {
  var n, r;
  if (this.apiClient.isVertexAI()) throw new Error("Live music is not supported for Vertex AI.");
  console.warn("Live music generation is experimental and may change in future versions.");
  const i = this.apiClient.getWebsocketBaseUrl(),
   o = this.apiClient.getApiVersion(),
   s = H9(this.apiClient.getDefaultHeaders()),
   a = this.apiClient.getApiKey(),
   l = `${i}/ws/google.ai.generativelanguage.${o}.GenerativeService.BidiGenerateMusic?key=${a}`;
  let u = () => {};
  const h = new Promise((E) => {
    u = E;
   }),
   p = e.callbacks,
   m = function () {
    u({});
   },
   v = this.apiClient,
   w = {
    onopen: m,
    onmessage: (E) => {
     O9(v, p.onmessage, E);
    },
    onerror: (n = p == null ? void 0 : p.onerror) !== null && n !== void 0 ? n : function (E) {},
    onclose: (r = p == null ? void 0 : p.onclose) !== null && r !== void 0 ? r : function (E) {},
   },
   C = this.webSocketFactory.create(l, $9(s), w);
  C.connect(), await h;
  const _ = { setup: { model: ye(this.apiClient, e.model) } };
  return C.send(JSON.stringify(_)), new B9(C, this.apiClient);
 }
}
class B9 {
 constructor(e, n) {
  (this.conn = e), (this.apiClient = n);
 }
 async setWeightedPrompts(e) {
  if (!e.weightedPrompts || Object.keys(e.weightedPrompts).length === 0)
   throw new Error("Weighted prompts must be set and contain at least one entry.");
  const n = dz(e);
  this.conn.send(JSON.stringify({ clientContent: n }));
 }
 async setMusicGenerationConfig(e) {
  e.musicGenerationConfig || (e.musicGenerationConfig = {});
  const n = cz(e);
  this.conn.send(JSON.stringify(n));
 }
 sendPlaybackControl(e) {
  const n = { playbackControl: e };
  this.conn.send(JSON.stringify(n));
 }
 play() {
  this.sendPlaybackControl(is.PLAY);
 }
 pause() {
  this.sendPlaybackControl(is.PAUSE);
 }
 stop() {
  this.sendPlaybackControl(is.STOP);
 }
 resetContext() {
  this.sendPlaybackControl(is.RESET_CONTEXT);
 }
 close() {
  this.conn.close();
 }
}
function $9(t) {
 const e = {};
 return (
  t.forEach((n, r) => {
   e[r] = n;
  }),
  e
 );
}
function H9(t) {
 const e = new Headers();
 for (const [n, r] of Object.entries(t)) e.append(n, r);
 return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const q9 =
 "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
async function G9(t, e, n) {
 const r = new r5();
 let i;
 n.data instanceof Blob
  ? (i = await n.data.text())
  : n.data instanceof ArrayBuffer
    ? (i = new TextDecoder().decode(n.data))
    : (i = n.data);
 const o = JSON.parse(i);
 if (t.isVertexAI()) {
  const s = pz(o);
  Object.assign(r, s);
 } else Object.assign(r, o);
 e(r);
}
class z9 {
 constructor(e, n, r) {
  (this.apiClient = e),
   (this.auth = n),
   (this.webSocketFactory = r),
   (this.music = new F9(this.apiClient, this.auth, this.webSocketFactory));
 }
 async connect(e) {
  var n, r, i, o, s, a;
  if (e.config && e.config.httpOptions)
   throw new Error(
    "The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead."
   );
  const l = this.apiClient.getWebsocketBaseUrl(),
   u = this.apiClient.getApiVersion();
  let h;
  const p = this.apiClient.getHeaders();
  e.config && e.config.tools && eb(e.config.tools) && tb(p);
  const m = Y9(p);
  if (this.apiClient.isVertexAI()) {
   const R = this.apiClient.getProject(),
    k = this.apiClient.getLocation(),
    x = this.apiClient.getApiKey(),
    D = (!!R && !!k) || !!x;
   this.apiClient.getCustomBaseUrl() && !D
    ? (h = l)
    : ((h = `${l}/ws/google.cloud.aiplatform.${u}.LlmBidiService/BidiGenerateContent`),
      await this.auth.addAuthHeaders(m, h));
  } else {
   const R = this.apiClient.getApiKey();
   let k = "BidiGenerateContent",
    x = "key";
   R != null &&
    R.startsWith("auth_tokens/") &&
    (console.warn("Warning: Ephemeral token support is experimental and may change in future versions."),
    u !== "v1alpha" &&
     console.warn(
      "Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection."
     ),
    (k = "BidiGenerateContentConstrained"),
    (x = "access_token")),
    (h = `${l}/ws/google.ai.generativelanguage.${u}.GenerativeService.${k}?${x}=${R}`);
  }
  let v = () => {};
  const w = new Promise((R) => {
    v = R;
   }),
   C = e.callbacks,
   A = function () {
    var R;
    (R = C == null ? void 0 : C.onopen) === null || R === void 0 || R.call(C), v({});
   },
   T = this.apiClient,
   _ = {
    onopen: A,
    onmessage: (R) => {
     G9(T, C.onmessage, R);
    },
    onerror: (n = C == null ? void 0 : C.onerror) !== null && n !== void 0 ? n : function (R) {},
    onclose: (r = C == null ? void 0 : C.onclose) !== null && r !== void 0 ? r : function (R) {},
   },
   E = this.webSocketFactory.create(h, J9(m), _);
  E.connect(), await w;
  let N = ye(this.apiClient, e.model);
  if (this.apiClient.isVertexAI() && N.startsWith("publishers/")) {
   const R = this.apiClient.getProject(),
    k = this.apiClient.getLocation();
   R && k && (N = `projects/${R}/locations/${k}/` + N);
  }
  let M = {};
  this.apiClient.isVertexAI() &&
   ((i = e.config) === null || i === void 0 ? void 0 : i.responseModalities) === void 0 &&
   (e.config === void 0 ? (e.config = { responseModalities: [Rd.AUDIO] }) : (e.config.responseModalities = [Rd.AUDIO])),
   !((o = e.config) === null || o === void 0) &&
    o.generationConfig &&
    console.warn(
     "Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025)."
    );
  const F = (a = (s = e.config) === null || s === void 0 ? void 0 : s.tools) !== null && a !== void 0 ? a : [],
   P = [];
  for (const R of F)
   if (this.isCallableTool(R)) {
    const k = R;
    P.push(await k.tool());
   } else P.push(R);
  P.length > 0 && (e.config.tools = P);
  const I = { model: N, config: e.config, callbacks: e.callbacks };
  return (
   this.apiClient.isVertexAI() ? (M = uz(this.apiClient, I)) : (M = lz(this.apiClient, I)),
   delete M.config,
   E.send(JSON.stringify(M)),
   new K9(E, this.apiClient)
  );
 }
 isCallableTool(e) {
  return "callTool" in e && typeof e.callTool == "function";
 }
}
const W9 = { turnComplete: !0 };
class K9 {
 constructor(e, n) {
  (this.conn = e), (this.apiClient = n);
 }
 tLiveClientContent(e, n) {
  if (n.turns !== null && n.turns !== void 0) {
   let r = [];
   try {
    (r = Sn(n.turns)), e.isVertexAI() || (r = r.map((i) => Pf(i)));
   } catch {
    throw new Error(`Failed to parse client content "turns", type: '${typeof n.turns}'`);
   }
   return { clientContent: { turns: r, turnComplete: n.turnComplete } };
  }
  return { clientContent: { turnComplete: n.turnComplete } };
 }
 tLiveClienttToolResponse(e, n) {
  let r = [];
  if (n.functionResponses == null) throw new Error("functionResponses is required.");
  if ((Array.isArray(n.functionResponses) ? (r = n.functionResponses) : (r = [n.functionResponses]), r.length === 0))
   throw new Error("functionResponses is required.");
  for (const o of r) {
   if (typeof o != "object" || o === null || !("name" in o) || !("response" in o))
    throw new Error(`Could not parse function response, type '${typeof o}'.`);
   if (!e.isVertexAI() && !("id" in o)) throw new Error(q9);
  }
  return { toolResponse: { functionResponses: r } };
 }
 sendClientContent(e) {
  e = Object.assign(Object.assign({}, W9), e);
  const n = this.tLiveClientContent(this.apiClient, e);
  this.conn.send(JSON.stringify(n));
 }
 sendRealtimeInput(e) {
  let n = {};
  this.apiClient.isVertexAI() ? (n = { realtimeInput: hz(e) }) : (n = { realtimeInput: fz(e) }),
   this.conn.send(JSON.stringify(n));
 }
 sendToolResponse(e) {
  if (e.functionResponses == null) throw new Error("Tool response parameters are required.");
  const n = this.tLiveClienttToolResponse(this.apiClient, e);
  this.conn.send(JSON.stringify(n));
 }
 close() {
  this.conn.close();
 }
}
function J9(t) {
 const e = {};
 return (
  t.forEach((n, r) => {
   e[r] = n;
  }),
  e
 );
}
function Y9(t) {
 const e = new Headers();
 for (const [n, r] of Object.entries(t)) e.append(n, r);
 return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const jT = 10;
function ZT(t) {
 var e, n, r;
 if (!((e = t == null ? void 0 : t.automaticFunctionCalling) === null || e === void 0) && e.disable) return !0;
 let i = !1;
 for (const s of (n = t == null ? void 0 : t.tools) !== null && n !== void 0 ? n : [])
  if (vs(s)) {
   i = !0;
   break;
  }
 if (!i) return !0;
 const o =
  (r = t == null ? void 0 : t.automaticFunctionCalling) === null || r === void 0 ? void 0 : r.maximumRemoteCalls;
 return (o && (o < 0 || !Number.isInteger(o))) || o == 0
  ? (console.warn(
     "Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:",
     o
    ),
    !0)
  : !1;
}
function vs(t) {
 return "callTool" in t && typeof t.callTool == "function";
}
function Q9(t) {
 var e, n, r;
 return (r =
  (n = (e = t.config) === null || e === void 0 ? void 0 : e.tools) === null || n === void 0
   ? void 0
   : n.some((i) => vs(i))) !== null && r !== void 0
  ? r
  : !1;
}
function eI(t) {
 var e;
 const n = [];
 return (
  !((e = t == null ? void 0 : t.config) === null || e === void 0) &&
   e.tools &&
   t.config.tools.forEach((r, i) => {
    if (vs(r)) return;
    const o = r;
    o.functionDeclarations && o.functionDeclarations.length > 0 && n.push(i);
   }),
  n
 );
}
function tI(t) {
 var e;
 return !(!((e = t == null ? void 0 : t.automaticFunctionCalling) === null || e === void 0) && e.ignoreCallHistory);
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class X9 extends Fr {
 constructor(e) {
  super(),
   (this.apiClient = e),
   (this.generateContent = async (n) => {
    var r, i, o, s, a;
    const l = await this.processParamsMaybeAddMcpUsage(n);
    if ((this.maybeMoveToResponseJsonSchem(n), !Q9(n) || ZT(n.config))) return await this.generateContentInternal(l);
    const u = eI(n);
    if (u.length > 0) {
     const C = u.map((A) => `tools[${A}]`).join(", ");
     throw new Error(
      `Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${C}.`
     );
    }
    let h, p;
    const m = Sn(l.contents),
     v =
      (o =
       (i = (r = l.config) === null || r === void 0 ? void 0 : r.automaticFunctionCalling) === null || i === void 0
        ? void 0
        : i.maximumRemoteCalls) !== null && o !== void 0
       ? o
       : jT;
    let w = 0;
    for (
     ;
     w < v && ((h = await this.generateContentInternal(l)), !(!h.functionCalls || h.functionCalls.length === 0));

    ) {
     const C = h.candidates[0].content,
      A = [];
     for (const T of (a = (s = n.config) === null || s === void 0 ? void 0 : s.tools) !== null && a !== void 0 ? a : [])
      if (vs(T)) {
       const E = await T.callTool(h.functionCalls);
       A.push(...E);
      }
     w++,
      (p = { role: "user", parts: A }),
      (l.contents = Sn(l.contents)),
      l.contents.push(C),
      l.contents.push(p),
      tI(l.config) && (m.push(C), m.push(p));
    }
    return tI(l.config) && (h.automaticFunctionCallingHistory = m), h;
   }),
   (this.generateContentStream = async (n) => {
    var r, i, o, s, a;
    if ((this.maybeMoveToResponseJsonSchem(n), ZT(n.config))) {
     const p = await this.processParamsMaybeAddMcpUsage(n);
     return await this.generateContentStreamInternal(p);
    }
    const l = eI(n);
    if (l.length > 0) {
     const p = l.map((m) => `tools[${m}]`).join(", ");
     throw new Error(
      `Incompatible tools found at ${p}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`
     );
    }
    const u =
      (o =
       (i = (r = n == null ? void 0 : n.config) === null || r === void 0 ? void 0 : r.toolConfig) === null ||
       i === void 0
        ? void 0
        : i.functionCallingConfig) === null || o === void 0
       ? void 0
       : o.streamFunctionCallArguments,
     h =
      (a = (s = n == null ? void 0 : n.config) === null || s === void 0 ? void 0 : s.automaticFunctionCalling) ===
       null || a === void 0
       ? void 0
       : a.disable;
    if (u && !h)
     throw new Error(
      "Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature."
     );
    return await this.processAfcStream(n);
   }),
   (this.generateImages = async (n) =>
    await this.generateImagesInternal(n).then((r) => {
     var i;
     let o;
     const s = [];
     if (r != null && r.generatedImages)
      for (const l of r.generatedImages)
       l &&
       l != null &&
       l.safetyAttributes &&
       ((i = l == null ? void 0 : l.safetyAttributes) === null || i === void 0 ? void 0 : i.contentType) ===
        "Positive Prompt"
        ? (o = l == null ? void 0 : l.safetyAttributes)
        : s.push(l);
     let a;
     return (
      o
       ? (a = { generatedImages: s, positivePromptSafetyAttributes: o, sdkHttpResponse: r.sdkHttpResponse })
       : (a = { generatedImages: s, sdkHttpResponse: r.sdkHttpResponse }),
      a
     );
    })),
   (this.list = async (n) => {
    var r;
    const s = { config: Object.assign(Object.assign({}, { queryBase: !0 }), n == null ? void 0 : n.config) };
    if (this.apiClient.isVertexAI() && !s.config.queryBase) {
     if (!((r = s.config) === null || r === void 0) && r.filter)
      throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
     s.config.filter = "labels.tune-type:*";
    }
    return new Mo(Dr.PAGED_ITEM_MODELS, (a) => this.listInternal(a), await this.listInternal(s), s);
   }),
   (this.editImage = async (n) => {
    const r = { model: n.model, prompt: n.prompt, referenceImages: [], config: n.config };
    return (
     n.referenceImages &&
      n.referenceImages &&
      (r.referenceImages = n.referenceImages.map((i) => i.toReferenceImageAPI())),
     await this.editImageInternal(r)
    );
   }),
   (this.upscaleImage = async (n) => {
    let r = { numberOfImages: 1, mode: "upscale" };
    n.config && (r = Object.assign(Object.assign({}, r), n.config));
    const i = { model: n.model, image: n.image, upscaleFactor: n.upscaleFactor, config: r };
    return await this.upscaleImageInternal(i);
   }),
   (this.generateVideos = async (n) => {
    var r, i, o, s, a, l;
    if ((n.prompt || n.image || n.video) && n.source)
     throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
    return (
     this.apiClient.isVertexAI() ||
      (!((r = n.video) === null || r === void 0) && r.uri && !((i = n.video) === null || i === void 0) && i.videoBytes
       ? (n.video = { uri: n.video.uri, mimeType: n.video.mimeType })
       : !((s = (o = n.source) === null || o === void 0 ? void 0 : o.video) === null || s === void 0) &&
         s.uri &&
         !((l = (a = n.source) === null || a === void 0 ? void 0 : a.video) === null || l === void 0) &&
         l.videoBytes &&
         (n.source.video = { uri: n.source.video.uri, mimeType: n.source.video.mimeType })),
     await this.generateVideosInternal(n)
    );
   });
 }
 maybeMoveToResponseJsonSchem(e) {
  e.config &&
   e.config.responseSchema &&
   (e.config.responseJsonSchema ||
    (Object.keys(e.config.responseSchema).includes("$schema") &&
     ((e.config.responseJsonSchema = e.config.responseSchema), delete e.config.responseSchema)));
 }
 async processParamsMaybeAddMcpUsage(e) {
  var n, r, i;
  const o = (n = e.config) === null || n === void 0 ? void 0 : n.tools;
  if (!o) return e;
  const s = await Promise.all(o.map(async (l) => (vs(l) ? await l.tool() : l))),
   a = { model: e.model, contents: e.contents, config: Object.assign(Object.assign({}, e.config), { tools: s }) };
  if (((a.config.tools = s), e.config && e.config.tools && eb(e.config.tools))) {
   const l =
    (i = (r = e.config.httpOptions) === null || r === void 0 ? void 0 : r.headers) !== null && i !== void 0 ? i : {};
   let u = Object.assign({}, l);
   Object.keys(u).length === 0 && (u = this.apiClient.getDefaultHeaders()),
    tb(u),
    (a.config.httpOptions = Object.assign(Object.assign({}, e.config.httpOptions), { headers: u }));
  }
  return a;
 }
 async initAfcToolsMap(e) {
  var n, r, i;
  const o = new Map();
  for (const s of (r = (n = e.config) === null || n === void 0 ? void 0 : n.tools) !== null && r !== void 0 ? r : [])
   if (vs(s)) {
    const a = s,
     l = await a.tool();
    for (const u of (i = l.functionDeclarations) !== null && i !== void 0 ? i : []) {
     if (!u.name) throw new Error("Function declaration name is required.");
     if (o.has(u.name)) throw new Error(`Duplicate tool declaration name: ${u.name}`);
     o.set(u.name, a);
    }
   }
  return o;
 }
 async processAfcStream(e) {
  var n, r, i;
  const o =
   (i =
    (r = (n = e.config) === null || n === void 0 ? void 0 : n.automaticFunctionCalling) === null || r === void 0
     ? void 0
     : r.maximumRemoteCalls) !== null && i !== void 0
    ? i
    : jT;
  let s = !1,
   a = 0;
  const l = await this.initAfcToolsMap(e);
  return (function (u, h, p) {
   return Fn(this, arguments, function* () {
    for (var m, v, w, C, A, T; a < o; ) {
     s && (a++, (s = !1));
     const M = yield ie(u.processParamsMaybeAddMcpUsage(p)),
      F = yield ie(u.generateContentStreamInternal(M)),
      P = [],
      I = [];
     try {
      for (var _ = !0, E = ((v = void 0), Bn(F)), N; (N = yield ie(E.next())), (m = N.done), !m; _ = !0) {
       (C = N.value), (_ = !1);
       const R = C;
       if ((yield yield ie(R), R.candidates && !((A = R.candidates[0]) === null || A === void 0) && A.content)) {
        I.push(R.candidates[0].content);
        for (const k of (T = R.candidates[0].content.parts) !== null && T !== void 0 ? T : [])
         if (a < o && k.functionCall) {
          if (!k.functionCall.name) throw new Error("Function call name was not returned by the model.");
          if (h.has(k.functionCall.name)) {
           const x = yield ie(h.get(k.functionCall.name).callTool([k.functionCall]));
           P.push(...x);
          } else
           throw new Error(
            `Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${h.keys()}, mising tool: ${k.functionCall.name}`
           );
         }
       }
      }
     } catch (R) {
      v = { error: R };
     } finally {
      try {
       !_ && !m && (w = E.return) && (yield ie(w.call(E)));
      } finally {
       if (v) throw v.error;
      }
     }
     if (P.length > 0) {
      s = !0;
      const R = new Sa();
      (R.candidates = [{ content: { role: "user", parts: P } }]), yield yield ie(R);
      const k = [];
      k.push(...I), k.push({ role: "user", parts: P });
      const x = Sn(p.contents).concat(k);
      p.contents = x;
     } else break;
    }
   });
  })(this, l, e);
 }
 async generateContentInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = JT(this.apiClient, e);
   return (
    (a = K("{model}:generateContent", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = QT(h),
      m = new Sa();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = KT(this.apiClient, e);
   return (
    (a = K("{model}:generateContent", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = YT(h),
      m = new Sa();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async generateContentStreamInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = JT(this.apiClient, e);
   return (
    (a = K("{model}:streamGenerateContent?alt=sse", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient.requestStream({
     path: a,
     queryParams: l,
     body: JSON.stringify(u),
     httpMethod: "POST",
     httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
     abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
    })),
    s.then(function (p) {
     return Fn(this, arguments, function* () {
      var m, v, w, C;
      try {
       for (var A = !0, T = Bn(p), _; (_ = yield ie(T.next())), (m = _.done), !m; A = !0) {
        (C = _.value), (A = !1);
        const E = C,
         N = QT(yield ie(E.json()), e);
        N.sdkHttpResponse = { headers: E.headers };
        const M = new Sa();
        Object.assign(M, N), yield yield ie(M);
       }
      } catch (E) {
       v = { error: E };
      } finally {
       try {
        !A && !m && (w = T.return) && (yield ie(w.call(T)));
       } finally {
        if (v) throw v.error;
       }
      }
     });
    })
   );
  } else {
   const u = KT(this.apiClient, e);
   return (
    (a = K("{model}:streamGenerateContent?alt=sse", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient.requestStream({
     path: a,
     queryParams: l,
     body: JSON.stringify(u),
     httpMethod: "POST",
     httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
     abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
    })),
    s.then(function (p) {
     return Fn(this, arguments, function* () {
      var m, v, w, C;
      try {
       for (var A = !0, T = Bn(p), _; (_ = yield ie(T.next())), (m = _.done), !m; A = !0) {
        (C = _.value), (A = !1);
        const E = C,
         N = YT(yield ie(E.json()), e);
        N.sdkHttpResponse = { headers: E.headers };
        const M = new Sa();
        Object.assign(M, N), yield yield ie(M);
       }
      } catch (E) {
       v = { error: E };
      } finally {
       try {
        !A && !m && (w = T.return) && (yield ie(w.call(T)));
       } finally {
        if (v) throw v.error;
       }
      }
     });
    })
   );
  }
 }
 async embedContent(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = zz(this.apiClient, e);
   return (
    (a = K("{model}:predict", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = Kz(h),
      m = new bT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = Gz(this.apiClient, e);
   return (
    (a = K("{model}:batchEmbedContents", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = Wz(h),
      m = new bT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async generateImagesInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = i6(this.apiClient, e);
   return (
    (a = K("{model}:predict", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = s6(h),
      m = new NT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = r6(this.apiClient, e);
   return (
    (a = K("{model}:predict", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = o6(h),
      m = new NT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async editImageInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) {
   const a = Bz(this.apiClient, e);
   return (
    (o = K("{model}:predict", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) =>
      l.json().then((u) => {
       const h = u;
       return (h.sdkHttpResponse = { headers: l.headers }), h;
      })
     )),
    i.then((l) => {
     const u = $z(l),
      h = new zG();
     return Object.assign(h, u), h;
    })
   );
  } else throw new Error("This method is only supported by the Vertex AI.");
 }
 async upscaleImageInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) {
   const a = i9(this.apiClient, e);
   return (
    (o = K("{model}:predict", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) =>
      l.json().then((u) => {
       const h = u;
       return (h.sdkHttpResponse = { headers: l.headers }), h;
      })
     )),
    i.then((l) => {
     const u = o9(l),
      h = new WG();
     return Object.assign(h, u), h;
    })
   );
  } else throw new Error("This method is only supported by the Vertex AI.");
 }
 async recontextImage(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) {
   const a = F6(this.apiClient, e);
   return (
    (o = K("{model}:predict", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => {
     const u = B6(l),
      h = new KG();
     return Object.assign(h, u), h;
    })
   );
  } else throw new Error("This method is only supported by the Vertex AI.");
 }
 async segmentImage(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) {
   const a = W6(this.apiClient, e);
   return (
    (o = K("{model}:predict", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => {
     const u = K6(l),
      h = new JG();
     return Object.assign(h, u), h;
    })
   );
  } else throw new Error("This method is only supported by the Vertex AI.");
 }
 async get(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = I6(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => Lm(h))
   );
  } else {
   const u = T6(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => Dm(h))
   );
  }
 }
 async listInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = x6(this.apiClient, e);
   return (
    (a = K("{models_url}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = D6(h),
      m = new xT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = N6(this.apiClient, e);
   return (
    (a = K("{models_url}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = M6(h),
      m = new xT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async update(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = n9(this.apiClient, e);
   return (
    (a = K("{model}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "PATCH",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => Lm(h))
   );
  } else {
   const u = t9(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "PATCH",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => Dm(h))
   );
  }
 }
 async delete(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = Vz(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "DELETE",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = Oz(h),
      m = new MT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = Lz(this.apiClient, e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "DELETE",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = Uz(h),
      m = new MT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async countTokens(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = xz(this.apiClient, e);
   return (
    (a = K("{model}:countTokens", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = Dz(h),
      m = new DT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = Nz(this.apiClient, e);
   return (
    (a = K("{model}:countTokens", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = Mz(h),
      m = new DT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async computeTokens(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) {
   const a = Sz(this.apiClient, e);
   return (
    (o = K("{model}:computeTokens", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) =>
      l.json().then((u) => {
       const h = u;
       return (h.sdkHttpResponse = { headers: l.headers }), h;
      })
     )),
    i.then((l) => {
     const u = Az(l),
      h = new YG();
     return Object.assign(h, u), h;
    })
   );
  } else throw new Error("This method is only supported by the Vertex AI.");
 }
 async generateVideosInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = f6(this.apiClient, e);
   return (
    (a = K("{model}:predictLongRunning", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => {
     const p = c6(h),
      m = new Pd();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = d6(this.apiClient, e);
   return (
    (a = K("{model}:predictLongRunning", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) => h.json())),
    s.then((h) => {
     const p = u6(h),
      m = new Pd();
     return Object.assign(m, p), m;
    })
   );
  }
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class j9 extends Fr {
 constructor(e) {
  super(), (this.apiClient = e);
 }
 async getVideosOperation(e) {
  const n = e.operation,
   r = e.config;
  if (n.name === void 0 || n.name === "") throw new Error("Operation name is required.");
  if (this.apiClient.isVertexAI()) {
   const i = n.name.split("/operations/")[0];
   let o;
   r && "httpOptions" in r && (o = r.httpOptions);
   const s = await this.fetchPredictVideosOperationInternal({
    operationName: n.name,
    resourceName: i,
    config: { httpOptions: o },
   });
   return n._fromAPIResponse({ apiResponse: s, _isVertexAI: !0 });
  } else {
   const i = await this.getVideosOperationInternal({ operationName: n.name, config: r });
   return n._fromAPIResponse({ apiResponse: i, _isVertexAI: !1 });
  }
 }
 async get(e) {
  const n = e.operation,
   r = e.config;
  if (n.name === void 0 || n.name === "") throw new Error("Operation name is required.");
  if (this.apiClient.isVertexAI()) {
   const i = n.name.split("/operations/")[0];
   let o;
   r && "httpOptions" in r && (o = r.httpOptions);
   const s = await this.fetchPredictVideosOperationInternal({
    operationName: n.name,
    resourceName: i,
    config: { httpOptions: o },
   });
   return n._fromAPIResponse({ apiResponse: s, _isVertexAI: !0 });
  } else {
   const i = await this.getVideosOperationInternal({ operationName: n.name, config: r });
   return n._fromAPIResponse({ apiResponse: i, _isVertexAI: !1 });
  }
 }
 async getVideosOperationInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = FG(e);
   return (
    (a = K("{operationName}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) => h.json())),
    s
   );
  } else {
   const u = OG(e);
   return (
    (a = K("{operationName}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) => h.json())),
    s
   );
  }
 }
 async fetchPredictVideosOperationInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) {
   const a = NG(e);
   return (
    (o = K("{resourceName}:fetchPredictOperation", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i
   );
  } else throw new Error("This method is only supported by the Vertex AI.");
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function Z9(t) {
 const e = {},
  n = c(t, ["data"]);
 if ((n != null && d(e, ["data"], n), c(t, ["displayName"]) !== void 0))
  throw new Error("displayName parameter is not supported in Gemini API.");
 const r = c(t, ["mimeType"]);
 return r != null && d(e, ["mimeType"], r), e;
}
function eW(t) {
 const e = {},
  n = c(t, ["parts"]);
 if (n != null) {
  let i = n;
  Array.isArray(i) && (i = i.map((o) => uW(o))), d(e, ["parts"], i);
 }
 const r = c(t, ["role"]);
 return r != null && d(e, ["role"], r), e;
}
function tW(t, e, n) {
 const r = {},
  i = c(e, ["expireTime"]);
 n !== void 0 && i != null && d(n, ["expireTime"], i);
 const o = c(e, ["newSessionExpireTime"]);
 n !== void 0 && o != null && d(n, ["newSessionExpireTime"], o);
 const s = c(e, ["uses"]);
 n !== void 0 && s != null && d(n, ["uses"], s);
 const a = c(e, ["liveConnectConstraints"]);
 n !== void 0 && a != null && d(n, ["bidiGenerateContentSetup"], lW(t, a));
 const l = c(e, ["lockAdditionalFields"]);
 return n !== void 0 && l != null && d(n, ["fieldMask"], l), r;
}
function nW(t, e) {
 const n = {},
  r = c(e, ["config"]);
 return r != null && d(n, ["config"], tW(t, r, n)), n;
}
function rW(t) {
 const e = {};
 if (c(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
 const n = c(t, ["fileUri"]);
 n != null && d(e, ["fileUri"], n);
 const r = c(t, ["mimeType"]);
 return r != null && d(e, ["mimeType"], r), e;
}
function iW(t) {
 const e = {},
  n = c(t, ["id"]);
 n != null && d(e, ["id"], n);
 const r = c(t, ["args"]);
 r != null && d(e, ["args"], r);
 const i = c(t, ["name"]);
 if ((i != null && d(e, ["name"], i), c(t, ["partialArgs"]) !== void 0))
  throw new Error("partialArgs parameter is not supported in Gemini API.");
 if (c(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
 return e;
}
function oW(t) {
 const e = {};
 if (c(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
 const n = c(t, ["enableWidget"]);
 return n != null && d(e, ["enableWidget"], n), e;
}
function sW(t) {
 const e = {};
 if (c(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
 if (c(t, ["blockingConfidence"]) !== void 0)
  throw new Error("blockingConfidence parameter is not supported in Gemini API.");
 const n = c(t, ["timeRangeFilter"]);
 return n != null && d(e, ["timeRangeFilter"], n), e;
}
function aW(t, e) {
 const n = {},
  r = c(t, ["generationConfig"]);
 e !== void 0 && r != null && d(e, ["setup", "generationConfig"], r);
 const i = c(t, ["responseModalities"]);
 e !== void 0 && i != null && d(e, ["setup", "generationConfig", "responseModalities"], i);
 const o = c(t, ["temperature"]);
 e !== void 0 && o != null && d(e, ["setup", "generationConfig", "temperature"], o);
 const s = c(t, ["topP"]);
 e !== void 0 && s != null && d(e, ["setup", "generationConfig", "topP"], s);
 const a = c(t, ["topK"]);
 e !== void 0 && a != null && d(e, ["setup", "generationConfig", "topK"], a);
 const l = c(t, ["maxOutputTokens"]);
 e !== void 0 && l != null && d(e, ["setup", "generationConfig", "maxOutputTokens"], l);
 const u = c(t, ["mediaResolution"]);
 e !== void 0 && u != null && d(e, ["setup", "generationConfig", "mediaResolution"], u);
 const h = c(t, ["seed"]);
 e !== void 0 && h != null && d(e, ["setup", "generationConfig", "seed"], h);
 const p = c(t, ["speechConfig"]);
 e !== void 0 && p != null && d(e, ["setup", "generationConfig", "speechConfig"], wv(p));
 const m = c(t, ["thinkingConfig"]);
 e !== void 0 && m != null && d(e, ["setup", "generationConfig", "thinkingConfig"], m);
 const v = c(t, ["enableAffectiveDialog"]);
 e !== void 0 && v != null && d(e, ["setup", "generationConfig", "enableAffectiveDialog"], v);
 const w = c(t, ["systemInstruction"]);
 e !== void 0 && w != null && d(e, ["setup", "systemInstruction"], eW(bt(w)));
 const C = c(t, ["tools"]);
 if (e !== void 0 && C != null) {
  let F = Xs(C);
  Array.isArray(F) && (F = F.map((P) => dW(Qs(P)))), d(e, ["setup", "tools"], F);
 }
 const A = c(t, ["sessionResumption"]);
 e !== void 0 && A != null && d(e, ["setup", "sessionResumption"], cW(A));
 const T = c(t, ["inputAudioTranscription"]);
 e !== void 0 && T != null && d(e, ["setup", "inputAudioTranscription"], T);
 const _ = c(t, ["outputAudioTranscription"]);
 e !== void 0 && _ != null && d(e, ["setup", "outputAudioTranscription"], _);
 const E = c(t, ["realtimeInputConfig"]);
 e !== void 0 && E != null && d(e, ["setup", "realtimeInputConfig"], E);
 const N = c(t, ["contextWindowCompression"]);
 e !== void 0 && N != null && d(e, ["setup", "contextWindowCompression"], N);
 const M = c(t, ["proactivity"]);
 if ((e !== void 0 && M != null && d(e, ["setup", "proactivity"], M), c(t, ["explicitVadSignal"]) !== void 0))
  throw new Error("explicitVadSignal parameter is not supported in Gemini API.");
 return n;
}
function lW(t, e) {
 const n = {},
  r = c(e, ["model"]);
 r != null && d(n, ["setup", "model"], ye(t, r));
 const i = c(e, ["config"]);
 return i != null && d(n, ["config"], aW(i, n)), n;
}
function uW(t) {
 const e = {},
  n = c(t, ["mediaResolution"]);
 n != null && d(e, ["mediaResolution"], n);
 const r = c(t, ["codeExecutionResult"]);
 r != null && d(e, ["codeExecutionResult"], r);
 const i = c(t, ["executableCode"]);
 i != null && d(e, ["executableCode"], i);
 const o = c(t, ["fileData"]);
 o != null && d(e, ["fileData"], rW(o));
 const s = c(t, ["functionCall"]);
 s != null && d(e, ["functionCall"], iW(s));
 const a = c(t, ["functionResponse"]);
 a != null && d(e, ["functionResponse"], a);
 const l = c(t, ["inlineData"]);
 l != null && d(e, ["inlineData"], Z9(l));
 const u = c(t, ["text"]);
 u != null && d(e, ["text"], u);
 const h = c(t, ["thought"]);
 h != null && d(e, ["thought"], h);
 const p = c(t, ["thoughtSignature"]);
 p != null && d(e, ["thoughtSignature"], p);
 const m = c(t, ["videoMetadata"]);
 return m != null && d(e, ["videoMetadata"], m), e;
}
function cW(t) {
 const e = {},
  n = c(t, ["handle"]);
 if ((n != null && d(e, ["handle"], n), c(t, ["transparent"]) !== void 0))
  throw new Error("transparent parameter is not supported in Gemini API.");
 return e;
}
function dW(t) {
 const e = {};
 if (c(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
 const n = c(t, ["computerUse"]);
 n != null && d(e, ["computerUse"], n);
 const r = c(t, ["fileSearch"]);
 r != null && d(e, ["fileSearch"], r);
 const i = c(t, ["codeExecution"]);
 if ((i != null && d(e, ["codeExecution"], i), c(t, ["enterpriseWebSearch"]) !== void 0))
  throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
 const o = c(t, ["functionDeclarations"]);
 if (o != null) {
  let h = o;
  Array.isArray(h) && (h = h.map((p) => p)), d(e, ["functionDeclarations"], h);
 }
 const s = c(t, ["googleMaps"]);
 s != null && d(e, ["googleMaps"], oW(s));
 const a = c(t, ["googleSearch"]);
 a != null && d(e, ["googleSearch"], sW(a));
 const l = c(t, ["googleSearchRetrieval"]);
 l != null && d(e, ["googleSearchRetrieval"], l);
 const u = c(t, ["urlContext"]);
 return u != null && d(e, ["urlContext"], u), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function fW(t) {
 const e = [];
 for (const n in t)
  if (Object.prototype.hasOwnProperty.call(t, n)) {
   const r = t[n];
   if (typeof r == "object" && r != null && Object.keys(r).length > 0) {
    const i = Object.keys(r).map((o) => `${n}.${o}`);
    e.push(...i);
   } else e.push(n);
  }
 return e.join(",");
}
function hW(t, e) {
 let n = null;
 const r = t.bidiGenerateContentSetup;
 if (typeof r == "object" && r !== null && "setup" in r) {
  const o = r.setup;
  typeof o == "object" && o !== null ? ((t.bidiGenerateContentSetup = o), (n = o)) : delete t.bidiGenerateContentSetup;
 } else r !== void 0 && delete t.bidiGenerateContentSetup;
 const i = t.fieldMask;
 if (n) {
  const o = fW(n);
  if (
   Array.isArray(e == null ? void 0 : e.lockAdditionalFields) &&
   (e == null ? void 0 : e.lockAdditionalFields.length) === 0
  )
   o ? (t.fieldMask = o) : delete t.fieldMask;
  else if (
   e != null &&
   e.lockAdditionalFields &&
   e.lockAdditionalFields.length > 0 &&
   i !== null &&
   Array.isArray(i) &&
   i.length > 0
  ) {
   const s = ["temperature", "topK", "topP", "maxOutputTokens", "responseModalities", "seed", "speechConfig"];
   let a = [];
   i.length > 0 && (a = i.map((u) => (s.includes(u) ? `generationConfig.${u}` : u)));
   const l = [];
   o && l.push(o), a.length > 0 && l.push(...a), l.length > 0 ? (t.fieldMask = l.join(",")) : delete t.fieldMask;
  } else delete t.fieldMask;
 } else i !== null && Array.isArray(i) && i.length > 0 ? (t.fieldMask = i.join(",")) : delete t.fieldMask;
 return t;
}
class pW extends Fr {
 constructor(e) {
  super(), (this.apiClient = e);
 }
 async create(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI())
   throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
  {
   const a = nW(this.apiClient, e);
   (o = K("auth_tokens", a._url)), (s = a._query), delete a.config, delete a._url, delete a._query;
   const l = hW(a, e.config);
   return (
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(l),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((u) => u.json())),
    i.then((u) => u)
   );
  }
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function mW(t, e) {
 const n = {},
  r = c(t, ["force"]);
 return e !== void 0 && r != null && d(e, ["_query", "force"], r), n;
}
function gW(t) {
 const e = {},
  n = c(t, ["name"]);
 n != null && d(e, ["_url", "name"], n);
 const r = c(t, ["config"]);
 return r != null && mW(r, e), e;
}
function yW(t) {
 const e = {},
  n = c(t, ["name"]);
 return n != null && d(e, ["_url", "name"], n), e;
}
function vW(t, e) {
 const n = {},
  r = c(t, ["pageSize"]);
 e !== void 0 && r != null && d(e, ["_query", "pageSize"], r);
 const i = c(t, ["pageToken"]);
 return e !== void 0 && i != null && d(e, ["_query", "pageToken"], i), n;
}
function _W(t) {
 const e = {},
  n = c(t, ["parent"]);
 n != null && d(e, ["_url", "parent"], n);
 const r = c(t, ["config"]);
 return r != null && vW(r, e), e;
}
function wW(t) {
 const e = {},
  n = c(t, ["sdkHttpResponse"]);
 n != null && d(e, ["sdkHttpResponse"], n);
 const r = c(t, ["nextPageToken"]);
 r != null && d(e, ["nextPageToken"], r);
 const i = c(t, ["documents"]);
 if (i != null) {
  let o = i;
  Array.isArray(o) && (o = o.map((s) => s)), d(e, ["documents"], o);
 }
 return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class EW extends Fr {
 constructor(e) {
  super(),
   (this.apiClient = e),
   (this.list = async (n) =>
    new Mo(
     Dr.PAGED_ITEM_DOCUMENTS,
     (r) => this.listInternal({ parent: n.parent, config: r.config }),
     await this.listInternal(n),
     n
    ));
 }
 async get(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = yW(e);
   return (
    (o = K("{name}", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => l)
   );
  }
 }
 async delete(e) {
  var n, r;
  let i = "",
   o = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const s = gW(e);
   (i = K("{name}", s._url)),
    (o = s._query),
    delete s._url,
    delete s._query,
    await this.apiClient.request({
     path: i,
     queryParams: o,
     body: JSON.stringify(s),
     httpMethod: "DELETE",
     httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
     abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
    });
  }
 }
 async listInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = _W(e);
   return (
    (o = K("{parent}/documents", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => {
     const u = wW(l),
      h = new QG();
     return Object.assign(h, u), h;
    })
   );
  }
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class TW extends Fr {
 constructor(e, n = new EW(e)) {
  super(),
   (this.apiClient = e),
   (this.documents = n),
   (this.list = async (r = {}) =>
    new Mo(Dr.PAGED_ITEM_FILE_SEARCH_STORES, (i) => this.listInternal(i), await this.listInternal(r), r));
 }
 async uploadToFileSearchStore(e) {
  if (this.apiClient.isVertexAI())
   throw new Error("Vertex AI does not support uploading files to a file search store.");
  return this.apiClient.uploadFileToFileSearchStore(e.fileSearchStoreName, e.file, e.config);
 }
 async create(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = f9(e);
   return (
    (o = K("fileSearchStores", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => l)
   );
  }
 }
 async get(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = m9(e);
   return (
    (o = K("{name}", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => l)
   );
  }
 }
 async delete(e) {
  var n, r;
  let i = "",
   o = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const s = p9(e);
   (i = K("{name}", s._url)),
    (o = s._query),
    delete s._url,
    delete s._query,
    await this.apiClient.request({
     path: i,
     queryParams: o,
     body: JSON.stringify(s),
     httpMethod: "DELETE",
     httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
     abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
    });
  }
 }
 async listInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = E9(e);
   return (
    (o = K("fileSearchStores", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => {
     const u = T9(l),
      h = new XG();
     return Object.assign(h, u), h;
    })
   );
  }
 }
 async uploadToFileSearchStoreInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = I9(e);
   return (
    (o = K("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => {
     const u = S9(l),
      h = new jG();
     return Object.assign(h, u), h;
    })
   );
  }
 }
 async importFile(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = v9(e);
   return (
    (o = K("{file_search_store_name}:importFile", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) => l.json())),
    i.then((l) => {
     const u = y9(l),
      h = new mv();
     return Object.assign(h, u), h;
    })
   );
  }
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ let nb = function () {
 const { crypto: t } = globalThis;
 if (t != null && t.randomUUID) return (nb = t.randomUUID.bind(t)), t.randomUUID();
 const e = new Uint8Array(1),
  n = t ? () => t.getRandomValues(e)[0] : () => (Math.random() * 255) & 255;
 return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (r) => (+r ^ (n() & (15 >> (+r / 4)))).toString(16));
};
const IW = () => nb();
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function Um(t) {
 return (
  typeof t == "object" &&
  t !== null &&
  (("name" in t && t.name === "AbortError") ||
   ("message" in t && String(t.message).includes("FetchRequestCanceledException")))
 );
}
const Om = (t) => {
 if (t instanceof Error) return t;
 if (typeof t == "object" && t !== null) {
  try {
   if (Object.prototype.toString.call(t) === "[object Error]") {
    const e = new Error(t.message, t.cause ? { cause: t.cause } : {});
    return t.stack && (e.stack = t.stack), t.cause && !e.cause && (e.cause = t.cause), t.name && (e.name = t.name), e;
   }
  } catch {}
  try {
   return new Error(JSON.stringify(t));
  } catch {}
 }
 return new Error(t);
};
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class kn extends Error {}
class Gt extends kn {
 constructor(e, n, r, i) {
  super(`${Gt.makeMessage(e, n, r)}`), (this.status = e), (this.headers = i), (this.error = n);
 }
 static makeMessage(e, n, r) {
  const i =
   n != null && n.message
    ? typeof n.message == "string"
      ? n.message
      : JSON.stringify(n.message)
    : n
      ? JSON.stringify(n)
      : r;
  return e && i ? `${e} ${i}` : e ? `${e} status code (no body)` : i || "(no status code or body)";
 }
 static generate(e, n, r, i) {
  if (!e || !i) return new Nf({ message: r, cause: Om(n) });
  const o = n;
  return e === 400
   ? new ib(e, o, r, i)
   : e === 401
     ? new ob(e, o, r, i)
     : e === 403
       ? new sb(e, o, r, i)
       : e === 404
         ? new ab(e, o, r, i)
         : e === 409
           ? new lb(e, o, r, i)
           : e === 422
             ? new ub(e, o, r, i)
             : e === 429
               ? new cb(e, o, r, i)
               : e >= 500
                 ? new db(e, o, r, i)
                 : new Gt(e, o, r, i);
 }
}
class Fm extends Gt {
 constructor({ message: e } = {}) {
  super(void 0, void 0, e || "Request was aborted.", void 0);
 }
}
class Nf extends Gt {
 constructor({ message: e, cause: n }) {
  super(void 0, void 0, e || "Connection error.", void 0), n && (this.cause = n);
 }
}
class rb extends Nf {
 constructor({ message: e } = {}) {
  super({ message: e ?? "Request timed out." });
 }
}
class ib extends Gt {}
class ob extends Gt {}
class sb extends Gt {}
class ab extends Gt {}
class lb extends Gt {}
class ub extends Gt {}
class cb extends Gt {}
class db extends Gt {}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const SW = /^[a-z][a-z0-9+.-]*:/i,
 AW = (t) => SW.test(t);
let Bm = (t) => ((Bm = Array.isArray), Bm(t));
const CW = Bm;
let RW = CW;
const nI = RW;
function PW(t) {
 if (!t) return !0;
 for (const e in t) return !1;
 return !0;
}
function kW(t, e) {
 return Object.prototype.hasOwnProperty.call(t, e);
}
const bW = (t, e) => {
  if (typeof e != "number" || !Number.isInteger(e)) throw new kn(`${t} must be an integer`);
  if (e < 0) throw new kn(`${t} must be a positive integer`);
  return e;
 },
 NW = (t) => {
  try {
   return JSON.parse(t);
  } catch {
   return;
  }
 };
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const xW = (t) => new Promise((e) => setTimeout(e, t));
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const Go = "0.0.1";
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function MW() {
 return typeof Deno < "u" && Deno.build != null
  ? "deno"
  : typeof EdgeRuntime < "u"
    ? "edge"
    : Object.prototype.toString.call(typeof globalThis.process < "u" ? globalThis.process : 0) === "[object process]"
      ? "node"
      : "unknown";
}
const DW = () => {
 var t, e, n, r, i;
 const o = MW();
 if (o === "deno")
  return {
   "X-Stainless-Lang": "js",
   "X-Stainless-Package-Version": Go,
   "X-Stainless-OS": iI(Deno.build.os),
   "X-Stainless-Arch": rI(Deno.build.arch),
   "X-Stainless-Runtime": "deno",
   "X-Stainless-Runtime-Version":
    typeof Deno.version == "string"
     ? Deno.version
     : (e = (t = Deno.version) === null || t === void 0 ? void 0 : t.deno) !== null && e !== void 0
       ? e
       : "unknown",
  };
 if (typeof EdgeRuntime < "u")
  return {
   "X-Stainless-Lang": "js",
   "X-Stainless-Package-Version": Go,
   "X-Stainless-OS": "Unknown",
   "X-Stainless-Arch": `other:${EdgeRuntime}`,
   "X-Stainless-Runtime": "edge",
   "X-Stainless-Runtime-Version": globalThis.process.version,
  };
 if (o === "node")
  return {
   "X-Stainless-Lang": "js",
   "X-Stainless-Package-Version": Go,
   "X-Stainless-OS": iI((n = globalThis.process.platform) !== null && n !== void 0 ? n : "unknown"),
   "X-Stainless-Arch": rI((r = globalThis.process.arch) !== null && r !== void 0 ? r : "unknown"),
   "X-Stainless-Runtime": "node",
   "X-Stainless-Runtime-Version": (i = globalThis.process.version) !== null && i !== void 0 ? i : "unknown",
  };
 const s = LW();
 return s
  ? {
     "X-Stainless-Lang": "js",
     "X-Stainless-Package-Version": Go,
     "X-Stainless-OS": "Unknown",
     "X-Stainless-Arch": "unknown",
     "X-Stainless-Runtime": `browser:${s.browser}`,
     "X-Stainless-Runtime-Version": s.version,
    }
  : {
     "X-Stainless-Lang": "js",
     "X-Stainless-Package-Version": Go,
     "X-Stainless-OS": "Unknown",
     "X-Stainless-Arch": "unknown",
     "X-Stainless-Runtime": "unknown",
     "X-Stainless-Runtime-Version": "unknown",
    };
};
function LW() {
 if (typeof navigator > "u" || !navigator) return null;
 const t = [
  { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
  { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
  { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
  { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
  { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
  { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ },
 ];
 for (const { key: e, pattern: n } of t) {
  const r = n.exec(navigator.userAgent);
  if (r) {
   const i = r[1] || 0,
    o = r[2] || 0,
    s = r[3] || 0;
   return { browser: e, version: `${i}.${o}.${s}` };
  }
 }
 return null;
}
const rI = (t) =>
  t === "x32"
   ? "x32"
   : t === "x86_64" || t === "x64"
     ? "x64"
     : t === "arm"
       ? "arm"
       : t === "aarch64" || t === "arm64"
         ? "arm64"
         : t
           ? `other:${t}`
           : "unknown",
 iI = (t) => (
  (t = t.toLowerCase()),
  t.includes("ios")
   ? "iOS"
   : t === "android"
     ? "Android"
     : t === "darwin"
       ? "MacOS"
       : t === "win32"
         ? "Windows"
         : t === "freebsd"
           ? "FreeBSD"
           : t === "openbsd"
             ? "OpenBSD"
             : t === "linux"
               ? "Linux"
               : t
                 ? `Other:${t}`
                 : "Unknown"
 );
let ju;
const VW = () => ju ?? (ju = DW());
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function UW() {
 if (typeof fetch < "u") return fetch;
 throw new Error(
  "`fetch` is not defined as a global; Either pass `fetch` to the client, `new GeminiNextGenAPIClient({ fetch })` or polyfill the global, `globalThis.fetch = fetch`"
 );
}
function fb(...t) {
 const e = globalThis.ReadableStream;
 if (typeof e > "u")
  throw new Error(
   "`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`"
  );
 return new e(...t);
}
function OW(t) {
 let e = Symbol.asyncIterator in t ? t[Symbol.asyncIterator]() : t[Symbol.iterator]();
 return fb({
  start() {},
  async pull(n) {
   const { done: r, value: i } = await e.next();
   r ? n.close() : n.enqueue(i);
  },
  async cancel() {
   var n;
   await ((n = e.return) === null || n === void 0 ? void 0 : n.call(e));
  },
 });
}
function hb(t) {
 if (t[Symbol.asyncIterator]) return t;
 const e = t.getReader();
 return {
  async next() {
   try {
    const n = await e.read();
    return n != null && n.done && e.releaseLock(), n;
   } catch (n) {
    throw (e.releaseLock(), n);
   }
  },
  async return() {
   const n = e.cancel();
   return e.releaseLock(), await n, { done: !0, value: void 0 };
  },
  [Symbol.asyncIterator]() {
   return this;
  },
 };
}
async function FW(t) {
 var e, n;
 if (t === null || typeof t != "object") return;
 if (t[Symbol.asyncIterator]) {
  await ((n = (e = t[Symbol.asyncIterator]()).return) === null || n === void 0 ? void 0 : n.call(e));
  return;
 }
 const r = t.getReader(),
  i = r.cancel();
 r.releaseLock(), await i;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const BW = ({ headers: t, body: e }) => ({
 bodyHeaders: { "content-type": "application/json" },
 body: JSON.stringify(e),
});
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const pb = () => {
 var t;
 if (typeof File > "u") {
  const { process: e } = globalThis,
   n =
    typeof ((t = e == null ? void 0 : e.versions) === null || t === void 0 ? void 0 : t.node) == "string" &&
    parseInt(e.versions.node.split(".")) < 20;
  throw new Error(
   "`File` is not defined as a global, which is required for file uploads." +
    (n ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : "")
  );
 }
};
function Qh(t, e, n) {
 return pb(), new File(t, e ?? "unknown_file", n);
}
function $W(t) {
 return (
  (
   (typeof t == "object" &&
    t !== null &&
    (("name" in t && t.name && String(t.name)) ||
     ("url" in t && t.url && String(t.url)) ||
     ("filename" in t && t.filename && String(t.filename)) ||
     ("path" in t && t.path && String(t.path)))) ||
   ""
  )
   .split(/[\\/]/)
   .pop() || void 0
 );
}
const HW = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function";
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const mb = (t) =>
  t != null &&
  typeof t == "object" &&
  typeof t.size == "number" &&
  typeof t.type == "string" &&
  typeof t.text == "function" &&
  typeof t.slice == "function" &&
  typeof t.arrayBuffer == "function",
 qW = (t) =>
  t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && mb(t),
 GW = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function";
async function zW(t, e, n) {
 if ((pb(), (t = await t), qW(t))) return t instanceof File ? t : Qh([await t.arrayBuffer()], t.name);
 if (GW(t)) {
  const i = await t.blob();
  return e || (e = new URL(t.url).pathname.split(/[\\/]/).pop()), Qh(await $m(i), e, n);
 }
 const r = await $m(t);
 if ((e || (e = $W(t)), !(n != null && n.type))) {
  const i = r.find((o) => typeof o == "object" && "type" in o && o.type);
  typeof i == "string" && (n = Object.assign(Object.assign({}, n), { type: i }));
 }
 return Qh(r, e, n);
}
async function $m(t) {
 var e, n, r, i, o;
 let s = [];
 if (typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer) s.push(t);
 else if (mb(t)) s.push(t instanceof Blob ? t : await t.arrayBuffer());
 else if (HW(t))
  try {
   for (var a = !0, l = Bn(t), u; (u = await l.next()), (e = u.done), !e; a = !0) {
    (i = u.value), (a = !1);
    const h = i;
    s.push(...(await $m(h)));
   }
  } catch (h) {
   n = { error: h };
  } finally {
   try {
    !a && !e && (r = l.return) && (await r.call(l));
   } finally {
    if (n) throw n.error;
   }
  }
 else {
  const h = (o = t == null ? void 0 : t.constructor) === null || o === void 0 ? void 0 : o.name;
  throw new Error(`Unexpected data type: ${typeof t}${h ? `; constructor: ${h}` : ""}${WW(t)}`);
 }
 return s;
}
function WW(t) {
 return typeof t != "object" || t === null
  ? ""
  : `; props: [${Object.getOwnPropertyNames(t)
     .map((n) => `"${n}"`)
     .join(", ")}]`;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class gb {
 constructor(e) {
  this._client = e;
 }
}
gb._key = [];
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function yb(t) {
 return t.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
const oI = Object.freeze(Object.create(null)),
 KW = (t = yb) =>
  function (n, ...r) {
   if (n.length === 1) return n[0];
   let i = !1;
   const o = [],
    s = n.reduce((h, p, m) => {
     var v, w, C;
     /[?#]/.test(p) && (i = !0);
     const A = r[m];
     let T = (i ? encodeURIComponent : t)("" + A);
     return (
      m !== r.length &&
       (A == null ||
        (typeof A == "object" &&
         A.toString ===
          ((C = Object.getPrototypeOf(
           (w = Object.getPrototypeOf((v = A.hasOwnProperty) !== null && v !== void 0 ? v : oI)) !== null &&
            w !== void 0
            ? w
            : oI
          )) === null || C === void 0
           ? void 0
           : C.toString))) &&
       ((T = A + ""),
       o.push({
        start: h.length + p.length,
        length: T.length,
        error: `Value of type ${Object.prototype.toString.call(A).slice(8, -1)} is not a valid path parameter`,
       })),
      h + p + (m === r.length ? "" : T)
     );
    }, ""),
    a = s.split(/[?#]/, 1)[0],
    l = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
   let u;
   for (; (u = l.exec(a)) !== null; )
    o.push({
     start: u.index,
     length: u[0].length,
     error: `Value "${u[0]}" can't be safely passed as a path parameter`,
    });
   if ((o.sort((h, p) => h.start - p.start), o.length > 0)) {
    let h = 0;
    const p = o.reduce((m, v) => {
     const w = " ".repeat(v.start - h),
      C = "^".repeat(v.length);
     return (h = v.start + v.length), m + w + C;
    }, "");
    throw new kn(`Path parameters result in path with invalid segments:
${o.map((m) => m.error).join(`
`)}
${s}
${p}`);
   }
   return s;
  },
 Zu = KW(yb);
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class vb extends gb {
 create(e, n) {
  var r;
  const { api_version: i = this._client.apiVersion } = e,
   o = bd(e, ["api_version"]);
  if ("model" in o && "agent_config" in o)
   throw new kn(
    "Invalid request: specified `model` and `agent_config`. If specifying `model`, use `generation_config`."
   );
  if ("agent" in o && "generation_config" in o)
   throw new kn(
    "Invalid request: specified `agent` and `generation_config`. If specifying `agent`, use `agent_config`."
   );
  return this._client.post(
   Zu`/${i}/interactions`,
   Object.assign(Object.assign({ body: o }, n), { stream: (r = e.stream) !== null && r !== void 0 ? r : !1 })
  );
 }
 delete(e, n = {}, r) {
  const { api_version: i = this._client.apiVersion } = n ?? {};
  return this._client.delete(Zu`/${i}/interactions/${e}`, r);
 }
 cancel(e, n = {}, r) {
  const { api_version: i = this._client.apiVersion } = n ?? {};
  return this._client.post(Zu`/${i}/interactions/${e}/cancel`, r);
 }
 get(e, n = {}, r) {
  var i;
  const o = n ?? {},
   { api_version: s = this._client.apiVersion } = o,
   a = bd(o, ["api_version"]);
  return this._client.get(
   Zu`/${s}/interactions/${e}`,
   Object.assign(Object.assign({ query: a }, r), {
    stream: (i = n == null ? void 0 : n.stream) !== null && i !== void 0 ? i : !1,
   })
  );
 }
}
vb._key = Object.freeze(["interactions"]);
class _b extends vb {}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function JW(t) {
 let e = 0;
 for (const i of t) e += i.length;
 const n = new Uint8Array(e);
 let r = 0;
 for (const i of t) n.set(i, r), (r += i.length);
 return n;
}
let ec;
function Tv(t) {
 let e;
 return (ec ?? ((e = new globalThis.TextEncoder()), (ec = e.encode.bind(e))))(t);
}
let tc;
function sI(t) {
 let e;
 return (tc ?? ((e = new globalThis.TextDecoder()), (tc = e.decode.bind(e))))(t);
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class xf {
 constructor() {
  (this.buffer = new Uint8Array()), (this.carriageReturnIndex = null);
 }
 decode(e) {
  if (e == null) return [];
  const n = e instanceof ArrayBuffer ? new Uint8Array(e) : typeof e == "string" ? Tv(e) : e;
  this.buffer = JW([this.buffer, n]);
  const r = [];
  let i;
  for (; (i = YW(this.buffer, this.carriageReturnIndex)) != null; ) {
   if (i.carriage && this.carriageReturnIndex == null) {
    this.carriageReturnIndex = i.index;
    continue;
   }
   if (this.carriageReturnIndex != null && (i.index !== this.carriageReturnIndex + 1 || i.carriage)) {
    r.push(sI(this.buffer.subarray(0, this.carriageReturnIndex - 1))),
     (this.buffer = this.buffer.subarray(this.carriageReturnIndex)),
     (this.carriageReturnIndex = null);
    continue;
   }
   const o = this.carriageReturnIndex !== null ? i.preceding - 1 : i.preceding,
    s = sI(this.buffer.subarray(0, o));
   r.push(s), (this.buffer = this.buffer.subarray(i.index)), (this.carriageReturnIndex = null);
  }
  return r;
 }
 flush() {
  return this.buffer.length
   ? this.decode(`
`)
   : [];
 }
}
xf.NEWLINE_CHARS = new Set([
 `
`,
 "\r",
]);
xf.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function YW(t, e) {
 for (let i = e ?? 0; i < t.length; i++) {
  if (t[i] === 10) return { preceding: i, index: i + 1, carriage: !1 };
  if (t[i] === 13) return { preceding: i, index: i + 1, carriage: !0 };
 }
 return null;
}
function QW(t) {
 for (let r = 0; r < t.length - 1; r++) {
  if ((t[r] === 10 && t[r + 1] === 10) || (t[r] === 13 && t[r + 1] === 13)) return r + 2;
  if (t[r] === 13 && t[r + 1] === 10 && r + 3 < t.length && t[r + 2] === 13 && t[r + 3] === 10) return r + 4;
 }
 return -1;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const Nd = { off: 0, error: 200, warn: 300, info: 400, debug: 500 },
 aI = (t, e, n) => {
  if (t) {
   if (kW(Nd, t)) return t;
   Ft(n).warn(`${e} was set to ${JSON.stringify(t)}, expected one of ${JSON.stringify(Object.keys(Nd))}`);
  }
 };
function Va() {}
function nc(t, e, n) {
 return !e || Nd[t] > Nd[n] ? Va : e[t].bind(e);
}
const XW = { error: Va, warn: Va, info: Va, debug: Va };
let lI = new WeakMap();
function Ft(t) {
 var e;
 const n = t.logger,
  r = (e = t.logLevel) !== null && e !== void 0 ? e : "off";
 if (!n) return XW;
 const i = lI.get(n);
 if (i && i[0] === r) return i[1];
 const o = { error: nc("error", n, r), warn: nc("warn", n, r), info: nc("info", n, r), debug: nc("debug", n, r) };
 return lI.set(n, [r, o]), o;
}
const Qi = (t) => (
 t.options && ((t.options = Object.assign({}, t.options)), delete t.options.headers),
 t.headers &&
  (t.headers = Object.fromEntries(
   (t.headers instanceof Headers ? [...t.headers] : Object.entries(t.headers)).map(([e, n]) => [
    e,
    e.toLowerCase() === "x-goog-api-key" ||
    e.toLowerCase() === "authorization" ||
    e.toLowerCase() === "cookie" ||
    e.toLowerCase() === "set-cookie"
     ? "***"
     : n,
   ])
  )),
 "retryOfRequestLogID" in t &&
  (t.retryOfRequestLogID && (t.retryOf = t.retryOfRequestLogID), delete t.retryOfRequestLogID),
 t
);
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class os {
 constructor(e, n, r) {
  (this.iterator = e), (this.controller = n), (this.client = r);
 }
 static fromSSEResponse(e, n, r) {
  let i = !1;
  const o = r ? Ft(r) : console;
  function s() {
   return Fn(this, arguments, function* () {
    var l, u, h, p;
    if (i) throw new kn("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
    i = !0;
    let m = !1;
    try {
     try {
      for (var v = !0, w = Bn(jW(e, n)), C; (C = yield ie(w.next())), (l = C.done), !l; v = !0) {
       (p = C.value), (v = !1);
       const A = p;
       if (!m)
        if (A.data.startsWith("[DONE]")) {
         m = !0;
         continue;
        } else
         try {
          yield yield ie(JSON.parse(A.data));
         } catch (T) {
          throw (o.error("Could not parse message into JSON:", A.data), o.error("From chunk:", A.raw), T);
         }
      }
     } catch (A) {
      u = { error: A };
     } finally {
      try {
       !v && !l && (h = w.return) && (yield ie(h.call(w)));
      } finally {
       if (u) throw u.error;
      }
     }
     m = !0;
    } catch (A) {
     if (Um(A)) return yield ie(void 0);
     throw A;
    } finally {
     m || n.abort();
    }
   });
  }
  return new os(s, n, r);
 }
 static fromReadableStream(e, n, r) {
  let i = !1;
  function o() {
   return Fn(this, arguments, function* () {
    var l, u, h, p;
    const m = new xf(),
     v = hb(e);
    try {
     for (var w = !0, C = Bn(v), A; (A = yield ie(C.next())), (l = A.done), !l; w = !0) {
      (p = A.value), (w = !1);
      const T = p;
      for (const _ of m.decode(T)) yield yield ie(_);
     }
    } catch (T) {
     u = { error: T };
    } finally {
     try {
      !w && !l && (h = C.return) && (yield ie(h.call(C)));
     } finally {
      if (u) throw u.error;
     }
    }
    for (const T of m.flush()) yield yield ie(T);
   });
  }
  function s() {
   return Fn(this, arguments, function* () {
    var l, u, h, p;
    if (i) throw new kn("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
    i = !0;
    let m = !1;
    try {
     try {
      for (var v = !0, w = Bn(o()), C; (C = yield ie(w.next())), (l = C.done), !l; v = !0) {
       (p = C.value), (v = !1);
       const A = p;
       m || (A && (yield yield ie(JSON.parse(A))));
      }
     } catch (A) {
      u = { error: A };
     } finally {
      try {
       !v && !l && (h = w.return) && (yield ie(h.call(w)));
      } finally {
       if (u) throw u.error;
      }
     }
     m = !0;
    } catch (A) {
     if (Um(A)) return yield ie(void 0);
     throw A;
    } finally {
     m || n.abort();
    }
   });
  }
  return new os(s, n, r);
 }
 [Symbol.asyncIterator]() {
  return this.iterator();
 }
 tee() {
  const e = [],
   n = [],
   r = this.iterator(),
   i = (o) => ({
    next: () => {
     if (o.length === 0) {
      const s = r.next();
      e.push(s), n.push(s);
     }
     return o.shift();
    },
   });
  return [new os(() => i(e), this.controller, this.client), new os(() => i(n), this.controller, this.client)];
 }
 toReadableStream() {
  const e = this;
  let n;
  return fb({
   async start() {
    n = e[Symbol.asyncIterator]();
   },
   async pull(r) {
    try {
     const { value: i, done: o } = await n.next();
     if (o) return r.close();
     const s = Tv(
      JSON.stringify(i) +
       `
`
     );
     r.enqueue(s);
    } catch (i) {
     r.error(i);
    }
   },
   async cancel() {
    var r;
    await ((r = n.return) === null || r === void 0 ? void 0 : r.call(n));
   },
  });
 }
}
function jW(t, e) {
 return Fn(this, arguments, function* () {
  var r, i, o, s;
  if (!t.body)
   throw (
    (e.abort(),
    typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative"
     ? new kn(
        "The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api"
       )
     : new kn("Attempted to iterate over a response with no body"))
   );
  const a = new e7(),
   l = new xf(),
   u = hb(t.body);
  try {
   for (var h = !0, p = Bn(ZW(u)), m; (m = yield ie(p.next())), (r = m.done), !r; h = !0) {
    (s = m.value), (h = !1);
    const v = s;
    for (const w of l.decode(v)) {
     const C = a.decode(w);
     C && (yield yield ie(C));
    }
   }
  } catch (v) {
   i = { error: v };
  } finally {
   try {
    !h && !r && (o = p.return) && (yield ie(o.call(p)));
   } finally {
    if (i) throw i.error;
   }
  }
  for (const v of l.flush()) {
   const w = a.decode(v);
   w && (yield yield ie(w));
  }
 });
}
function ZW(t) {
 return Fn(this, arguments, function* () {
  var n, r, i, o;
  let s = new Uint8Array();
  try {
   for (var a = !0, l = Bn(t), u; (u = yield ie(l.next())), (n = u.done), !n; a = !0) {
    (o = u.value), (a = !1);
    const h = o;
    if (h == null) continue;
    const p = h instanceof ArrayBuffer ? new Uint8Array(h) : typeof h == "string" ? Tv(h) : h;
    let m = new Uint8Array(s.length + p.length);
    m.set(s), m.set(p, s.length), (s = m);
    let v;
    for (; (v = QW(s)) !== -1; ) yield yield ie(s.slice(0, v)), (s = s.slice(v));
   }
  } catch (h) {
   r = { error: h };
  } finally {
   try {
    !a && !n && (i = l.return) && (yield ie(i.call(l)));
   } finally {
    if (r) throw r.error;
   }
  }
  s.length > 0 && (yield yield ie(s));
 });
}
class e7 {
 constructor() {
  (this.event = null), (this.data = []), (this.chunks = []);
 }
 decode(e) {
  if ((e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e)) {
   if (!this.event && !this.data.length) return null;
   const o = {
    event: this.event,
    data: this.data.join(`
`),
    raw: this.chunks,
   };
   return (this.event = null), (this.data = []), (this.chunks = []), o;
  }
  if ((this.chunks.push(e), e.startsWith(":"))) return null;
  let [n, r, i] = t7(e, ":");
  return (
   i.startsWith(" ") && (i = i.substring(1)), n === "event" ? (this.event = i) : n === "data" && this.data.push(i), null
  );
 }
}
function t7(t, e) {
 const n = t.indexOf(e);
 return n !== -1 ? [t.substring(0, n), e, t.substring(n + e.length)] : [t, "", ""];
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ async function n7(t, e) {
 const { response: n, requestLogID: r, retryOfRequestLogID: i, startTime: o } = e,
  s = await (async () => {
   var a;
   if (e.options.stream)
    return (
     Ft(t).debug("response", n.status, n.url, n.headers, n.body),
     e.options.__streamClass
      ? e.options.__streamClass.fromSSEResponse(n, e.controller, t)
      : os.fromSSEResponse(n, e.controller, t)
    );
   if (n.status === 204) return null;
   if (e.options.__binaryResponse) return n;
   const l = n.headers.get("content-type"),
    u = (a = l == null ? void 0 : l.split(";")[0]) === null || a === void 0 ? void 0 : a.trim();
   return (u == null ? void 0 : u.includes("application/json")) || (u == null ? void 0 : u.endsWith("+json"))
    ? await n.json()
    : await n.text();
  })();
 return (
  Ft(t).debug(
   `[${r}] response parsed`,
   Qi({ retryOfRequestLogID: i, url: n.url, status: n.status, body: s, durationMs: Date.now() - o })
  ),
  s
 );
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class Iv extends Promise {
 constructor(e, n, r = n7) {
  super((i) => {
   i(null);
  }),
   (this.responsePromise = n),
   (this.parseResponse = r),
   (this.client = e);
 }
 _thenUnwrap(e) {
  return new Iv(this.client, this.responsePromise, async (n, r) => e(await this.parseResponse(n, r), r));
 }
 asResponse() {
  return this.responsePromise.then((e) => e.response);
 }
 async withResponse() {
  const [e, n] = await Promise.all([this.parse(), this.asResponse()]);
  return { data: e, response: n };
 }
 parse() {
  return (
   this.parsedPromise || (this.parsedPromise = this.responsePromise.then((e) => this.parseResponse(this.client, e))),
   this.parsedPromise
  );
 }
 then(e, n) {
  return this.parse().then(e, n);
 }
 catch(e) {
  return this.parse().catch(e);
 }
 finally(e) {
  return this.parse().finally(e);
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const wb = Symbol("brand.privateNullableHeaders");
function* r7(t) {
 if (!t) return;
 if (wb in t) {
  const { values: r, nulls: i } = t;
  yield* r.entries();
  for (const o of i) yield [o, null];
  return;
 }
 let e = !1,
  n;
 t instanceof Headers ? (n = t.entries()) : nI(t) ? (n = t) : ((e = !0), (n = Object.entries(t ?? {})));
 for (let r of n) {
  const i = r[0];
  if (typeof i != "string") throw new TypeError("expected header name to be a string");
  const o = nI(r[1]) ? r[1] : [r[1]];
  let s = !1;
  for (const a of o) a !== void 0 && (e && !s && ((s = !0), yield [i, null]), yield [i, a]);
 }
}
const Aa = (t) => {
 const e = new Headers(),
  n = new Set();
 for (const r of t) {
  const i = new Set();
  for (const [o, s] of r7(r)) {
   const a = o.toLowerCase();
   i.has(a) || (e.delete(o), i.add(a)), s === null ? (e.delete(o), n.add(a)) : (e.append(o, s), n.delete(a));
  }
 }
 return { [wb]: !0, values: e, nulls: n };
};
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const Xh = (t) => {
 var e, n, r, i, o, s;
 if (typeof globalThis.process < "u")
  return (r = (n = (e = AG) === null || e === void 0 ? void 0 : e[t]) === null || n === void 0 ? void 0 : n.trim()) !==
   null && r !== void 0
   ? r
   : void 0;
 if (typeof globalThis.Deno < "u")
  return (s =
   (o = (i = globalThis.Deno.env) === null || i === void 0 ? void 0 : i.get) === null || o === void 0
    ? void 0
    : o.call(i, t)) === null || s === void 0
   ? void 0
   : s.trim();
};
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ var Eb;
class Mf {
 constructor(e) {
  var n,
   r,
   i,
   o,
   s,
   a,
   l,
   {
    baseURL: u = Xh("GEMINI_NEXT_GEN_API_BASE_URL"),
    apiKey: h = (n = Xh("GEMINI_API_KEY")) !== null && n !== void 0 ? n : null,
    apiVersion: p = "v1beta",
   } = e,
   m = bd(e, ["baseURL", "apiKey", "apiVersion"]);
  const v = Object.assign(Object.assign({ apiKey: h, apiVersion: p }, m), {
   baseURL: u || "https://generativelanguage.googleapis.com",
  });
  (this.baseURL = v.baseURL),
   (this.timeout = (r = v.timeout) !== null && r !== void 0 ? r : Mf.DEFAULT_TIMEOUT),
   (this.logger = (i = v.logger) !== null && i !== void 0 ? i : console);
  const w = "warn";
  (this.logLevel = w),
   (this.logLevel =
    (s =
     (o = aI(v.logLevel, "ClientOptions.logLevel", this)) !== null && o !== void 0
      ? o
      : aI(Xh("GEMINI_NEXT_GEN_API_LOG"), "process.env['GEMINI_NEXT_GEN_API_LOG']", this)) !== null && s !== void 0
     ? s
     : w),
   (this.fetchOptions = v.fetchOptions),
   (this.maxRetries = (a = v.maxRetries) !== null && a !== void 0 ? a : 2),
   (this.fetch = (l = v.fetch) !== null && l !== void 0 ? l : UW()),
   (this.encoder = BW),
   (this._options = v),
   (this.apiKey = h),
   (this.apiVersion = p),
   (this.clientAdapter = v.clientAdapter);
 }
 withOptions(e) {
  return new this.constructor(
   Object.assign(
    Object.assign(Object.assign({}, this._options), {
     baseURL: this.baseURL,
     maxRetries: this.maxRetries,
     timeout: this.timeout,
     logger: this.logger,
     logLevel: this.logLevel,
     fetch: this.fetch,
     fetchOptions: this.fetchOptions,
     apiKey: this.apiKey,
     apiVersion: this.apiVersion,
    }),
    e
   )
  );
 }
 baseURLOverridden() {
  return this.baseURL !== "https://generativelanguage.googleapis.com";
 }
 defaultQuery() {
  return this._options.defaultQuery;
 }
 validateHeaders({ values: e, nulls: n }) {
  if (
   !(e.has("authorization") || e.has("x-goog-api-key")) &&
   !(this.apiKey && e.get("x-goog-api-key")) &&
   !n.has("x-goog-api-key")
  )
   throw new Error(
    'Could not resolve authentication method. Expected the apiKey to be set. Or for the "x-goog-api-key" headers to be explicitly omitted'
   );
 }
 async authHeaders(e) {
  const n = Aa([e.headers]);
  if (!(n.values.has("authorization") || n.values.has("x-goog-api-key"))) {
   if (this.apiKey) return Aa([{ "x-goog-api-key": this.apiKey }]);
   if (this.clientAdapter.isVertexAI()) return Aa([await this.clientAdapter.getAuthHeaders()]);
  }
 }
 stringifyQuery(e) {
  return Object.entries(e)
   .filter(([n, r]) => typeof r < "u")
   .map(([n, r]) => {
    if (typeof r == "string" || typeof r == "number" || typeof r == "boolean")
     return `${encodeURIComponent(n)}=${encodeURIComponent(r)}`;
    if (r === null) return `${encodeURIComponent(n)}=`;
    throw new kn(
     `Cannot stringify type ${typeof r}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`
    );
   })
   .join("&");
 }
 getUserAgent() {
  return `${this.constructor.name}/JS ${Go}`;
 }
 defaultIdempotencyKey() {
  return `stainless-node-retry-${IW()}`;
 }
 makeStatusError(e, n, r, i) {
  return Gt.generate(e, n, r, i);
 }
 buildURL(e, n, r) {
  const i = (!this.baseURLOverridden() && r) || this.baseURL,
   o = AW(e) ? new URL(e) : new URL(i + (i.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)),
   s = this.defaultQuery();
  return (
   PW(s) || (n = Object.assign(Object.assign({}, s), n)),
   typeof n == "object" && n && !Array.isArray(n) && (o.search = this.stringifyQuery(n)),
   o.toString()
  );
 }
 async prepareOptions(e) {
  if (this.clientAdapter && this.clientAdapter.isVertexAI() && !e.path.startsWith(`/${this.apiVersion}/projects/`)) {
   const n = e.path.slice(this.apiVersion.length + 1);
   e.path = `/${this.apiVersion}/projects/${this.clientAdapter.getProject()}/locations/${this.clientAdapter.getLocation()}${n}`;
  }
 }
 async prepareRequest(e, { url: n, options: r }) {}
 get(e, n) {
  return this.methodRequest("get", e, n);
 }
 post(e, n) {
  return this.methodRequest("post", e, n);
 }
 patch(e, n) {
  return this.methodRequest("patch", e, n);
 }
 put(e, n) {
  return this.methodRequest("put", e, n);
 }
 delete(e, n) {
  return this.methodRequest("delete", e, n);
 }
 methodRequest(e, n, r) {
  return this.request(Promise.resolve(r).then((i) => Object.assign({ method: e, path: n }, i)));
 }
 request(e, n = null) {
  return new Iv(this, this.makeRequest(e, n, void 0));
 }
 async makeRequest(e, n, r) {
  var i, o, s;
  const a = await e,
   l = (i = a.maxRetries) !== null && i !== void 0 ? i : this.maxRetries;
  n == null && (n = l), await this.prepareOptions(a);
  const { req: u, url: h, timeout: p } = await this.buildRequest(a, { retryCount: l - n });
  await this.prepareRequest(u, { url: h, options: a });
  const m = "log_" + ((Math.random() * (1 << 24)) | 0).toString(16).padStart(6, "0"),
   v = r === void 0 ? "" : `, retryOf: ${r}`,
   w = Date.now();
  if (
   (Ft(this).debug(
    `[${m}] sending request`,
    Qi({ retryOfRequestLogID: r, method: a.method, url: h, options: a, headers: u.headers })
   ),
   !((o = a.signal) === null || o === void 0) && o.aborted)
  )
   throw new Fm();
  const C = new AbortController(),
   A = await this.fetchWithTimeout(h, u, p, C).catch(Om),
   T = Date.now();
  if (A instanceof globalThis.Error) {
   const E = `retrying, ${n} attempts remaining`;
   if (!((s = a.signal) === null || s === void 0) && s.aborted) throw new Fm();
   const N = Um(A) || /timed? ?out/i.test(String(A) + ("cause" in A ? String(A.cause) : ""));
   if (n)
    return (
     Ft(this).info(`[${m}] connection ${N ? "timed out" : "failed"} - ${E}`),
     Ft(this).debug(
      `[${m}] connection ${N ? "timed out" : "failed"} (${E})`,
      Qi({ retryOfRequestLogID: r, url: h, durationMs: T - w, message: A.message })
     ),
     this.retryRequest(a, n, r ?? m)
    );
   throw (
    (Ft(this).info(`[${m}] connection ${N ? "timed out" : "failed"} - error; no more retries left`),
    Ft(this).debug(
     `[${m}] connection ${N ? "timed out" : "failed"} (error; no more retries left)`,
     Qi({ retryOfRequestLogID: r, url: h, durationMs: T - w, message: A.message })
    ),
    N ? new rb() : new Nf({ cause: A }))
   );
  }
  const _ = `[${m}${v}] ${u.method} ${h} ${A.ok ? "succeeded" : "failed"} with status ${A.status} in ${T - w}ms`;
  if (!A.ok) {
   const E = await this.shouldRetry(A);
   if (n && E) {
    const R = `retrying, ${n} attempts remaining`;
    return (
     await FW(A.body),
     Ft(this).info(`${_} - ${R}`),
     Ft(this).debug(
      `[${m}] response error (${R})`,
      Qi({ retryOfRequestLogID: r, url: A.url, status: A.status, headers: A.headers, durationMs: T - w })
     ),
     this.retryRequest(a, n, r ?? m, A.headers)
    );
   }
   const N = E ? "error; no more retries left" : "error; not retryable";
   Ft(this).info(`${_} - ${N}`);
   const M = await A.text().catch((R) => Om(R).message),
    F = NW(M),
    P = F ? void 0 : M;
   throw (
    (Ft(this).debug(
     `[${m}] response error (${N})`,
     Qi({
      retryOfRequestLogID: r,
      url: A.url,
      status: A.status,
      headers: A.headers,
      message: P,
      durationMs: Date.now() - w,
     })
    ),
    this.makeStatusError(A.status, F, P, A.headers))
   );
  }
  return (
   Ft(this).info(_),
   Ft(this).debug(
    `[${m}] response start`,
    Qi({ retryOfRequestLogID: r, url: A.url, status: A.status, headers: A.headers, durationMs: T - w })
   ),
   { response: A, options: a, controller: C, requestLogID: m, retryOfRequestLogID: r, startTime: w }
  );
 }
 async fetchWithTimeout(e, n, r, i) {
  const o = n || {},
   { signal: s, method: a } = o,
   l = bd(o, ["signal", "method"]);
  s && s.addEventListener("abort", () => i.abort());
  const u = setTimeout(() => i.abort(), r),
   h =
    (globalThis.ReadableStream && l.body instanceof globalThis.ReadableStream) ||
    (typeof l.body == "object" && l.body !== null && Symbol.asyncIterator in l.body),
   p = Object.assign(
    Object.assign(Object.assign({ signal: i.signal }, h ? { duplex: "half" } : {}), { method: "GET" }),
    l
   );
  a && (p.method = a.toUpperCase());
  try {
   return await this.fetch.call(void 0, e, p);
  } finally {
   clearTimeout(u);
  }
 }
 async shouldRetry(e) {
  const n = e.headers.get("x-should-retry");
  return n === "true"
   ? !0
   : n === "false"
     ? !1
     : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
 }
 async retryRequest(e, n, r, i) {
  var o;
  let s;
  const a = i == null ? void 0 : i.get("retry-after-ms");
  if (a) {
   const u = parseFloat(a);
   Number.isNaN(u) || (s = u);
  }
  const l = i == null ? void 0 : i.get("retry-after");
  if (l && !s) {
   const u = parseFloat(l);
   Number.isNaN(u) ? (s = Date.parse(l) - Date.now()) : (s = u * 1e3);
  }
  if (!(s && 0 <= s && s < 60 * 1e3)) {
   const u = (o = e.maxRetries) !== null && o !== void 0 ? o : this.maxRetries;
   s = this.calculateDefaultRetryTimeoutMillis(n, u);
  }
  return await xW(s), this.makeRequest(e, n - 1, r);
 }
 calculateDefaultRetryTimeoutMillis(e, n) {
  const o = n - e,
   s = Math.min(0.5 * Math.pow(2, o), 8),
   a = 1 - Math.random() * 0.25;
  return s * a * 1e3;
 }
 async buildRequest(e, { retryCount: n = 0 } = {}) {
  var r, i, o;
  const s = Object.assign({}, e),
   { method: a, path: l, query: u, defaultBaseURL: h } = s,
   p = this.buildURL(l, u, h);
  "timeout" in s && bW("timeout", s.timeout), (s.timeout = (r = s.timeout) !== null && r !== void 0 ? r : this.timeout);
  const { bodyHeaders: m, body: v } = this.buildBody({ options: s }),
   w = await this.buildHeaders({ options: e, method: a, bodyHeaders: m, retryCount: n });
  return {
   req: Object.assign(
    Object.assign(
     Object.assign(
      Object.assign(
       Object.assign({ method: a, headers: w }, s.signal && { signal: s.signal }),
       globalThis.ReadableStream && v instanceof globalThis.ReadableStream && { duplex: "half" }
      ),
      v && { body: v }
     ),
     (i = this.fetchOptions) !== null && i !== void 0 ? i : {}
    ),
    (o = s.fetchOptions) !== null && o !== void 0 ? o : {}
   ),
   url: p,
   timeout: s.timeout,
  };
 }
 async buildHeaders({ options: e, method: n, bodyHeaders: r, retryCount: i }) {
  let o = {};
  this.idempotencyHeader &&
   n !== "get" &&
   (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()),
   (o[this.idempotencyHeader] = e.idempotencyKey));
  const s = await this.authHeaders(e);
  let a = Aa([
   o,
   Object.assign(
    Object.assign(
     { Accept: "application/json", "User-Agent": this.getUserAgent(), "X-Stainless-Retry-Count": String(i) },
     e.timeout ? { "X-Stainless-Timeout": String(Math.trunc(e.timeout / 1e3)) } : {}
    ),
    VW()
   ),
   this._options.defaultHeaders,
   r,
   e.headers,
   s,
  ]);
  return this.validateHeaders(a), a.values;
 }
 buildBody({ options: { body: e, headers: n } }) {
  if (!e) return { bodyHeaders: void 0, body: void 0 };
  const r = Aa([n]);
  return ArrayBuffer.isView(e) ||
   e instanceof ArrayBuffer ||
   e instanceof DataView ||
   (typeof e == "string" && r.values.has("content-type")) ||
   (globalThis.Blob && e instanceof globalThis.Blob) ||
   e instanceof FormData ||
   e instanceof URLSearchParams ||
   (globalThis.ReadableStream && e instanceof globalThis.ReadableStream)
   ? { bodyHeaders: void 0, body: e }
   : typeof e == "object" &&
       (Symbol.asyncIterator in e || (Symbol.iterator in e && "next" in e && typeof e.next == "function"))
     ? { bodyHeaders: void 0, body: OW(e) }
     : this.encoder({ body: e, headers: r });
 }
}
Mf.DEFAULT_TIMEOUT = 6e4;
class dt extends Mf {
 constructor() {
  super(...arguments), (this.interactions = new _b(this));
 }
}
Eb = dt;
dt.GeminiNextGenAPIClient = Eb;
dt.GeminiNextGenAPIClientError = kn;
dt.APIError = Gt;
dt.APIConnectionError = Nf;
dt.APIConnectionTimeoutError = rb;
dt.APIUserAbortError = Fm;
dt.NotFoundError = ab;
dt.ConflictError = lb;
dt.RateLimitError = cb;
dt.BadRequestError = ib;
dt.AuthenticationError = ob;
dt.InternalServerError = db;
dt.PermissionDeniedError = sb;
dt.UnprocessableEntityError = ub;
dt.toFile = zW;
dt.Interactions = _b;
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ function i7(t, e) {
 const n = {},
  r = c(t, ["name"]);
 return r != null && d(n, ["_url", "name"], r), n;
}
function o7(t, e) {
 const n = {},
  r = c(t, ["name"]);
 return r != null && d(n, ["_url", "name"], r), n;
}
function s7(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 return r != null && d(n, ["sdkHttpResponse"], r), n;
}
function a7(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 return r != null && d(n, ["sdkHttpResponse"], r), n;
}
function l7(t, e, n) {
 const r = {};
 if (c(t, ["validationDataset"]) !== void 0)
  throw new Error("validationDataset parameter is not supported in Gemini API.");
 const i = c(t, ["tunedModelDisplayName"]);
 if ((e !== void 0 && i != null && d(e, ["displayName"], i), c(t, ["description"]) !== void 0))
  throw new Error("description parameter is not supported in Gemini API.");
 const o = c(t, ["epochCount"]);
 e !== void 0 && o != null && d(e, ["tuningTask", "hyperparameters", "epochCount"], o);
 const s = c(t, ["learningRateMultiplier"]);
 if (
  (s != null && d(r, ["tuningTask", "hyperparameters", "learningRateMultiplier"], s),
  c(t, ["exportLastCheckpointOnly"]) !== void 0)
 )
  throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
 if (c(t, ["preTunedModelCheckpointId"]) !== void 0)
  throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
 if (c(t, ["adapterSize"]) !== void 0) throw new Error("adapterSize parameter is not supported in Gemini API.");
 if (c(t, ["tuningMode"]) !== void 0) throw new Error("tuningMode parameter is not supported in Gemini API.");
 if (c(t, ["customBaseModel"]) !== void 0) throw new Error("customBaseModel parameter is not supported in Gemini API.");
 const a = c(t, ["batchSize"]);
 e !== void 0 && a != null && d(e, ["tuningTask", "hyperparameters", "batchSize"], a);
 const l = c(t, ["learningRate"]);
 if (
  (e !== void 0 && l != null && d(e, ["tuningTask", "hyperparameters", "learningRate"], l), c(t, ["labels"]) !== void 0)
 )
  throw new Error("labels parameter is not supported in Gemini API.");
 if (c(t, ["beta"]) !== void 0) throw new Error("beta parameter is not supported in Gemini API.");
 if (c(t, ["baseTeacherModel"]) !== void 0)
  throw new Error("baseTeacherModel parameter is not supported in Gemini API.");
 if (c(t, ["tunedTeacherModelSource"]) !== void 0)
  throw new Error("tunedTeacherModelSource parameter is not supported in Gemini API.");
 if (c(t, ["sftLossWeightMultiplier"]) !== void 0)
  throw new Error("sftLossWeightMultiplier parameter is not supported in Gemini API.");
 if (c(t, ["outputUri"]) !== void 0) throw new Error("outputUri parameter is not supported in Gemini API.");
 return r;
}
function u7(t, e, n) {
 const r = {};
 let i = c(n, ["config", "method"]);
 if ((i === void 0 && (i = "SUPERVISED_FINE_TUNING"), i === "SUPERVISED_FINE_TUNING")) {
  const M = c(t, ["validationDataset"]);
  e !== void 0 && M != null && d(e, ["supervisedTuningSpec"], jh(M));
 } else if (i === "PREFERENCE_TUNING") {
  const M = c(t, ["validationDataset"]);
  e !== void 0 && M != null && d(e, ["preferenceOptimizationSpec"], jh(M));
 } else if (i === "DISTILLATION") {
  const M = c(t, ["validationDataset"]);
  e !== void 0 && M != null && d(e, ["distillationSpec"], jh(M));
 }
 const o = c(t, ["tunedModelDisplayName"]);
 e !== void 0 && o != null && d(e, ["tunedModelDisplayName"], o);
 const s = c(t, ["description"]);
 e !== void 0 && s != null && d(e, ["description"], s);
 let a = c(n, ["config", "method"]);
 if ((a === void 0 && (a = "SUPERVISED_FINE_TUNING"), a === "SUPERVISED_FINE_TUNING")) {
  const M = c(t, ["epochCount"]);
  e !== void 0 && M != null && d(e, ["supervisedTuningSpec", "hyperParameters", "epochCount"], M);
 } else if (a === "PREFERENCE_TUNING") {
  const M = c(t, ["epochCount"]);
  e !== void 0 && M != null && d(e, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], M);
 } else if (a === "DISTILLATION") {
  const M = c(t, ["epochCount"]);
  e !== void 0 && M != null && d(e, ["distillationSpec", "hyperParameters", "epochCount"], M);
 }
 let l = c(n, ["config", "method"]);
 if ((l === void 0 && (l = "SUPERVISED_FINE_TUNING"), l === "SUPERVISED_FINE_TUNING")) {
  const M = c(t, ["learningRateMultiplier"]);
  e !== void 0 && M != null && d(e, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], M);
 } else if (l === "PREFERENCE_TUNING") {
  const M = c(t, ["learningRateMultiplier"]);
  e !== void 0 && M != null && d(e, ["preferenceOptimizationSpec", "hyperParameters", "learningRateMultiplier"], M);
 } else if (l === "DISTILLATION") {
  const M = c(t, ["learningRateMultiplier"]);
  e !== void 0 && M != null && d(e, ["distillationSpec", "hyperParameters", "learningRateMultiplier"], M);
 }
 let u = c(n, ["config", "method"]);
 if ((u === void 0 && (u = "SUPERVISED_FINE_TUNING"), u === "SUPERVISED_FINE_TUNING")) {
  const M = c(t, ["exportLastCheckpointOnly"]);
  e !== void 0 && M != null && d(e, ["supervisedTuningSpec", "exportLastCheckpointOnly"], M);
 } else if (u === "PREFERENCE_TUNING") {
  const M = c(t, ["exportLastCheckpointOnly"]);
  e !== void 0 && M != null && d(e, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], M);
 } else if (u === "DISTILLATION") {
  const M = c(t, ["exportLastCheckpointOnly"]);
  e !== void 0 && M != null && d(e, ["distillationSpec", "exportLastCheckpointOnly"], M);
 }
 let h = c(n, ["config", "method"]);
 if ((h === void 0 && (h = "SUPERVISED_FINE_TUNING"), h === "SUPERVISED_FINE_TUNING")) {
  const M = c(t, ["adapterSize"]);
  e !== void 0 && M != null && d(e, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], M);
 } else if (h === "PREFERENCE_TUNING") {
  const M = c(t, ["adapterSize"]);
  e !== void 0 && M != null && d(e, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], M);
 } else if (h === "DISTILLATION") {
  const M = c(t, ["adapterSize"]);
  e !== void 0 && M != null && d(e, ["distillationSpec", "hyperParameters", "adapterSize"], M);
 }
 let p = c(n, ["config", "method"]);
 if ((p === void 0 && (p = "SUPERVISED_FINE_TUNING"), p === "SUPERVISED_FINE_TUNING")) {
  const M = c(t, ["tuningMode"]);
  e !== void 0 && M != null && d(e, ["supervisedTuningSpec", "tuningMode"], M);
 }
 const m = c(t, ["customBaseModel"]);
 e !== void 0 && m != null && d(e, ["customBaseModel"], m);
 let v = c(n, ["config", "method"]);
 if ((v === void 0 && (v = "SUPERVISED_FINE_TUNING"), v === "SUPERVISED_FINE_TUNING")) {
  const M = c(t, ["batchSize"]);
  e !== void 0 && M != null && d(e, ["supervisedTuningSpec", "hyperParameters", "batchSize"], M);
 }
 let w = c(n, ["config", "method"]);
 if ((w === void 0 && (w = "SUPERVISED_FINE_TUNING"), w === "SUPERVISED_FINE_TUNING")) {
  const M = c(t, ["learningRate"]);
  e !== void 0 && M != null && d(e, ["supervisedTuningSpec", "hyperParameters", "learningRate"], M);
 }
 const C = c(t, ["labels"]);
 e !== void 0 && C != null && d(e, ["labels"], C);
 const A = c(t, ["beta"]);
 e !== void 0 && A != null && d(e, ["preferenceOptimizationSpec", "hyperParameters", "beta"], A);
 const T = c(t, ["baseTeacherModel"]);
 e !== void 0 && T != null && d(e, ["distillationSpec", "baseTeacherModel"], T);
 const _ = c(t, ["tunedTeacherModelSource"]);
 e !== void 0 && _ != null && d(e, ["distillationSpec", "tunedTeacherModelSource"], _);
 const E = c(t, ["sftLossWeightMultiplier"]);
 e !== void 0 && E != null && d(e, ["distillationSpec", "hyperParameters", "sftLossWeightMultiplier"], E);
 const N = c(t, ["outputUri"]);
 return e !== void 0 && N != null && d(e, ["outputUri"], N), r;
}
function c7(t, e) {
 const n = {},
  r = c(t, ["baseModel"]);
 r != null && d(n, ["baseModel"], r);
 const i = c(t, ["preTunedModel"]);
 i != null && d(n, ["preTunedModel"], i);
 const o = c(t, ["trainingDataset"]);
 o != null && E7(o);
 const s = c(t, ["config"]);
 return s != null && l7(s, n), n;
}
function d7(t, e) {
 const n = {},
  r = c(t, ["baseModel"]);
 r != null && d(n, ["baseModel"], r);
 const i = c(t, ["preTunedModel"]);
 i != null && d(n, ["preTunedModel"], i);
 const o = c(t, ["trainingDataset"]);
 o != null && T7(o, n, e);
 const s = c(t, ["config"]);
 return s != null && u7(s, n, e), n;
}
function f7(t, e) {
 const n = {},
  r = c(t, ["name"]);
 return r != null && d(n, ["_url", "name"], r), n;
}
function h7(t, e) {
 const n = {},
  r = c(t, ["name"]);
 return r != null && d(n, ["_url", "name"], r), n;
}
function p7(t, e, n) {
 const r = {},
  i = c(t, ["pageSize"]);
 e !== void 0 && i != null && d(e, ["_query", "pageSize"], i);
 const o = c(t, ["pageToken"]);
 e !== void 0 && o != null && d(e, ["_query", "pageToken"], o);
 const s = c(t, ["filter"]);
 return e !== void 0 && s != null && d(e, ["_query", "filter"], s), r;
}
function m7(t, e, n) {
 const r = {},
  i = c(t, ["pageSize"]);
 e !== void 0 && i != null && d(e, ["_query", "pageSize"], i);
 const o = c(t, ["pageToken"]);
 e !== void 0 && o != null && d(e, ["_query", "pageToken"], o);
 const s = c(t, ["filter"]);
 return e !== void 0 && s != null && d(e, ["_query", "filter"], s), r;
}
function g7(t, e) {
 const n = {},
  r = c(t, ["config"]);
 return r != null && p7(r, n), n;
}
function y7(t, e) {
 const n = {},
  r = c(t, ["config"]);
 return r != null && m7(r, n), n;
}
function v7(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["nextPageToken"]);
 i != null && d(n, ["nextPageToken"], i);
 const o = c(t, ["tunedModels"]);
 if (o != null) {
  let s = o;
  Array.isArray(s) && (s = s.map((a) => Tb(a))), d(n, ["tuningJobs"], s);
 }
 return n;
}
function _7(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["nextPageToken"]);
 i != null && d(n, ["nextPageToken"], i);
 const o = c(t, ["tuningJobs"]);
 if (o != null) {
  let s = o;
  Array.isArray(s) && (s = s.map((a) => Hm(a))), d(n, ["tuningJobs"], s);
 }
 return n;
}
function w7(t, e) {
 const n = {},
  r = c(t, ["name"]);
 r != null && d(n, ["model"], r);
 const i = c(t, ["name"]);
 return i != null && d(n, ["endpoint"], i), n;
}
function E7(t, e) {
 const n = {};
 if (c(t, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API.");
 if (c(t, ["vertexDatasetResource"]) !== void 0)
  throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
 const r = c(t, ["examples"]);
 if (r != null) {
  let i = r;
  Array.isArray(i) && (i = i.map((o) => o)), d(n, ["examples", "examples"], i);
 }
 return n;
}
function T7(t, e, n) {
 const r = {};
 let i = c(n, ["config", "method"]);
 if ((i === void 0 && (i = "SUPERVISED_FINE_TUNING"), i === "SUPERVISED_FINE_TUNING")) {
  const s = c(t, ["gcsUri"]);
  e !== void 0 && s != null && d(e, ["supervisedTuningSpec", "trainingDatasetUri"], s);
 } else if (i === "PREFERENCE_TUNING") {
  const s = c(t, ["gcsUri"]);
  e !== void 0 && s != null && d(e, ["preferenceOptimizationSpec", "trainingDatasetUri"], s);
 } else if (i === "DISTILLATION") {
  const s = c(t, ["gcsUri"]);
  e !== void 0 && s != null && d(e, ["distillationSpec", "promptDatasetUri"], s);
 }
 let o = c(n, ["config", "method"]);
 if ((o === void 0 && (o = "SUPERVISED_FINE_TUNING"), o === "SUPERVISED_FINE_TUNING")) {
  const s = c(t, ["vertexDatasetResource"]);
  e !== void 0 && s != null && d(e, ["supervisedTuningSpec", "trainingDatasetUri"], s);
 } else if (o === "PREFERENCE_TUNING") {
  const s = c(t, ["vertexDatasetResource"]);
  e !== void 0 && s != null && d(e, ["preferenceOptimizationSpec", "trainingDatasetUri"], s);
 } else if (o === "DISTILLATION") {
  const s = c(t, ["vertexDatasetResource"]);
  e !== void 0 && s != null && d(e, ["distillationSpec", "promptDatasetUri"], s);
 }
 if (c(t, ["examples"]) !== void 0) throw new Error("examples parameter is not supported in Vertex AI.");
 return r;
}
function Tb(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["name"]);
 i != null && d(n, ["name"], i);
 const o = c(t, ["state"]);
 o != null && d(n, ["state"], Ok(o));
 const s = c(t, ["createTime"]);
 s != null && d(n, ["createTime"], s);
 const a = c(t, ["tuningTask", "startTime"]);
 a != null && d(n, ["startTime"], a);
 const l = c(t, ["tuningTask", "completeTime"]);
 l != null && d(n, ["endTime"], l);
 const u = c(t, ["updateTime"]);
 u != null && d(n, ["updateTime"], u);
 const h = c(t, ["description"]);
 h != null && d(n, ["description"], h);
 const p = c(t, ["baseModel"]);
 p != null && d(n, ["baseModel"], p);
 const m = c(t, ["_self"]);
 return m != null && d(n, ["tunedModel"], w7(m)), n;
}
function Hm(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["name"]);
 i != null && d(n, ["name"], i);
 const o = c(t, ["state"]);
 o != null && d(n, ["state"], Ok(o));
 const s = c(t, ["createTime"]);
 s != null && d(n, ["createTime"], s);
 const a = c(t, ["startTime"]);
 a != null && d(n, ["startTime"], a);
 const l = c(t, ["endTime"]);
 l != null && d(n, ["endTime"], l);
 const u = c(t, ["updateTime"]);
 u != null && d(n, ["updateTime"], u);
 const h = c(t, ["error"]);
 h != null && d(n, ["error"], h);
 const p = c(t, ["description"]);
 p != null && d(n, ["description"], p);
 const m = c(t, ["baseModel"]);
 m != null && d(n, ["baseModel"], m);
 const v = c(t, ["tunedModel"]);
 v != null && d(n, ["tunedModel"], v);
 const w = c(t, ["preTunedModel"]);
 w != null && d(n, ["preTunedModel"], w);
 const C = c(t, ["supervisedTuningSpec"]);
 C != null && d(n, ["supervisedTuningSpec"], C);
 const A = c(t, ["preferenceOptimizationSpec"]);
 A != null && d(n, ["preferenceOptimizationSpec"], A);
 const T = c(t, ["distillationSpec"]);
 T != null && d(n, ["distillationSpec"], T);
 const _ = c(t, ["tuningDataStats"]);
 _ != null && d(n, ["tuningDataStats"], _);
 const E = c(t, ["encryptionSpec"]);
 E != null && d(n, ["encryptionSpec"], E);
 const N = c(t, ["partnerModelTuningSpec"]);
 N != null && d(n, ["partnerModelTuningSpec"], N);
 const M = c(t, ["customBaseModel"]);
 M != null && d(n, ["customBaseModel"], M);
 const F = c(t, ["experiment"]);
 F != null && d(n, ["experiment"], F);
 const P = c(t, ["labels"]);
 P != null && d(n, ["labels"], P);
 const I = c(t, ["outputUri"]);
 I != null && d(n, ["outputUri"], I);
 const R = c(t, ["pipelineJob"]);
 R != null && d(n, ["pipelineJob"], R);
 const k = c(t, ["serviceAccount"]);
 k != null && d(n, ["serviceAccount"], k);
 const x = c(t, ["tunedModelDisplayName"]);
 x != null && d(n, ["tunedModelDisplayName"], x);
 const D = c(t, ["veoTuningSpec"]);
 return D != null && d(n, ["veoTuningSpec"], D), n;
}
function I7(t, e) {
 const n = {},
  r = c(t, ["sdkHttpResponse"]);
 r != null && d(n, ["sdkHttpResponse"], r);
 const i = c(t, ["name"]);
 i != null && d(n, ["name"], i);
 const o = c(t, ["metadata"]);
 o != null && d(n, ["metadata"], o);
 const s = c(t, ["done"]);
 s != null && d(n, ["done"], s);
 const a = c(t, ["error"]);
 return a != null && d(n, ["error"], a), n;
}
function jh(t, e) {
 const n = {},
  r = c(t, ["gcsUri"]);
 r != null && d(n, ["validationDatasetUri"], r);
 const i = c(t, ["vertexDatasetResource"]);
 return i != null && d(n, ["validationDatasetUri"], i), n;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class S7 extends Fr {
 constructor(e) {
  super(),
   (this.apiClient = e),
   (this.list = async (n = {}) =>
    new Mo(Dr.PAGED_ITEM_TUNING_JOBS, (r) => this.listInternal(r), await this.listInternal(n), n)),
   (this.get = async (n) => await this.getInternal(n)),
   (this.tune = async (n) => {
    var r;
    if (this.apiClient.isVertexAI())
     if (n.baseModel.startsWith("projects/")) {
      const i = { tunedModelName: n.baseModel };
      !((r = n.config) === null || r === void 0) &&
       r.preTunedModelCheckpointId &&
       (i.checkpointId = n.config.preTunedModelCheckpointId);
      const o = Object.assign(Object.assign({}, n), { preTunedModel: i });
      return (o.baseModel = void 0), await this.tuneInternal(o);
     } else {
      const i = Object.assign({}, n);
      return await this.tuneInternal(i);
     }
    else {
     const i = Object.assign({}, n),
      o = await this.tuneMldevInternal(i);
     let s = "";
     return (
      o.metadata !== void 0 && o.metadata.tunedModel !== void 0
       ? (s = o.metadata.tunedModel)
       : o.name !== void 0 && o.name.includes("/operations/") && (s = o.name.split("/operations/")[0]),
      { name: s, state: km.JOB_STATE_QUEUED }
     );
    }
   });
 }
 async getInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = h7(e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => Hm(h))
   );
  } else {
   const u = f7(e);
   return (
    (a = K("{name}", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => Tb(h))
   );
  }
 }
 async listInternal(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = y7(e);
   return (
    (a = K("tuningJobs", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = _7(h),
      m = new LT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = g7(e);
   return (
    (a = K("tunedModels", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "GET",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = v7(h),
      m = new LT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async cancel(e) {
  var n, r, i, o;
  let s,
   a = "",
   l = {};
  if (this.apiClient.isVertexAI()) {
   const u = o7(e);
   return (
    (a = K("{name}:cancel", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = a7(h),
      m = new VT();
     return Object.assign(m, p), m;
    })
   );
  } else {
   const u = i7(e);
   return (
    (a = K("{name}:cancel", u._url)),
    (l = u._query),
    delete u._url,
    delete u._query,
    (s = this.apiClient
     .request({
      path: a,
      queryParams: l,
      body: JSON.stringify(u),
      httpMethod: "POST",
      httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions,
      abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal,
     })
     .then((h) =>
      h.json().then((p) => {
       const m = p;
       return (m.sdkHttpResponse = { headers: h.headers }), m;
      })
     )),
    s.then((h) => {
     const p = s7(h),
      m = new VT();
     return Object.assign(m, p), m;
    })
   );
  }
 }
 async tuneInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) {
   const a = d7(e, e);
   return (
    (o = K("tuningJobs", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) =>
      l.json().then((u) => {
       const h = u;
       return (h.sdkHttpResponse = { headers: l.headers }), h;
      })
     )),
    i.then((l) => Hm(l))
   );
  } else throw new Error("This method is only supported by the Vertex AI.");
 }
 async tuneMldevInternal(e) {
  var n, r;
  let i,
   o = "",
   s = {};
  if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
  {
   const a = c7(e);
   return (
    (o = K("tunedModels", a._url)),
    (s = a._query),
    delete a._url,
    delete a._query,
    (i = this.apiClient
     .request({
      path: o,
      queryParams: s,
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions,
      abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal,
     })
     .then((l) =>
      l.json().then((u) => {
       const h = u;
       return (h.sdkHttpResponse = { headers: l.headers }), h;
      })
     )),
    i.then((l) => I7(l))
   );
  }
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class A7 {
 async download(e, n) {
  throw new Error(
   "Download to file is not supported in the browser, please use a browser compliant download like an <a> tag."
  );
 }
}
const C7 = 1024 * 1024 * 8,
 R7 = 3,
 P7 = 1e3,
 k7 = 2,
 xd = "x-goog-upload-status";
async function b7(t, e, n) {
 var r;
 const i = await Ib(t, e, n),
  o = await (i == null ? void 0 : i.json());
 if (((r = i == null ? void 0 : i.headers) === null || r === void 0 ? void 0 : r[xd]) !== "final")
  throw new Error("Failed to upload file: Upload status is not finalized.");
 return o.file;
}
async function N7(t, e, n) {
 var r;
 const i = await Ib(t, e, n),
  o = await (i == null ? void 0 : i.json());
 if (((r = i == null ? void 0 : i.headers) === null || r === void 0 ? void 0 : r[xd]) !== "final")
  throw new Error("Failed to upload file: Upload status is not finalized.");
 const s = xk(o),
  a = new gv();
 return Object.assign(a, s), a;
}
async function Ib(t, e, n) {
 var r, i;
 let o = 0,
  s = 0,
  a = new Nm(new Response()),
  l = "upload";
 for (o = t.size; s < o; ) {
  const u = Math.min(C7, o - s),
   h = t.slice(s, s + u);
  s + u >= o && (l += ", finalize");
  let p = 0,
   m = P7;
  for (
   ;
   p < R7 &&
   ((a = await n.request({
    path: "",
    body: h,
    httpMethod: "POST",
    httpOptions: {
     apiVersion: "",
     baseUrl: e,
     headers: { "X-Goog-Upload-Command": l, "X-Goog-Upload-Offset": String(s), "Content-Length": String(u) },
    },
   })),
   !(!((r = a == null ? void 0 : a.headers) === null || r === void 0) && r[xd]));

  )
   p++, await M7(m), (m = m * k7);
  if (((s += u), ((i = a == null ? void 0 : a.headers) === null || i === void 0 ? void 0 : i[xd]) !== "active")) break;
  if (o <= s) throw new Error("All content has been uploaded, but the upload status is not finalized.");
 }
 return a;
}
async function x7(t) {
 return { size: t.size, type: t.type };
}
function M7(t) {
 return new Promise((e) => setTimeout(e, t));
}
class D7 {
 async upload(e, n, r) {
  if (typeof e == "string") throw new Error("File path is not supported in browser uploader.");
  return await b7(e, n, r);
 }
 async uploadToFileSearchStore(e, n, r) {
  if (typeof e == "string") throw new Error("File path is not supported in browser uploader.");
  return await N7(e, n, r);
 }
 async stat(e) {
  if (typeof e == "string") throw new Error("File path is not supported in browser uploader.");
  return await x7(e);
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ class L7 {
 create(e, n, r) {
  return new V7(e, n, r);
 }
}
class V7 {
 constructor(e, n, r) {
  (this.url = e), (this.headers = n), (this.callbacks = r);
 }
 connect() {
  (this.ws = new WebSocket(this.url)),
   (this.ws.onopen = this.callbacks.onopen),
   (this.ws.onerror = this.callbacks.onerror),
   (this.ws.onclose = this.callbacks.onclose),
   (this.ws.onmessage = this.callbacks.onmessage);
 }
 send(e) {
  if (this.ws === void 0) throw new Error("WebSocket is not connected");
  this.ws.send(e);
 }
 close() {
  if (this.ws === void 0) throw new Error("WebSocket is not connected");
  this.ws.close();
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const uI = "x-goog-api-key";
class U7 {
 constructor(e) {
  this.apiKey = e;
 }
 async addAuthHeaders(e, n) {
  if (e.get(uI) === null) {
   if (this.apiKey.startsWith("auth_tokens/")) throw new Error("Ephemeral tokens are only supported by the live API.");
   if (!this.apiKey) throw new Error("API key is missing. Please provide a valid API key.");
   e.append(uI, this.apiKey);
  }
 }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const O7 = "gl-node/";
class F7 {
 get interactions() {
  if (this._interactions !== void 0) return this._interactions;
  console.warn("GoogleGenAI.interactions: Interactions usage is experimental and may change in future versions.");
  const e = this.httpOptions;
  e != null &&
   e.extraBody &&
   console.warn(
    "GoogleGenAI.interactions: Client level httpOptions.extraBody is not supported by the interactions client and will be ignored."
   );
  const n = new dt({
   baseURL: this.apiClient.getBaseUrl(),
   apiKey: this.apiKey,
   apiVersion: this.apiClient.getApiVersion(),
   clientAdapter: this.apiClient,
   defaultHeaders: this.apiClient.getDefaultHeaders(),
   timeout: e == null ? void 0 : e.timeout,
  });
  return (this._interactions = n.interactions), this._interactions;
 }
 constructor(e) {
  var n;
  if (e.apiKey == null) throw new Error("An API Key must be set when running in a browser");
  if (e.project || e.location)
   throw new Error(
    "Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location."
   );
  (this.vertexai = (n = e.vertexai) !== null && n !== void 0 ? n : !1), (this.apiKey = e.apiKey);
  const r = kG(e.httpOptions, e.vertexai, void 0, void 0);
  r && (e.httpOptions ? (e.httpOptions.baseUrl = r) : (e.httpOptions = { baseUrl: r })),
   (this.apiVersion = e.apiVersion),
   (this.httpOptions = e.httpOptions);
  const i = new U7(this.apiKey);
  (this.apiClient = new x9({
   auth: i,
   apiVersion: this.apiVersion,
   apiKey: this.apiKey,
   vertexai: this.vertexai,
   httpOptions: this.httpOptions,
   userAgentExtra: O7 + "web",
   uploader: new D7(),
   downloader: new A7(),
  })),
   (this.models = new X9(this.apiClient)),
   (this.live = new z9(this.apiClient, i, new L7())),
   (this.batches = new o3(this.apiClient)),
   (this.chats = new B3(this.models, this.apiClient)),
   (this.caches = new U3(this.apiClient)),
   (this.files = new j3(this.apiClient)),
   (this.operations = new j9(this.apiClient)),
   (this.authTokens = new pW(this.apiClient)),
   (this.tunings = new S7(this.apiClient)),
   (this.fileSearchStores = new TW(this.apiClient));
 }
}
var B7 = {};
const je = "data_pengguna",
 Hi = "data_soalujian",
 Bo = "question_packets",
 qi = "data_sesiujian",
 Gi = "data_nilaiujian",
 Zh = "config_sekolah",
 $o = "data_presensi",
 rc = "data_agenda_guru",
 ep = "data_kegiatan_kelas",
 ic = "data_nilai_harian",
 cI = "config_waktu_kbm",
 dI = "data_jadwal_pelajaran",
 oc = "data_materi_belajar",
 sc = "data_silabus",
 zi = "exam_live_sessions",
 fI = (t) => {
  const e = {};
  return (
   Object.keys(t).forEach((n) => {
    t[n] !== void 0 && (e[n] = t[n]);
   }),
   e
  );
 },
 qm = {
  uploadFile: async (t, e = "uploads") => {
   try {
    const n = `${Date.now()}_${Math.floor(Math.random() * 1e3)}_${t.name.replace(/[^a-zA-Z0-9.]/g, "")}`,
     r = jH(SG, `${e}/${n}`),
     i = await QH(r, t);
    return await XH(i.ref);
   } catch (n) {
    throw (console.error("Upload failed:", n), new Error("Gagal mengupload file ke storage."));
   }
  },
  initLiveSession: async (t) => {
   const e = `${t.token}_${t.studentId}`;
   return (
    await Jr(
     ee(q, zi, e),
     { ...t, status: "ongoing", violations: 0, answeredCount: 0, lastHeartbeat: Ta(), createdAt: Ta() },
     { merge: !0 }
    ),
    e
   );
  },
  updateLiveSession: async (t, e, n) => {
   const r = `${t}_${e}`,
    i = { ...n, lastHeartbeat: Ta() };
   try {
    await Yt(ee(q, zi, r), i);
   } catch (o) {
    console.warn("Update live session failed", o);
   }
  },
  listenToLiveSession: (t, e) => {
   const n = Ee(le(q, zi), he("token", "==", t));
   return vE(n, (r) => {
    const i = r.docs.map((o) => ({ id: o.id, ...o.data() }));
    e(i);
   });
  },
  listenToMyLiveStatus: (t, e, n) => {
   const r = `${t}_${e}`;
   return vE(ee(q, zi, r), (i) => {
    i.exists() && n(i.data());
   });
  },
  resetStudentStatus: async (t, e) => {
   const n = `${t}_${e}`;
   await Yt(ee(q, zi, n), { status: "ongoing", violations: 0, lastHeartbeat: Ta() });
  },
  forceFinishStudent: async (t, e) => {
   const n = `${t}_${e}`;
   await Yt(ee(q, zi, n), { status: "submitted", lastHeartbeat: Ta() });
  },
  deleteLiveSession: async (t, e) => {
   const n = `${t}_${e}`;
   await Mn(ee(q, zi, n));
  },
  getSyllabus: async (t) => {
   try {
    const e = le(q, sc),
     n = [];
    t.guru_id && n.push(he("guru_id", "==", t.guru_id));
    const r = Ee(e, ...n);
    let o = (await Ve(r)).docs.map((s) => ({ id: s.id, ...s.data() }));
    return (
     t.mapel && (o = o.filter((s) => s.mapel === t.mapel)),
     t.kelas &&
      (o = o.filter((s) => {
       var a;
       return s.kelas === t.kelas || ((a = t.kelas) == null ? void 0 : a.startsWith(s.kelas));
      })),
     o
    );
   } catch (e) {
    return console.error("Error fetching syllabus:", e), [];
   }
  },
  addSyllabus: async (t) => (await Yn(le(q, sc), { ...t, createdAt: new Date() }), !0),
  deleteSyllabus: async (t) => (await Mn(ee(q, sc, t)), !0),
  updateSyllabus: async (t, e) => (await Yt(ee(q, sc, t), e), !0),
  generateQuestionsWithAI: async (t) => {
   try {
    const e = new F7({ apiKey: B7.API_KEY }),
     n = `Buatkan ${t.jumlah} soal pilihan ganda untuk mata pelajaran ${t.mapel} kelas ${t.kelas} tentang topik "${t.topic}". Berikan output HANYA dalam format JSON valid. Pastikan soal bervariasi dan edukatif. Jangan gunakan markdown.`,
     i = (
      await e.models.generateContent({
       model: "gemini-3-flash-preview",
       contents: n,
       config: {
        responseMimeType: "application/json",
        responseSchema: {
         type: Rt.ARRAY,
         items: {
          type: Rt.OBJECT,
          properties: {
           pertanyaan: { type: Rt.STRING },
           pilihanJawaban: {
            type: Rt.ARRAY,
            items: {
             type: Rt.OBJECT,
             properties: { opsiId: { type: Rt.STRING }, teksOpsi: { type: Rt.STRING } },
             required: ["opsiId", "teksOpsi"],
            },
           },
           kunci: { type: Rt.STRING },
          },
          required: ["pertanyaan", "pilihanJawaban", "kunci"],
         },
        },
       },
      })
     ).text;
    if (!i) throw new Error("Gagal generate konten dari AI.");
    return JSON.parse(i).map((a, l) => ({
     id: `ai_${Date.now()}_${l}`,
     jenis_soal: "PG",
     mapel: t.mapel,
     kelas: t.kelas,
     materi: t.topic,
     pertanyaan: a.pertanyaan,
     gambar: "",
     pilihanJawaban: a.pilihanJawaban.map((u) => ({
      opsiId: u.opsiId,
      teksOpsi: u.teksOpsi,
      kunci: u.opsiId === a.kunci,
     })),
     kunci: a.kunci,
     author: "AI Assistant",
     createdAt: new Date(),
    }));
   } catch (e) {
    throw (console.error("AI Generation Error:", e), e);
   }
  },
  getMaterials: async (t) => {
   try {
    let e = Ee(le(q, oc), Ea("createdAt", "desc")),
     r = (await Ve(e)).docs.map((i) => {
      var o;
      return {
       id: i.id,
       ...i.data(),
       createdAt: (o = i.data().createdAt) != null && o.toDate ? i.data().createdAt.toDate() : new Date(),
      };
     });
    return (
     t.kelas &&
      t.kelas !== "Semua Kelas" &&
      (r = r.filter((i) => {
       var o;
       return i.kelas === "Semua" || i.kelas === t.kelas || ((o = t.kelas) == null ? void 0 : o.startsWith(i.kelas));
      })),
     t.mapel && t.mapel !== "Semua Mapel" && (r = r.filter((i) => i.mapel === t.mapel)),
     r
    );
   } catch (e) {
    return console.error(e), [];
   }
  },
  saveMaterial: async (t) => (await Yn(le(q, oc), { ...t, createdAt: new Date() }), !0),
  updateMaterial: async (t, e) => (await Yt(ee(q, oc, t), e), !0),
  deleteMaterial: async (t) => (await Mn(ee(q, oc, t)), !0),
  analyzeExamSession: async (t) => {
   try {
    const e = ee(q, qi, t),
     n = await Kr(e);
    if (!n.exists()) throw new Error("Sesi tidak ditemukan");
    const r = n.data();
    let i = [];
    if (r.mode === "PACKET" && r.packetId) {
     const _ = await Kr(ee(q, Bo, r.packetId));
     if (_.exists()) {
      const E = _.data();
      i = Array.isArray(E == null ? void 0 : E.questionIds) ? E.questionIds : [];
     }
    } else {
     const _ = Ee(le(q, Hi), he("mapel", "==", r.mapel), he("materi", "==", r.materi));
     i = (await Ve(_)).docs
      .sort((N, M) => {
       var F, P;
       return (
        (((F = N.data().createdAt) == null ? void 0 : F.seconds) || 0) -
        (((P = M.data().createdAt) == null ? void 0 : P.seconds) || 0)
       );
      })
      .map((N) => N.id);
    }
    const o = Ee(le(q, Gi), he("token", "==", r.token)),
     a = (await Ve(o)).docs.map((_) => _.data());
    if (a.length === 0) return [];
    const l = a.map((_) => {
      const E = _.ans ?? {},
       N = {};
      return (
       Object.keys(E).forEach((M) => {
        !isNaN(Number(M)) && M.length < 5 && i[Number(M)] ? (N[i[Number(M)]] = E[M]) : (N[M] = E[M]);
       }),
       { ..._, ans: N }
      );
     }),
     u = new Set();
    if (
     (l.forEach((_) => {
      _.ans && Object.keys(_.ans).forEach((E) => u.add(E));
     }),
     u.size === 0)
    )
     return [];
    const h = Array.from(u).map((_) => Kr(ee(q, Hi, _))),
     p = await Promise.all(h),
     m = new Map();
    p.forEach((_) => {
     _.exists() && m.set(_.id, { id: _.id, ..._.data() });
    }),
     l.sort((_, E) => E.nilai - _.nilai);
    const v = l.length,
     w = Math.max(1, Math.ceil(v * 0.27)),
     C = l.slice(0, w),
     A = l.slice(v - w, v),
     T = [];
    return (
     u.forEach((_) => {
      const E = m.get(_);
      if (!E || (E.jenis_soal !== "PG" && E.jenis_soal !== "PG_KOMPLEKS" && E.jenis_soal !== "BENAR_SALAH")) return;
      let N = 0,
       M = 0,
       F = 0,
       P = 0;
      const I = (b) => (E.jenis_soal === "PG", String(b) === String(E.kunci));
      if (
       (l.forEach((b) => {
        const se = b.ans ? b.ans[_] : null;
        se != null && (P++, I(se) && N++);
       }),
       C.forEach((b) => {
        const se = b.ans ? b.ans[_] : null;
        se != null && I(se) && M++;
       }),
       A.forEach((b) => {
        const se = b.ans ? b.ans[_] : null;
        se != null && I(se) && F++;
       }),
       P === 0)
      )
       return;
      const R = N / P;
      let k = "Sedang";
      R > 0.7 ? (k = "Mudah") : R < 0.3 && (k = "Sukar");
      const x = (M - F) / w;
      let D = "Jelek";
      x >= 0.4 ? (D = "Sangat Baik") : x >= 0.3 ? (D = "Baik") : x >= 0.2 && (D = "Cukup"),
       T.push({
        questionId: _,
        questionText: E.pertanyaan,
        difficultyIndex: parseFloat(R.toFixed(2)),
        discriminationIndex: parseFloat(x.toFixed(2)),
        difficultyCategory: k,
        discriminationCategory: D,
        totalCorrect: N,
        totalAttempts: P,
       });
     }),
     T
    );
   } catch (e) {
    throw (console.error("Analysis Error:", e), e);
   }
  },
  getSchoolConfig: async () => {
   try {
    const t = ee(q, Zh, "utama"),
     e = await Kr(t);
    return e.exists() ? e.data() : null;
   } catch (t) {
    return console.warn("Config fetch failed:", t), null;
   }
  },
  updateSchoolConfig: async (t) => {
   const e = ee(q, Zh, "utama");
   return await Jr(e, t, { merge: !0 }), !0;
  },
  promoteStudents: async () => {
   const t = Ee(le(q, je), he("role", "in", ["Siswa", "Student"])),
    e = await Ve(t),
    n = Fo(q);
   let r = 0;
   return (
    e.docs.forEach((i) => {
     const s = i.data().kelas || "";
     let a = s;
     s.startsWith("X-") || s.startsWith("10-")
      ? (a = s.replace("X-", "XI-").replace("10-", "11-"))
      : s.startsWith("XI-") || s.startsWith("11-")
        ? (a = s.replace("XI-", "XII-").replace("11-", "12-"))
        : (s.startsWith("XII-") || s.startsWith("12-")) && (a = "Alumni"),
      a !== s && (n.update(i.ref, { kelas: a, promotedAt: new Date() }), r++);
    }),
    r > 0 && (await n.commit()),
    r
   );
  },
  getDashboardStats: async () => {
   var t, e, n;
   try {
    const r = le(q, je),
     i = Ee(r, he("role", "in", ["Siswa", "Student"])),
     s = ((t = (await Yu(i)).data()) == null ? void 0 : t.count) || 0,
     a = le(q, Hi),
     u = ((e = (await Yu(a)).data()) == null ? void 0 : e.count) || 0,
     h = le(q, qi),
     p = Ee(h, he("status", "==", "aktif")),
     v = ((n = (await Yu(p)).data()) == null ? void 0 : n.count) || 0,
     w = Ee(le(q, Gi), Ea("timestamp", "desc"), mE(100)),
     C = await Ve(w),
     A = {};
    C.forEach((_) => {
     const E = _.data();
     E.kelas &&
      E.nilai !== void 0 &&
      (A[E.kelas] || (A[E.kelas] = { total: 0, count: 0 }),
      (A[E.kelas].total += Number(E.nilai)),
      (A[E.kelas].count += 1));
    });
    const T = Object.keys(A)
     .map((_) => ({ name: _, avg: Math.round(A[_].total / A[_].count) }))
     .sort((_, E) => E.avg - _.avg)
     .slice(0, 7);
    return { totalStudents: s, totalQuestions: u, activeSessions: v, chartData: T };
   } catch (r) {
    return (
     console.error("Dashboard Stats Error:", r),
     { totalStudents: 0, totalQuestions: 0, activeSessions: 0, chartData: [] }
    );
   }
  },
  register: async (t, e, n, r) => {
   const o = (await Gu(Yi, t, e)).user;
   let s = "Siswa";
   (r === "TEACHER" || r === "Guru") && (s = "Guru"),
    (r === "ADMIN" || r === "Admin") && (s = "Admin"),
    (r === "PICKET" || r === "Piket") && (s = "Piket");
   const a = { nama: n, email: t, role: s, status: "aktif", poin_keaktifan: 0, createdAt: new Date() };
   return await Jr(ee(q, je, o.uid), a), { id: o.uid, ...a };
  },
  login: async (t, e) => {
   try {
    const r = (await TO(Yi, t, e)).user;
    let i = await Kr(ee(q, je, r.uid));
    if (!i.exists()) {
     const s = Ee(le(q, je), he("email", "==", t)),
      a = await Ve(s);
     if (!a.empty) {
      const l = a.docs[0],
       h = { ...l.data(), id: r.uid, status: "aktif", migratedAt: new Date() },
       p = Fo(q);
      return p.set(ee(q, je, r.uid), h), p.delete(l.ref), await p.commit(), h;
     }
     throw new Error("access-denied: Data pengguna tidak ditemukan. Hubungi Admin.");
    }
    const o = i.data();
    if (!o) throw new Error("user-not-found: Data user tidak ditemukan.");
    if (o.status === "suspended") throw new Error("access-denied: Akun ditangguhkan.");
    return {
     id: i.id,
     nama: o.nama ?? "",
     email: o.email ?? "",
     role: o.role ?? "student",
     kelas: o.kelas ?? "",
     status: o.status ?? "active",
     poin_keaktifan: o.poin_keaktifan ?? 0,
     username: o.email ?? "",
     teachingAssignments: o.teachingAssignments ?? [],
     nip: o.nip ?? "",
     no_hp: o.no_hp ?? "",
     alamat: o.alamat ?? "",
     bio: o.bio ?? "",
    };
   } catch (n) {
    if (n.code === "auth/user-not-found" || n.code === "auth/invalid-credential" || n.code === "auth/wrong-password")
     try {
      const i = (await Gu(Yi, t, e)).user,
       o = Ee(le(q, je), he("email", "==", t)),
       s = await Ve(o);
      if (!s.empty) {
       const a = s.docs[0],
        l = a.data();
       if (String(l.password).trim() === e) {
        const h = { ...l, id: i.uid, status: "aktif", migratedAt: new Date() },
         p = Fo(q);
        return p.set(ee(q, je, i.uid), h), p.delete(ee(q, je, a.id)), await p.commit(), h;
       }
      }
      if ((await i.delete(), !s.empty)) throw new Error("Password salah. Pastikan sesuai data dari guru.");
     } catch (r) {
      if ((console.error("Auto-reg failed:", r), r.code === "auth/email-already-in-use"))
       throw new Error("Password salah atau akun sudah aktif.");
     }
    throw n;
   }
  },
  logout: async () => {
   await w0(Yi), localStorage.removeItem("LMS_EXAM_STATE");
  },
  changeUserPassword: async (t) => {
   const e = Yi.currentUser;
   if (!e) throw new Error("User not authenticated");
   return await IO(e, t), await Yt(ee(q, je, e.uid), { password: t }), !0;
  },
  getTimeConfig: async () => {
   try {
    const t = ee(q, cI, "default"),
     e = await Kr(t);
    return e.exists() ? e.data() : { jumlah_jam: 10, slots: [] };
   } catch (t) {
    return console.error(t), { jumlah_jam: 10, slots: [] };
   }
  },
  saveTimeConfig: async (t) => {
   await Jr(ee(q, cI, "default"), t);
  },
  getSchedules: async (t) => {
   try {
    let e = Ee(le(q, dI));
    return (
     t.kelas && t.kelas !== "Semua Kelas" && (e = Ee(e, he("kelas", "==", t.kelas))),
     t.hari && (e = Ee(e, he("hari", "==", t.hari))),
     t.guru_id && (e = Ee(e, he("guru_id", "==", t.guru_id))),
     (await Ve(e)).docs.map((i) => ({ id: i.id, ...i.data() })).sort((i, o) => i.jam_ke - o.jam_ke)
    );
   } catch (e) {
    return console.error("Error fetching schedules", e), [];
   }
  },
  saveScheduleItem: async (t) => {
   const e = `${t.kelas}_${t.hari}_${t.jam_ke}`;
   await Jr(ee(q, dI, e), { ...t, id: e });
  },
  getUserById: async (t) => {
   try {
    const e = await Kr(ee(q, je, t));
    if (!e.exists()) return null;
    const n = e.data();
    return n
     ? {
        id: e.id,
        nama: n.nama ?? "",
        email: n.email ?? "",
        role: n.role ?? "student",
        kelas: n.kelas ?? "",
        status: n.status ?? "active",
        poin_keaktifan: n.poin_keaktifan ?? 0,
        username: n.email ?? "",
        teachingAssignments: n.teachingAssignments ?? [],
        nip: n.nip ?? "",
        no_hp: n.no_hp ?? "",
        alamat: n.alamat ?? "",
        bio: n.bio ?? "",
       }
     : null;
   } catch (e) {
    return console.error("Error getUserById:", e), null;
   }
  },
  getUsers: async (t) => {
   let e = le(q, je);
   const n = [];
   t != null && t.kelas && t.kelas !== "Semua Kelas" && n.push(he("kelas", "==", t.kelas));
   const r = n.length ? Ee(e, ...n) : e;
   return (await Ve(r)).docs
    .map((s) => {
     const a = s.data();
     return { id: s.id, ...a, poin_keaktifan: a.poin_keaktifan || 0 };
    })
    .sort((s, a) =>
     s.status === "pending_auth" && a.status !== "pending_auth"
      ? -1
      : s.status !== "pending_auth" && a.status === "pending_auth"
        ? 1
        : s.nama.localeCompare(a.nama)
    );
  },
  createUserDirect: async (t) => {
   const e = t.password || "123456";
   let n = "";
   try {
    let i;
    try {
     i = Gl("SecondaryApp");
    } catch {
     i = ay(su.options, "SecondaryApp");
    }
    const o = IR(i);
    (n = (await Gu(o, t.email, e)).user.uid), await w0(o);
   } catch (i) {
    throw i.code === "auth/email-already-in-use" ? new Error("Email sudah terdaftar di sistem Authentication.") : i;
   }
   const r = fI(t);
   return (
    await Jr(ee(q, je, n), {
     ...r,
     id: n,
     createdAt: new Date(),
     status: t.status || "aktif",
     poin_keaktifan: 0,
     password: e,
    }),
    !0
   );
  },
  updateUser: async (t, e) => {
   const n = fI(e);
   return await Yt(ee(q, je, t), n), !0;
  },
  deleteUser: async (t) => (await Mn(ee(q, je, t)), !0),
  bulkDeleteUsers: async (t) => {
   const e = Fo(q);
   return (
    t.forEach((n) => {
     const r = ee(q, je, n);
     e.delete(r);
    }),
    await e.commit(),
    !0
   );
  },
  importUsers: async (t) => {
   const e = Fo(q);
   return (
    t.forEach((n) => {
     const r = ee(le(q, je));
     e.set(r, { ...n, createdAt: new Date(), status: "pending_auth", poin_keaktifan: 0 });
    }),
    await e.commit(),
    !0
   );
  },
  updateStudentPoints: async (t, e) => {
   const n = ee(q, je, t);
   return await Yt(n, { poin_keaktifan: H$(e) }), !0;
  },
  getAttendanceSession: async (t, e, n) => {
   try {
    const r = Ee(le(q, $o), he("tanggal", "==", t), he("kelas", "==", e), he("mapel", "==", n)),
     i = await Ve(r);
    if (!i.empty) {
     const o = i.docs[0],
      s = o.data();
     let a = s.records || [];
     return (
      (!a || a.length === 0) &&
       s.data_absensi &&
       Array.isArray(s.data_absensi) &&
       (a = s.data_absensi.map((l) => ({
        uid: l.uid || l.id,
        nama: l.nama,
        status: l.status,
        keterangan: l.keterangan || "",
       }))),
      { id: o.id, ...s, records: a }
     );
    }
    return null;
   } catch (r) {
    return console.error("Error getAttendanceSession:", r), null;
   }
  },
  saveAttendance: async (t) => {
   try {
    const e = Ee(le(q, $o), he("tanggal", "==", t.tanggal), he("kelas", "==", t.kelas), he("mapel", "==", t.mapel)),
     n = await Ve(e),
     r = { ...t, updatedAt: new Date() };
    if (n.empty) await Yn(le(q, $o), { ...r, createdAt: new Date() });
    else {
     const i = n.docs[0].id;
     await Yt(ee(q, $o, i), r);
    }
    return !0;
   } catch (e) {
    throw (console.error("Error saveAttendance:", e), e);
   }
  },
  deleteAttendanceSession: async (t, e, n) => {
   try {
    const r = Ee(le(q, $o), he("tanggal", "==", t), he("kelas", "==", e), he("mapel", "==", n)),
     i = await Ve(r),
     o = Fo(q);
    return i.empty
     ? !1
     : (i.docs.forEach((s) => {
        o.delete(s.ref);
       }),
       await o.commit(),
       !0);
   } catch (r) {
    throw (console.error("Error deleteAttendanceSession:", r), r);
   }
  },
  getAttendanceHistory: async (t, e) => {
   try {
    const n = Ee(le(q, $o), he("kelas", "==", t), he("mapel", "==", e));
    return (await Ve(n)).docs
     .map((o) => {
      const s = o.data();
      let a = s.records || [];
      return (
       (!a || a.length === 0) &&
        s.data_absensi &&
        (a = s.data_absensi.map((l) => ({
         uid: l.uid || l.id,
         nama: l.nama,
         status: l.status,
         keterangan: l.keterangan || "",
        }))),
       { id: o.id, ...s, records: a }
      );
     })
     .sort((o, s) => new Date(o.tanggal).getTime() - new Date(s.tanggal).getTime());
   } catch (n) {
    return console.error(n), [];
   }
  },
  getJournals: async (t) => {
   try {
    let e = Ee(le(q, rc), Ea("tanggal", "desc"));
    t.teacherId && (e = Ee(le(q, rc), he("guru_id", "==", t.teacherId)));
    let r = (await Ve(e)).docs.map((i) => {
     var s;
     const o = i.data();
     return {
      id: i.id,
      ...o,
      attendance_summary: o.attendance_summary || { H: 0, S: 0, I: 0, A: 0 },
      created_at: (s = o.created_at) != null && s.toDate ? o.created_at.toDate() : new Date(o.created_at),
     };
    });
    return (
     t.kelas && t.kelas !== "Semua Kelas" && (r = r.filter((i) => i.kelas === t.kelas)),
     r.sort((i, o) => new Date(o.tanggal).getTime() - new Date(i.tanggal).getTime())
    );
   } catch (e) {
    return console.error(e), [];
   }
  },
  addJournal: async (t) => (await Yn(le(q, rc), { ...t, created_at: new Date() }), !0),
  deleteJournal: async (t) => (await Mn(ee(q, rc, t)), !0),
  getClassActivities: async (t) => {
   try {
    const e = Ee(le(q, ep), Ea("timestamp", "desc"), mE(50));
    let r = (await Ve(e)).docs.map((i) => {
     var s;
     const o = i.data();
     return {
      id: i.id,
      ...o,
      timestamp: (s = o.timestamp) != null && s.toDate ? o.timestamp.toDate() : new Date(o.timestamp),
     };
    });
    return t && t !== "Semua Kelas" && (r = r.filter((i) => i.kelas === t || i.kelas === "Semua Kelas")), r;
   } catch (e) {
    return console.error(e), [];
   }
  },
  addClassActivity: async (t) => (await Yn(le(q, ep), { ...t, timestamp: new Date() }), !0),
  deleteClassActivity: async (t) => (await Mn(ee(q, ep, t)), !0),
  saveDailyGrade: async (t) => (await Yn(le(q, ic), { ...t, timestamp: new Date() }), !0),
  updateDailyGrade: async (t, e) => (await Yt(ee(q, ic, t), e), !0),
  deleteDailyGrade: async (t) => (await Mn(ee(q, ic, t)), !0),
  getDailyGrades: async (t) => {
   let e = Ee(le(q, ic), Ea("timestamp", "desc")),
    r = (await Ve(e)).docs.map((i) => {
     var u;
     const o = i.data();
     let s = [];
     if (Array.isArray(o.records)) s = o.records;
     else if (o.records && typeof o.records == "object") s = Object.values(o.records);
     else if (Array.isArray(o.detail_nilai)) s = o.detail_nilai;
     else {
      const h = [];
      Object.keys(o).forEach((p) => {
       if (!isNaN(Number(p))) {
        const m = o[p];
        m && typeof m == "object" && m.uid && h.push(m);
       }
      }),
       h.length > 0 && (s = h);
     }
     s = s.map((h) => ({
      uid: h.uid,
      nama: h.nama || "",
      nilai: Number(h.nilai || 0),
      nilai_skala: Number(h.nilai_skala || 0),
     }));
     const a = s.reduce((h, p) => h + (p.nilai_skala || 0), 0),
      l = s.length > 0 ? Math.round(a / s.length) : 0;
     return {
      id: i.id,
      ...o,
      records: s,
      rata_rata: l,
      timestamp: (u = o.timestamp) != null && u.toDate ? o.timestamp.toDate() : new Date(o.timestamp || Date.now()),
     };
    });
   return (
    t.kelas && t.kelas !== "Semua Kelas" && (r = r.filter((i) => i.kelas === t.kelas)),
    t.mapel && t.mapel !== "Semua Mapel" && (r = r.filter((i) => i.mapel === t.mapel)),
    r
   );
  },
  getQuestions: async (t) => {
   let e = le(q, Hi);
   const n = [];
   t != null && t.kelas && t.kelas !== "Semua Kelas" && n.push(he("kelas", "==", t.kelas)),
    t != null && t.mapel && t.mapel !== "Semua Mapel" && n.push(he("mapel", "==", t.mapel)),
    t != null && t.materi && t.materi !== "Semua Materi" && n.push(he("materi", "==", t.materi));
   const r = n.length ? Ee(e, ...n) : e,
    i = await Ve(r),
    o = [];
   return (
    i.forEach((s) => {
     var v, w;
     if (t != null && t.ids && t.ids.length > 0 && !t.ids.includes(s.id)) return;
     const a = s.data(),
      l = a.jenis_soal,
      u = a.kunci;
     let h = [];
     const p = a.opsi || a.pilihanJawaban || [],
      m = Array.isArray(p) ? p : Object.values(p);
     l === "PG" || l === "PG_KOMPLEKS"
      ? (h = m.map((C) => ({
         opsiId: C.label || C.opsiId || "",
         teksOpsi: C.text || C.teksOpsi || "",
         gambar: C.img || C.gambar || "",
         kunci:
          l === "PG" ? String(u) === String(C.label || C.opsiId) : Array.isArray(u) && u.includes(C.label || C.opsiId),
        })))
      : l === "BENAR_SALAH" &&
        (h = m.map((C, A) => ({
         opsiId: String(A + 1),
         teksOpsi: C.teksOpsi || C.text || "",
         gambar: C.gambar || "",
         kunci: C.kunci === "BENAR" || C.kunci === !0,
        }))),
      o.push({
       id: s.id,
       jenis_soal: l,
       mapel: a.mapel,
       kelas: a.kelas,
       materi: a.materi,
       tp: a.tp,
       pertanyaan: a.pertanyaan,
       gambar: a.gambar || "",
       pilihanJawaban: h,
       kunci: u,
       author: a.author || "Anonim",
       authorId: a.authorId || "",
       createdAt: ((w = (v = a.createdAt) == null ? void 0 : v.toDate) == null ? void 0 : w.call(v)) || new Date(),
      });
    }),
    o.sort((s, a) => {
     const l = s.createdAt ? s.createdAt.getTime() : 0;
     return (a.createdAt ? a.createdAt.getTime() : 0) - l;
    })
   );
  },
  addQuestion: async (t) => {
   const e = t.pilihanJawaban.map((r) => {
     const i = { label: r.opsiId, text: r.teksOpsi, img: r.gambar || "" };
     return t.jenis_soal === "BENAR_SALAH" && (i.kunci = r.kunci ? "BENAR" : "SALAH"), i;
    }),
    n = {
     ...t,
     gambar: t.gambar || "",
     opsi: e,
     author: t.author || "Guru",
     authorId: t.authorId || "",
     createdAt: new Date(),
    };
   return (
    delete n.pilihanJawaban, Object.keys(n).forEach((r) => n[r] === void 0 && delete n[r]), await Yn(le(q, Hi), n), !0
   );
  },
  updateQuestion: async (t, e) => {
   const n = { ...e };
   return (
    e.pilihanJawaban &&
     ((n.opsi = e.pilihanJawaban.map((r) => {
      const i = { label: r.opsiId, text: r.teksOpsi, img: r.gambar || "" };
      return e.jenis_soal === "BENAR_SALAH" && (i.kunci = r.kunci ? "BENAR" : "SALAH"), i;
     })),
     delete n.pilihanJawaban),
    Object.keys(n).forEach((r) => n[r] === void 0 && delete n[r]),
    await Yt(ee(q, Hi, t), n),
    !0
   );
  },
  deleteQuestion: async (t) => (await Mn(ee(q, Hi, t)), !0),
  createPacket: async (t, e, n, r) => (
   await Yn(le(q, Bo), { name: t, questionIds: e, subject: n, classLevel: r, createdAt: new Date() }), !0
  ),
  updatePacket: async (t, e) => {
   const { id: n, ...r } = e;
   return await Yt(ee(q, Bo, t), r), !0;
  },
  deletePacket: async (t) => (await Mn(ee(q, Bo, t)), !0),
  getPackets: async () => (await Ve(le(q, Bo))).docs.map((e) => ({ id: e.id, ...e.data() })),
  getPacketById: async (t) => {
   const e = await Kr(ee(q, Bo, t));
   return e.exists() ? { id: e.id, ...e.data() } : null;
  },
  getSessions: async () => {
   const t = Ee(le(q, qi));
   return (await Ve(t)).docs
    .map((n) => {
     var o;
     const r = n.data(),
      i = r.createdAt || r.created_at;
     return {
      id: n.id,
      ...r,
      max_kesempatan: r.max_kesempatan || r.limit || 1,
      createdAt: ((o = i == null ? void 0 : i.toDate) == null ? void 0 : o.call(i)) || new Date(),
     };
    })
    .sort((n, r) => r.createdAt.getTime() - n.createdAt.getTime());
  },
  createSession: async (t) => (await Yn(le(q, qi), { ...t, createdAt: new Date() }), !0),
  updateSessionStatus: async (t, e) => (await Yt(ee(q, qi, t), { status: e }), !0),
  deleteSession: async (t) => (await Mn(ee(q, qi, t)), !0),
  verifyToken: async (t, e, n) => {
   const r = Ee(le(q, qi), he("token", "==", t)),
    i = await Ve(r);
   if (i.empty) throw new Error("Token tidak ditemukan.");
   const o = i.docs[0],
    s = o.data();
   if (((s.id = o.id), s.status !== "aktif")) throw new Error("Ujian ini sudah tidak aktif / ditutup.");
   if (s.kelas_spesifik !== "Semua" && !s.kelas_spesifik.includes(e))
    throw new Error(`Anda kelas ${e}, ujian ini khusus untuk ${s.kelas_spesifik}.`);
   const a = Ee(le(q, Gi), he("token", "==", t), he("userId", "==", n)),
    u = (await Ve(a)).size,
    h = s.max_kesempatan || 1;
   if (u >= h) throw new Error(`Anda sudah mengerjakan ujian ini. Batas kesempatan: ${h}x.`);
   return s;
  },
  getExamResults: async (t) => {
   let e = le(q, Gi);
   const n = [];
   t != null && t.token && t.token !== "semua" && n.push(he("token", "==", t.token));
   const r = n.length ? Ee(e, ...n) : e,
    i = await Ve(r),
    o = [];
   return (
    i.forEach((s) => {
     var u;
     const a = s.data(),
      l = (u = a.timestamp) != null && u.toDate ? a.timestamp.toDate() : new Date(a.timestamp || Date.now());
     o.push({
      id: s.id,
      userId: a.userId || "",
      nama: a.nama || "Tanpa Nama",
      kelas: a.kelas || "-",
      mapel: a.mapel || "-",
      token: a.token || "-",
      nilai: typeof a.nilai == "number" ? a.nilai : 0,
      violations: typeof a.violations == "number" ? a.violations : 0,
      timestamp: l,
      ans: a.ans || {},
     });
    }),
    o.sort((s, a) => a.timestamp.getTime() - s.timestamp.getTime())
   );
  },
  saveExamResult: async (t) => (await Yn(le(q, Gi), { ...t, timestamp: new Date() }), !0),
  deleteExamResult: async (t) => (await Mn(ee(q, Gi, t)), !0),
  updateExamResult: async (t, e) => (await Yt(ee(q, Gi, t), e), !0),
  initializeSystem: async (t, e) => {
   var o;
   if (((o = (await Yu(le(q, je))).data()) == null ? void 0 : o.count) > 0) return !1;
   const r = await Gu(Yi, t, e),
    i = { nama: "Super Admin", email: t, role: "Admin", status: "aktif", createdAt: new Date(), password: e };
   return (
    await Jr(ee(q, je, r.user.uid), i),
    await Jr(ee(q, Zh, "utama"), {
     tahun: new Date().getFullYear() + "/" + (new Date().getFullYear() + 1),
     semester: "Ganjil",
     daftar_mapel: ["Matematika", "Bahasa Indonesia", "Bahasa Inggris"],
    }),
    !0
   );
  },
 },
 $7 = ({ onLogout: t, userRole: e }) => {
  const n = Ao(),
   r = Xd(),
   [i, o] = W.useState({ name: "LMS Pro", logo: "" });
  W.useEffect(() => {
   (async () => {
    const p = await qm.getSchoolConfig();
    p && o({ name: p.namaSekolah || "LMS Pro", logo: p.logoUrl || "" });
   })();
  }, []);
  const s = () => {
    vl
     .fire({
      title: "Logout?",
      text: "Anda harus login kembali untuk mengakses sistem.",
      icon: "warning",
      showCancelButton: !0,
      confirmButtonColor: "#3b82f6",
      cancelButtonColor: "#ef4444",
      confirmButtonText: "Ya, Logout",
     })
     .then((h) => {
      h.isConfirmed && (t(), r("/"));
     });
   },
   a = (h) => n.pathname === h,
   l = (h) =>
    `flex items-center gap-3 px-4 py-3 rounded-lg transition-all duration-200 ${a(h) ? "bg-blue-600 text-white shadow-md" : "text-slate-500 hover:bg-slate-100 hover:text-blue-600"}`,
   u = (h) => {
    const p = (e || "").toLowerCase();
    let m = "STUDENT";
    return p === "admin" ? (m = "ADMIN") : (p === "guru" || p === "teacher") && (m = "TEACHER"), h.includes(m);
   };
  return L.jsxs("aside", {
   className: "w-64 bg-white border-r border-slate-200 h-screen fixed left-0 top-0 z-30 flex flex-col",
   children: [
    L.jsxs("div", {
     className: "p-6 border-b border-slate-100 flex items-center gap-3",
     children: [
      i.logo
       ? L.jsx("img", { src: i.logo, alt: "Logo", className: "w-8 h-8 object-contain" })
       : L.jsx("div", {
          className: "w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center text-white font-bold",
          children: i.name.charAt(0),
         }),
      L.jsx("h1", {
       className: "text-lg font-bold text-slate-800 tracking-tight truncate",
       title: i.name,
       children: i.name,
      }),
     ],
    }),
    L.jsxs("nav", {
     className: "flex-1 p-4 space-y-1 overflow-y-auto",
     children: [
      L.jsx("div", {
       className: "text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2 px-4 mt-2",
       children: "Main Menu",
      }),
      L.jsxs(rt, {
       to: "/dashboard",
       className: l("/dashboard"),
       children: [L.jsx(QM, { size: 20 }), L.jsx("span", { children: "Dashboard" })],
      }),
      u(["TEACHER", "ADMIN"]) &&
       L.jsxs(L.Fragment, {
        children: [
         L.jsxs(rt, {
          to: "/dashboard/teacher-profile",
          className: l("/dashboard/teacher-profile"),
          children: [L.jsx($M, { size: 20 }), L.jsx("span", { children: "Profil & Perangkat" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/bank",
          className: l("/dashboard/bank"),
          children: [L.jsx(BM, { size: 20 }), L.jsx("span", { children: "Bank Soal" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/packets",
          className: l("/dashboard/packets"),
          children: [L.jsx(ZM, { size: 20 }), L.jsx("span", { children: "Kelola Paket" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/sessions",
          className: l("/dashboard/sessions"),
          children: [L.jsx(HM, { size: 20 }), L.jsx("span", { children: "Sesi Ujian" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/monitoring",
          className: l("/dashboard/monitoring"),
          children: [L.jsx(jM, { size: 20 }), L.jsx("span", { children: "Live Monitor" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/student-monitor",
          className: l("/dashboard/student-monitor"),
          children: [L.jsx(FM, { size: 20 }), L.jsx("span", { children: "Monitoring Nilai" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/materials",
          className: l("/dashboard/materials"),
          children: [L.jsx(XM, { size: 20 }), L.jsx("span", { children: "E-Library & Materi" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/attendance",
          className: l("/dashboard/attendance"),
          children: [L.jsx(t1, { size: 20 }), L.jsx("span", { children: "Presensi Kelas" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/journal",
          className: l("/dashboard/journal"),
          children: [L.jsx(qM, { size: 20 }), L.jsx("span", { children: "Kegiatan Guru" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/gradebook",
          className: l("/dashboard/gradebook"),
          children: [L.jsx(JM, { size: 20 }), L.jsx("span", { children: "Buku Nilai" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/descriptions",
          className: l("/dashboard/descriptions"),
          children: [L.jsx(KM, { size: 20 }), L.jsx("span", { children: "Deskripsi Rapor" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/leger",
          className: l("/dashboard/leger"),
          children: [L.jsx(WM, { size: 20 }), L.jsx("span", { children: "Leger Nilai" })],
         }),
        ],
       }),
      u(["ADMIN"]) &&
       L.jsxs(L.Fragment, {
        children: [
         L.jsx("div", {
          className: "text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2 px-4 mt-4",
          children: "Administrator",
         }),
         L.jsxs(rt, {
          to: "/dashboard/schedule",
          className: l("/dashboard/schedule"),
          children: [L.jsx(zM, { size: 20 }), L.jsx("span", { children: "Jadwal Pelajaran" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/users",
          className: l("/dashboard/users"),
          children: [L.jsx(r1, { size: 20 }), L.jsx("span", { children: "Data Pengguna" })],
         }),
         L.jsxs(rt, {
          to: "/dashboard/settings",
          className: l("/dashboard/settings"),
          children: [L.jsx(e1, { size: 20 }), L.jsx("span", { children: "Pengaturan Sekolah" })],
         }),
        ],
       }),
     ],
    }),
    L.jsx("div", {
     className: "p-4 border-t border-slate-100",
     children: L.jsxs("button", {
      onClick: s,
      className: "flex items-center gap-3 px-4 py-3 w-full text-red-500 hover:bg-red-50 rounded-lg transition-colors",
      children: [L.jsx(jp, { size: 20 }), L.jsx("span", { children: "Keluar" })],
     }),
    }),
   ],
  });
 },
 H7 = ({ onLogout: t }) => {
  const e = Ao(),
   n = Xd(),
   r = (o) => e.pathname === o,
   i = () => {
    vl
     .fire({
      title: "Keluar?",
      text: "Anda akan keluar dari aplikasi.",
      icon: "question",
      showCancelButton: !0,
      confirmButtonText: "Ya, Keluar",
      confirmButtonColor: "#ef4444",
     })
     .then((o) => {
      o.isConfirmed && (t(), n("/"));
     });
   };
  return L.jsxs("div", {
   className: "min-h-screen bg-slate-50 pb-20 md:pb-0",
   children: [
    L.jsx("div", {
     className: "max-w-md mx-auto bg-white min-h-screen shadow-2xl overflow-hidden relative",
     children: L.jsx(DA, {}),
    }),
    L.jsxs("div", {
     className:
      "fixed bottom-0 left-0 w-full bg-white border-t border-slate-200 z-50 flex justify-around items-center py-3 pb-safe md:hidden shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]",
     children: [
      L.jsxs(rt, {
       to: "/student/home",
       className: `flex flex-col items-center gap-1 w-16 ${r("/student/home") ? "text-blue-600" : "text-slate-400 hover:text-slate-600"}`,
       children: [
        L.jsx(YM, { size: 24, strokeWidth: r("/student/home") ? 2.5 : 2 }),
        L.jsx("span", { className: "text-[10px] font-bold", children: "Beranda" }),
       ],
      }),
      L.jsxs(rt, {
       to: "/student/exams",
       className: `flex flex-col items-center gap-1 w-16 ${r("/student/exams") ? "text-blue-600" : "text-slate-400 hover:text-slate-600"}`,
       children: [
        L.jsx(GM, { size: 24, strokeWidth: r("/student/exams") ? 2.5 : 2 }),
        L.jsx("span", { className: "text-[10px] font-bold", children: "Ujian" }),
       ],
      }),
      L.jsxs(rt, {
       to: "/student/profile",
       className: `flex flex-col items-center gap-1 w-16 ${r("/student/profile") ? "text-blue-600" : "text-slate-400 hover:text-slate-600"}`,
       children: [
        L.jsx(n1, { size: 24, strokeWidth: r("/student/profile") ? 2.5 : 2 }),
        L.jsx("span", { className: "text-[10px] font-bold", children: "Profil" }),
       ],
      }),
      L.jsxs("button", {
       onClick: i,
       className: "flex flex-col items-center gap-1 w-16 text-slate-400 hover:text-red-500",
       children: [L.jsx(jp, { size: 24 }), L.jsx("span", { className: "text-[10px] font-bold", children: "Keluar" })],
      }),
     ],
    }),
    L.jsxs("div", {
     className: "hidden md:block fixed top-1/2 left-8 w-64 p-6 bg-white rounded-xl shadow-lg border border-slate-200",
     children: [
      L.jsx("h3", { className: "font-bold text-slate-800 mb-2", children: "Mode Siswa" }),
      L.jsx("p", {
       className: "text-sm text-slate-500 mb-4",
       children: "Tampilan ini dioptimalkan untuk perangkat seluler (Smartphone).",
      }),
      L.jsxs("button", {
       onClick: i,
       className: "text-red-500 text-sm font-bold flex items-center gap-2 hover:underline",
       children: [L.jsx(jp, { size: 16 }), " Logout"],
      }),
     ],
    }),
   ],
  });
 },
 q7 = De.lazy(() => Ge(() => import("./Login-BC3f1UkX.js"), [])),
 G7 = De.lazy(() => Ge(() => import("./DashboardHome-C2mfH2Aj.js"), __vite__mapDeps([0, 1]))),
 z7 = De.lazy(() =>
  Ge(() => import("./QuestionBank-4vpR0hfT.js"), __vite__mapDeps([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))
 ),
 W7 = De.lazy(() => Ge(() => import("./StudentExam-Bu_ZnvWL.js"), __vite__mapDeps([14, 3, 10, 15, 16]))),
 K7 = De.lazy(() => Ge(() => import("./StudentDashboard-CI-qOt-Z.js"), __vite__mapDeps([17, 1]))),
 J7 = De.lazy(() => Ge(() => import("./StudentExamList-CUtuSQTO.js"), __vite__mapDeps([18, 19]))),
 Y7 = De.lazy(() => Ge(() => import("./StudentProfile-ChT2w2lH.js"), __vite__mapDeps([20, 21, 13, 10]))),
 Q7 = De.lazy(() =>
  Ge(() => import("./ExamSessions-UWO1rSwt.js"), __vite__mapDeps([22, 23, 8, 24, 25, 26, 27, 9, 5, 28, 16, 29]))
 ),
 X7 = De.lazy(() => Ge(() => import("./LiveMonitoring-DyqnViSl.js"), __vite__mapDeps([30, 4, 26, 27, 10, 15, 9, 16]))),
 j7 = De.lazy(() => Ge(() => import("./StudentMonitor-CQAjFJUd.js"), __vite__mapDeps([31, 23, 32, 5, 4, 19]))),
 Z7 = De.lazy(() => Ge(() => import("./ReportDescriptions-DyJHwgzB.js"), __vite__mapDeps([33, 23, 5, 34, 32]))),
 eK = De.lazy(() =>
  Ge(() => import("./PacketManager-C2Xm7OEs.js"), __vite__mapDeps([35, 3, 25, 9, 26, 13, 5, 6, 4, 7]))
 ),
 tK = De.lazy(() => Ge(() => import("./UserManagement-MPjDGs5L.js"), __vite__mapDeps([36, 23, 7, 4, 5, 6, 9, 8, 24]))),
 nK = De.lazy(() => Ge(() => import("./ClassAttendance-CD9Vy32v.js"), __vite__mapDeps([37, 23, 9, 13, 5]))),
 rK = De.lazy(() =>
  Ge(() => import("./TeacherJournal-D2CrYiyl.js"), __vite__mapDeps([38, 23, 5, 7, 39, 29, 9, 10, 21]))
 ),
 iK = De.lazy(() => Ge(() => import("./TeacherGradebook-C2CuulEv.js"), __vite__mapDeps([40, 5, 29, 13, 9, 34]))),
 oK = De.lazy(() => Ge(() => import("./LegerNilai-DEODtUQp.js"), __vite__mapDeps([41, 23, 5, 19, 1]))),
 sK = De.lazy(() => Ge(() => import("./SchoolSettings-BEiXl1SY.js"), __vite__mapDeps([42, 43, 13, 7, 9, 27, 16]))),
 aK = De.lazy(() => Ge(() => import("./SchoolSchedule-DL01YS_Q.js"), __vite__mapDeps([44, 10, 13]))),
 lK = De.lazy(() => Ge(() => import("./LearningMaterials-Bv1RAZY_.js"), __vite__mapDeps([45, 7, 29, 9, 43, 11, 39]))),
 uK = De.lazy(() => Ge(() => import("./ExamAnalysis-Br8lDBvy.js"), __vite__mapDeps([46, 3, 12, 28]))),
 cK = De.lazy(() => Ge(() => import("./TeacherProfile-D2WrIX5v.js"), __vite__mapDeps([47, 13, 10, 7, 9, 21, 29]))),
 tp = () =>
  L.jsxs("div", {
   className: "min-h-screen flex flex-col items-center justify-center bg-slate-50 text-slate-400 gap-3",
   children: [
    L.jsx("i", { className: "fa-solid fa-circle-notch fa-spin text-3xl text-blue-500" }),
    L.jsx("p", { className: "text-sm font-medium animate-pulse", children: "Memuat Halaman..." }),
   ],
  }),
 dK = () => {
  const [t, e] = W.useState(null),
   [n, r] = W.useState(!0);
  W.useEffect(() => {
   const h = RO(Yi, async (p) => {
    var m, v;
    if (p)
     try {
      const w = await qm.getUserById(p.uid);
      if (w) e(w);
      else {
       const C = ((m = p.email) == null ? void 0 : m.toLowerCase()) || "";
       let A = "Siswa";
       C.includes("admin")
        ? (A = "Admin")
        : C.includes("guru") || C.includes("teacher") || C.includes("pengajar")
          ? (A = "Guru")
          : C.includes("piket") && (A = "Piket"),
        e({
         id: p.uid,
         nama: p.displayName || ((v = p.email) == null ? void 0 : v.split("@")[0]) || "User",
         email: p.email || "",
         role: A,
         status: "aktif",
        });
      }
     } catch (w) {
      console.error("Error fetching user details", w);
     }
    else e(null);
    r(!1);
   });
   return () => h();
  }, []);
  const i = (h) => {
    e(h);
   },
   o = async () => {
    try {
     await qm.logout(), e(null);
    } catch (h) {
     console.error("Logout failed", h);
    }
   },
   s = (h) => {
    const p = (h.role || "").toLowerCase();
    return p === "siswa" || p === "student" || p === "murid";
   },
   a = (h) => {
    const p = (h.role || "").toLowerCase();
    return p === "guru" || p === "teacher" || p === "admin" || p === "staf" || p === "piket";
   },
   l = () =>
    t
     ? s(t)
       ? L.jsx(Jn, { to: "/student/home", replace: !0 })
       : L.jsxs("div", {
          className: "flex min-h-screen bg-slate-50",
          children: [
           L.jsx($7, { onLogout: o, userRole: t.role }),
           L.jsx("main", {
            className: "flex-1 ml-64 p-8",
            children: L.jsx(W.Suspense, { fallback: L.jsx(tp, {}), children: L.jsx(DA, {}) }),
           }),
          ],
         })
     : L.jsx(Jn, { to: "/", replace: !0 }),
   u = () =>
    t
     ? a(t)
       ? L.jsx(Jn, { to: "/dashboard", replace: !0 })
       : L.jsx(H7, { onLogout: o })
     : L.jsx(Jn, { to: "/", replace: !0 });
  return n
   ? L.jsx(tp, {})
   : L.jsx(MM, {
      children: L.jsx(W.Suspense, {
       fallback: L.jsx(tp, {}),
       children: L.jsxs(CM, {
        children: [
         L.jsx(Te, {
          path: "/",
          element: t
           ? s(t)
             ? L.jsx(Jn, { to: "/student/home", replace: !0 })
             : L.jsx(Jn, { to: "/dashboard", replace: !0 })
           : L.jsx(q7, { onLogin: i }),
         }),
         L.jsxs(Te, {
          path: "/student",
          element: L.jsx(u, {}),
          children: [
           L.jsx(Te, { index: !0, element: L.jsx(Jn, { to: "/student/home", replace: !0 }) }),
           L.jsx(Te, { path: "portal", element: L.jsx(Jn, { to: "/student/home", replace: !0 }) }),
           L.jsx(Te, { path: "home", element: L.jsx(K7, {}) }),
           L.jsx(Te, { path: "exams", element: L.jsx(J7, {}) }),
           L.jsx(Te, { path: "profile", element: L.jsx(Y7, {}) }),
          ],
         }),
         L.jsx(Te, { path: "/student/take-exam", element: t ? L.jsx(W7, {}) : L.jsx(Jn, { to: "/", replace: !0 }) }),
         L.jsxs(Te, {
          path: "/dashboard",
          element: L.jsx(l, {}),
          children: [
           L.jsx(Te, { index: !0, element: L.jsx(G7, {}) }),
           L.jsx(Te, { path: "teacher-profile", element: L.jsx(cK, {}) }),
           L.jsx(Te, { path: "bank", element: L.jsx(z7, {}) }),
           L.jsx(Te, { path: "packets", element: L.jsx(eK, {}) }),
           L.jsx(Te, { path: "sessions", element: L.jsx(Q7, {}) }),
           L.jsx(Te, { path: "monitoring", element: L.jsx(X7, {}) }),
           L.jsx(Te, { path: "student-monitor", element: L.jsx(j7, {}) }),
           L.jsx(Te, { path: "attendance", element: L.jsx(nK, {}) }),
           L.jsx(Te, { path: "users", element: L.jsx(tK, {}) }),
           L.jsx(Te, { path: "journal", element: L.jsx(rK, {}) }),
           L.jsx(Te, { path: "gradebook", element: L.jsx(iK, {}) }),
           L.jsx(Te, { path: "descriptions", element: L.jsx(Z7, {}) }),
           " ",
           L.jsx(Te, { path: "leger", element: L.jsx(oK, {}) }),
           L.jsx(Te, { path: "schedule", element: L.jsx(aK, {}) }),
           L.jsx(Te, { path: "materials", element: L.jsx(lK, {}) }),
           L.jsx(Te, { path: "analysis", element: L.jsx(uK, {}) }),
           L.jsx(Te, { path: "settings", element: L.jsx(sK, {}) }),
           L.jsx(Te, {
            path: "discipline",
            element: L.jsx("div", { className: "p-10 text-slate-400", children: "Fitur Piket (Placeholder)" }),
           }),
           L.jsx(Te, { path: "*", element: L.jsx(Jn, { to: "/dashboard", replace: !0 }) }),
          ],
         }),
        ],
       }),
      }),
     });
 },
 Sb = document.getElementById("root");
if (!Sb) throw new Error("Could not find root element to mount to");
const fK = np.createRoot(Sb);
fK.render(L.jsx(De.StrictMode, { children: L.jsx(dK, {}) }));
export {
 BM as B,
 HM as C,
 WM as F,
 JM as G,
 rt as L,
 jM as M,
 De as R,
 vl as S,
 r1 as U,
 qm as a,
 hK as b,
 nt as c,
 zM as d,
 Yi as e,
 n1 as f,
 rN as g,
 Ao as h,
 FM as i,
 L as j,
 KM as k,
 $M as l,
 e1 as m,
 RO as o,
 W as r,
 Xd as u,
};
